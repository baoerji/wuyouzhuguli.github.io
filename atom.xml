<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>MrBird</title>
  
  <link href="/blog/atom.xml" rel="self"/>
  
  <link href="http://mrbird.cc/"/>
  <updated>2019-02-26T11:28:18.786Z</updated>
  <id>http://mrbird.cc/</id>
  
  <author>
    <name>MrBird</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Java 9 Flow API 学习</title>
    <link href="http://mrbird.cc/Java-9-Flow-API-Learn.html"/>
    <id>http://mrbird.cc/Java-9-Flow-API-Learn.html</id>
    <published>2018-11-10T02:46:14.000Z</published>
    <updated>2019-02-26T11:28:18.786Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Mar 21 2019 09:22:42 GMT+0800 (GMT+08:00) --><p>响应式编程（Reactive Programming）可以理解为一种处理数据项（Data Item）的异步流，即在数据项产生的时候，接收者就对其进行响应。在响应式编程中，会有一个数据发布者（Publisher）和数据订阅者（Subscriber），后者用于异步接收发布者发布的数据。在该模式中，还引入了一个更高级的特性：数据处理器（Processor），它用于将数据发布者发布的数据进行某些转换操作，然后再发布给数据订阅者。</p><p>总之，响应式编程是异步非阻塞编程，能够提升程序性能，可以解决传统编程模型遇到的困境。基于这个模型实现的有Java 9 Flow API、RxJava和Reactor等，这里主要介绍的是Java 9 Flow API的使用。</p><a id="more"></a><h2 id="Flow接口概览"><a href="#Flow接口概览" class="headerlink" title="Flow接口概览"></a>Flow接口概览</h2><p>Java 9 新增了一个<code>Flow</code>接口，位于<code>java.util.concurrent</code>路径下，构成如下图所示：</p><p><img src="img/QQ截图20190226141817.png" alt="QQ截图20190226141817.png"></p><p>其中<code>Publisher</code>为数据发布者，<code>Subscriber</code>为数据订阅者，<code>Subscription</code>为发布者和订阅者之间的订阅关系，<code>Processor</code>为数据处理器。</p><h3 id="Publisher"><a href="#Publisher" class="headerlink" title="Publisher"></a>Publisher</h3><p><code>Publisher</code>部分的源码如下所示:</p><p><img src="img/QQ截图20190226142214.png" alt="QQ截图20190226142214.png"></p><p>它是一个函数式接口，只包含一个<code>subscribe</code>方法，通过这个方法将数据发布出去。</p><h3 id="Subscriber"><a href="#Subscriber" class="headerlink" title="Subscriber"></a>Subscriber</h3><p><code>Subscriber</code>部分的源码如下所示: <img src="img/QQ截图20190226142519.png" alt="QQ截图20190226142519.png"></p><p>该接口包含了四个方法：</p><table><tr><th>方法</th><th>描述</th></tr><tr><td>onSubscribe</td><td>订阅成功的回调方法，用于初始化<code>Subscription</code>，并且表明可以开始接收订阅数据了</td></tr><tr><td>onNext</td><td>接收下一项订阅数据的回调方法</td></tr><tr><td>onError</td><td>在Publisher或Subcriber遇到不可恢复的错误时调用此方法，Subscriber不再接收订阅消息</td></tr><tr><td>onComplete</td><td>当接收完所有订阅数据，并且发布者已经关闭后会回调这个方法</td></tr></table><h3 id="Subscription"><a href="#Subscription" class="headerlink" title="Subscription"></a>Subscription</h3><p><code>Subscription</code>部分的源码如下所示：</p><p><img src="img/QQ截图20190226143424.png" alt="QQ截图20190226143424.png"></p><p>该接口包含了两个方法：</p><table><tr><th>方法</th><th>描述</th></tr><tr><td>request</td><td>用于向数据发布者请求n个数据项</td></tr><tr><td>cancel</td><td>取消消息订阅，订阅者将不再接收数据</td></tr></table><h3 id="Processor"><a href="#Processor" class="headerlink" title="Processor"></a>Processor</h3><p><code>Processor</code>部分的代码如下所示：</p><p><img src="img/QQ截图20190226143709.png" alt="QQ截图20190226143709.png"></p><p>它是一个空接口，但是它继承了<code>Publisher</code>和<code>Subscriber</code>，所以它既能发布数据也能订阅数据。基于这个特性，它可以充当数据转换的角色，先从数据发布者那接收数据项，然后经过处理后再发布给最终的数据订阅者。</p><h2 id="发布订阅示例"><a href="#发布订阅示例" class="headerlink" title="发布订阅示例"></a>发布订阅示例</h2><p>接下来我们举个数据发布和数据订阅的简单示例，以此了解Java 9 Flow API的使用。先入为主，直接贴出整个示例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FlowApiTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">// 1. 定义 String 类型的数据发布者，JDK 9自带的</span></span><br><span class="line">        <span class="comment">// SubmissionPublisher 实现了 Publisher</span></span><br><span class="line">        SubmissionPublisher&lt;String&gt; publisher = <span class="keyword">new</span> SubmissionPublisher&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 创建一个订阅者，用于接收发布者的消息</span></span><br><span class="line">        Subscriber&lt;String&gt; subscriber = <span class="keyword">new</span> Subscriber&lt;&gt;() &#123;</span><br><span class="line">            <span class="keyword">private</span> Subscription subscription;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSubscribe</span><span class="params">(Subscription subscription)</span> </span>&#123;</span><br><span class="line">                <span class="comment">// 通过 Subscription 和发布者保持订阅关系，并用它来给发布者反馈</span></span><br><span class="line">                <span class="keyword">this</span>.subscription = subscription;</span><br><span class="line">                <span class="comment">// 请求一个数据</span></span><br><span class="line">                <span class="keyword">this</span>.subscription.request(<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(String item)</span> </span>&#123;</span><br><span class="line">                <span class="comment">// 接收发布者发布的消息</span></span><br><span class="line">                System.out.println(<span class="string">"【订阅者】接收消息 &lt;------ "</span> + item);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 接收后再次请求一个数据</span></span><br><span class="line">                <span class="keyword">this</span>.subscription.request(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 如果不想再接收数据，也可以直接调用 cancel，表示不再接收了</span></span><br><span class="line">                <span class="comment">// this.subscription.cancel();</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable throwable)</span> </span>&#123;</span><br><span class="line">                <span class="comment">// 过程中出现异常会回调这个方法</span></span><br><span class="line">                System.out.println(<span class="string">"【订阅者】数据接收出现异常，"</span> + throwable);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 出现异常，取消订阅，告诉发布者我不再接收数据了</span></span><br><span class="line">                <span class="comment">// 实际测试发现，只要订阅者接收消息出现异常，进入了这个回调</span></span><br><span class="line">                <span class="comment">// 订阅者就不会再继续接收消息了</span></span><br><span class="line">                <span class="keyword">this</span>.subscription.cancel();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onComplete</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="comment">// 当发布者发出的数据都被接收了，</span></span><br><span class="line">                <span class="comment">// 并且发布者关闭后，会回调这个方法</span></span><br><span class="line">                System.out.println(<span class="string">"【订阅者】数据接收完毕"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 发布者和订阅者需要建立关系</span></span><br><span class="line">        publisher.subscribe(subscriber);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4. 发布者开始发布数据</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            String message = <span class="string">"hello flow api "</span> + i;</span><br><span class="line">            System.out.println(<span class="string">"【发布者】发布消息 ------&gt; "</span> + message);</span><br><span class="line">            publisher.submit(message);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5. 发布结束后，关闭发布者</span></span><br><span class="line">        publisher.close();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// main线程延迟关闭，不然订阅者还没接收完消息，线程就被关闭了</span></span><br><span class="line">        Thread.currentThread().join(<span class="number">2000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面使用JDK 自带的<code>Publisher</code>实现类<code>SubmissionPublisher</code>来发布 String类型的数据，然后用匿名实现类的方式创建了一个<code>Subscriber</code>实现类。接着使用<code>SubmissionPublisher</code>的<code>subscribe</code>方法来为发布者和订阅者建立关系。建立关系后，发布者就可以发布数据，接收者也开始接收数据。详细的说明注释里都写了，这里就不再赘述代码的逻辑了。</p><p>程序的输出如下所示：</p><p><img src="img/QQ截图20190226144617.png" alt="QQ截图20190226144617.png"></p><h2 id="模拟背压"><a href="#模拟背压" class="headerlink" title="模拟背压"></a>模拟背压</h2><p>所谓的<a href="https://en.wikipedia.org/wiki/Back_pressure" target="_blank" rel="noopener">背压</a>（Backpressure）通俗的讲就是数据接收者的压力，传统模式下，发布者只关心数据的创造与发布，而当数据发布速率远高于数据接收速率的时候，数据接收者缓冲区将被填满，无法再接收数据。发布者并不关心这些，依旧不断地发送数据，所以就造成了IO阻塞。</p><p>基于响应式模型实现的Flow API可以很好地解决这个问题。在Java 9的Flow API定义中，<code>Subscriber</code>会将<code>Publisher</code>发布的数据缓冲在<code>Subscription</code>中，其长度默认为256：</p><p><img src="img/QQ截图20190226150028.png" alt="QQ截图20190226150028.png"></p><p>假如当这个缓冲区都被填满后，<code>Publisher</code>将会停止发送数据，直到<code>Subscriber</code>接收了数据<code>Subscription</code>有空闲位置的时候，<code>Publisher</code>才会继续发布数据，而非一味地发个不停。</p><p>下面用代码来演示这个情况：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FlowApiTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">// 1. 定义String类型的数据发布者，JDK 9自带的</span></span><br><span class="line">        <span class="comment">// SubmissionPublisher实现了 Publisher</span></span><br><span class="line">        SubmissionPublisher&lt;String&gt; publisher = <span class="keyword">new</span> SubmissionPublisher&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 创建一个订阅者，用于接收发布者的消息</span></span><br><span class="line">        Subscriber&lt;String&gt; subscriber = <span class="keyword">new</span> Subscriber&lt;&gt;() &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">private</span> Subscription subscription;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSubscribe</span><span class="params">(Subscription subscription)</span> </span>&#123;</span><br><span class="line">                <span class="comment">// 通过 Subscription 和发布者保持订阅关系，并用它来给发布者反馈</span></span><br><span class="line">                <span class="keyword">this</span>.subscription = subscription;</span><br><span class="line">                <span class="comment">// 请求一个数据</span></span><br><span class="line">                <span class="keyword">this</span>.subscription.request(<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(String item)</span> </span>&#123;</span><br><span class="line">                <span class="comment">// 接收发布者发布的消息</span></span><br><span class="line">                System.out.println(<span class="string">"【订阅者】接收消息 &lt;------ "</span> + item);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 模拟接收数据缓慢，让缓冲池填满</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 接收后再次请求一个数据，表示我已经处理完了，你可以再发数据过来了</span></span><br><span class="line">                <span class="keyword">this</span>.subscription.request(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 如果不想再接收数据，也可以直接调用cancel，表示不再接收了</span></span><br><span class="line">                <span class="comment">// this.subscription.cancel();</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable throwable)</span> </span>&#123;</span><br><span class="line">                <span class="comment">// 过程中出现异常会回调这个方法</span></span><br><span class="line">                System.out.println(<span class="string">"【订阅者】数据接收出现异常，"</span> + throwable);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 出现异常，取消订阅，告诉发布者我不再接收数据了</span></span><br><span class="line">                <span class="comment">// 实际测试发现，只要订阅者接收消息出现异常，进入了这个回调</span></span><br><span class="line">                <span class="comment">// 订阅者就不会再继续接收消息了</span></span><br><span class="line">                <span class="keyword">this</span>.subscription.cancel();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onComplete</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="comment">// 当发布者发出的数据都被接收了，</span></span><br><span class="line">                <span class="comment">// 并且发布者关闭后，会回调这个方法</span></span><br><span class="line">                System.out.println(<span class="string">"【订阅者】数据接收完毕"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 发布者和订阅者需要建立关系</span></span><br><span class="line">        publisher.subscribe(subscriber);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4. 发布者开始发布数据</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">500</span>; i++) &#123;</span><br><span class="line">            String message = <span class="string">"hello flow api "</span> + i;</span><br><span class="line">            System.out.println(<span class="string">"【发布者】发布消息 ------&gt; "</span> + message);</span><br><span class="line">            publisher.submit(message);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5. 发布结束后，关闭发布者</span></span><br><span class="line">        publisher.close();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// main线程延迟关闭，不然订阅者还没接收完消息，线程就被关闭了</span></span><br><span class="line">        Thread.currentThread().join(<span class="number">20000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，我们在<code>Subscriber</code>的<code>onNext</code>方法中用下面的代码模拟延迟，让数据处理过程维持在2秒左右：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>然后数据发布量调整到了500，当程序启动的时候，由于数据发布的速度非常快（普通for循环），所以数据订阅者的数据缓冲区瞬间被填满，于是你会看到下面这个情况，只有当数据订阅者处理了一个数据的时候，数据发布者才会相应地再次发布一个新数据：</p><p><img src="img/testasdfasdf.gif" alt="testasdfasdf.gif"></p><h2 id="Processor示例"><a href="#Processor示例" class="headerlink" title="Processor示例"></a>Processor示例</h2><p><code>Processor</code>的使用也很简单，其实它就是<code>Publisher</code>和<code>Subscriber</code>的结合体，充当数据处理的角色，通常的做法是用它来接收发布者发布的消息，然后进行相应的处理，再将数据发布出去，供消息订阅者接收。</p><p>下面是一个<code>Processor</code>用法的简单示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FlowApiTest2</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyProcessor</span> <span class="keyword">extends</span> <span class="title">SubmissionPublisher</span>&lt;<span class="title">String</span>&gt;</span></span><br><span class="line"><span class="class">            <span class="keyword">implements</span> <span class="title">Processor</span>&lt;<span class="title">String</span>, <span class="title">String</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> Subscription subscription;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSubscribe</span><span class="params">(Subscription subscription)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 通过 Subscription 和发布者保持订阅关系，并用它来给发布者反馈</span></span><br><span class="line">            <span class="keyword">this</span>.subscription = subscription;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 请求一个数据</span></span><br><span class="line">            <span class="keyword">this</span>.subscription.request(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(String item)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 接收发布者发布的消息</span></span><br><span class="line">            System.out.println(<span class="string">"【处理器】接收消息 &lt;------ "</span> + item);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 处理器将消息进行转换</span></span><br><span class="line">            String newItem = <span class="string">"【处理器加工后的数据: "</span> + item + <span class="string">"】"</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">this</span>.submit(newItem);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 接收后再次请求一个数据，表示我已经处理完了，你可以再发数据过来了</span></span><br><span class="line">            <span class="keyword">this</span>.subscription.request(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果不想再接收数据，也可以直接调用cancel，表示不再接收了</span></span><br><span class="line">            <span class="comment">// this.subscription.cancel();</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable throwable)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 过程中出现异常会回调这个方法</span></span><br><span class="line">            System.out.println(<span class="string">"【处理器】数据接收出现异常，"</span> + throwable);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 出现异常，取消订阅，告诉发布者我不再接收数据了</span></span><br><span class="line">            <span class="keyword">this</span>.subscription.cancel();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onComplete</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"【处理器】数据处理完毕"</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 处理器处理完数据后关闭</span></span><br><span class="line">            <span class="keyword">this</span>.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">// 1. 定义String类型的数据发布者，JDK 9自带的</span></span><br><span class="line">        <span class="comment">// SubmissionPublisher实现了 Publisher</span></span><br><span class="line">        SubmissionPublisher&lt;String&gt; publisher = <span class="keyword">new</span> SubmissionPublisher&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 创建处理器，用于接收发布者发布的消息，</span></span><br><span class="line">        <span class="comment">// 转换后再发送给订阅者</span></span><br><span class="line">        MyProcessor processor = <span class="keyword">new</span> MyProcessor();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 发布者和处理器建立订阅的关系</span></span><br><span class="line">        publisher.subscribe(processor);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4.创建一个订阅者，用于接收处理器的消息</span></span><br><span class="line">        Subscriber&lt;String&gt; subscriber = <span class="keyword">new</span> Subscriber&lt;&gt;() &#123;</span><br><span class="line">            <span class="keyword">private</span> Subscription subscription;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSubscribe</span><span class="params">(Subscription subscription)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">this</span>.subscription = subscription;</span><br><span class="line">                <span class="keyword">this</span>.subscription.request(<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(String item)</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"【订阅者】接收消息 &lt;------ "</span> + item + <span class="string">""</span>);</span><br><span class="line">                <span class="keyword">this</span>.subscription.request(<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable throwable)</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"【订阅者】数据接收出现异常，"</span> + throwable);</span><br><span class="line">                <span class="keyword">this</span>.subscription.cancel();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onComplete</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"【订阅者】数据接收完毕"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5. 处理器和订阅者建立订阅关系</span></span><br><span class="line">        processor.subscribe(subscriber);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 6. 发布者开始发布数据</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            String message = <span class="string">"hello flow api "</span> + i;</span><br><span class="line">            System.out.println(<span class="string">"【发布者】发布消息 ------&gt; "</span> + message);</span><br><span class="line">            publisher.submit(message);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 7. 发布结束后，关闭发布者</span></span><br><span class="line">        publisher.close();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// main线程延迟关闭，不然订阅者还没接收完消息，线程就被关闭了</span></span><br><span class="line">        Thread.currentThread().join(<span class="number">2000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>程序运行结果如下所示：</p><p><img src="img/QQ截图20190226151701.png" alt="QQ截图20190226151701.png"></p><blockquote><p>参考文档：<a href="https://community.oracle.com/docs/DOC-1006738" target="_blank" rel="noopener">https://community.oracle.com/docs/DOC-1006738</a></p></blockquote><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Thu Mar 21 2019 09:22:42 GMT+0800 (GMT+08:00) --&gt;&lt;p&gt;响应式编程（Reactive Programming）可以理解为一种处理数据项（Data Item）的异步流，即在数据项产生的时候，接收者就对其进行响应。在响应式编程中，会有一个数据发布者（Publisher）和数据订阅者（Subscriber），后者用于异步接收发布者发布的数据。在该模式中，还引入了一个更高级的特性：数据处理器（Processor），它用于将数据发布者发布的数据进行某些转换操作，然后再发布给数据订阅者。&lt;/p&gt;&lt;p&gt;总之，响应式编程是异步非阻塞编程，能够提升程序性能，可以解决传统编程模型遇到的困境。基于这个模型实现的有Java 9 Flow API、RxJava和Reactor等，这里主要介绍的是Java 9 Flow API的使用。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java" scheme="http://mrbird.cc/tags/Java/"/>
    
      <category term="Java 9" scheme="http://mrbird.cc/tags/Java-9/"/>
    
  </entry>
  
  <entry>
    <title>Java 10 新特性之var</title>
    <link href="http://mrbird.cc/Java10-new-feature-var.html"/>
    <id>http://mrbird.cc/Java10-new-feature-var.html</id>
    <published>2018-11-05T07:16:50.000Z</published>
    <updated>2019-02-15T06:24:13.399Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Mar 21 2019 09:22:41 GMT+0800 (GMT+08:00) --><p>今年3月，Java 10 如期发布，Java 10 是采用新发布周期的第一个版本，提供了 109 项新特性，其中最备受关注的莫过于局部变量的类型推断。所以这里主要记录一下这个特性的用法。</p><a id="more"></a><p>看几个Java 10之前声明变量的例子:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">Stream&lt;String&gt; stream = list.stream();</span><br><span class="line"></span><br><span class="line">InputStreamReader reader = <span class="keyword">new</span> InputStreamReader(System.in);</span><br><span class="line">HttpClient httpClient = HttpClient.newHttpClient();</span><br></pre></td></tr></table></figure><p></p><p>在Java 10 中，只要是编译器能够通过对象类型来确定变量类型的情况下，变量类型声明可以使用<code>var</code>保留字代替：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="keyword">var</span> stream = list.stream();</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> reader = <span class="keyword">new</span> InputStreamReader(System.in);</span><br><span class="line"><span class="keyword">var</span> httpClient = HttpClient.newHttpClient();</span><br></pre></td></tr></table></figure><p></p><p>引入这个特性使得我们的Java 代码变得更加的简洁易读。除此之外我们也可以在增强<code>for</code>循环中使用<code>var</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">list.add(<span class="string">"hello"</span>);</span><br><span class="line">list.add(<span class="string">"java 10"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> s : list) System.out.println(s);</span><br></pre></td></tr></table></figure><p></p><p>当然，<code>var</code>并不是在何时何地都能使用，用于变量声明时，仅局限于具有构造器的变量或基本数据类型，比如下面这些例子编译是不通过的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a;</span><br><span class="line">a = <span class="string">"hello world"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> b = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br></pre></td></tr></table></figure><p>编译器将会告警：</p><p><img src="img/QQ截图20190214164317.png" alt="QQ截图20190214164317.png"></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Thu Mar 21 2019 09:22:41 GMT+0800 (GMT+08:00) --&gt;&lt;p&gt;今年3月，Java 10 如期发布，Java 10 是采用新发布周期的第一个版本，提供了 109 项新特性，其中最备受关注的莫过于局部变量的类型推断。所以这里主要记录一下这个特性的用法。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java" scheme="http://mrbird.cc/tags/Java/"/>
    
      <category term="Java 10" scheme="http://mrbird.cc/tags/Java-10/"/>
    
  </entry>
  
  <entry>
    <title>Java 9 新特性学习</title>
    <link href="http://mrbird.cc/Java-9-Feature.html"/>
    <id>http://mrbird.cc/Java-9-Feature.html</id>
    <published>2018-11-02T00:50:59.000Z</published>
    <updated>2019-02-14T07:12:22.428Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Mar 21 2019 09:22:42 GMT+0800 (GMT+08:00) --><p>在Java 8 发布3年多后，Java 9 终于在2017年9月21日正式发布。Java 9 提供了超过150项新功能特性，包括备受期待的模块化系统、 可交互的REPL工具jShell、JDK编译工具、Java公共API和私有代码，以及安全增强、扩展提升和性能管理改善等。在学习这些新特性之前，我们得先安装好JDK 9，JDK 9 下载地址：<a href="https://www.oracle.com/technetwork/cn/java/javase/downloads/jdk9-downloads-3848520-zhs.html" target="_blank" rel="noopener">https://www.oracle.com/technetwork/cn/java/javase/downloads/jdk9-downloads-3848520-zhs.html</a>。<a id="more"></a></p><h2 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h2><p>Java 9 中的模块化（Module）类似于ES6中的模块化，都是为了解决项目中减少内存的开销，提供可维护性和系统性能而提出的。通俗地说，Java 9 的模块化本质上就是在包（package）上再包裹一层（Module），默认模块里的内容都是隐藏的，只能通过（exports）关键字来暴露模块里的内容，而别的模块需要用到这些内容则需要使用（requires）关键字来导入。</p><p>下面我们用代码来演示这一个新特性。</p><p>新建一个Java 工程，然后在工程下面创建一个名为<strong>ModuleOne</strong>的模块：</p><p><img src="img/QQ截图20190213094527.png" alt="QQ截图20190213094527.png"></p><p>同样的，我们再创建一个<strong>ModuleTwo</strong>模块，创建完后项目目录如下所示：</p><p><img src="img/QQ截图20190213094722.png" alt="QQ截图20190213094722.png"></p><p>接着我们在ModuleOne的src目录下创建<code>cc.mrbird.domain</code>包，并创建一个名为Person的类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cc.mrbird.domain;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Person&#123;"</span> +</span><br><span class="line">                <span class="string">"name='"</span> + name + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">", age="</span> + age +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>然后在ModuleTwo的src目录下创建一个<code>cc.mrbid.test</code>包，并且创建一个Test类，用于待会测试。</p><p>至此，工程目录结构如下所示:</p><p><img src="img/QQ截图20190213095358.png" alt="QQ截图20190213095358.png"></p><p>我们在ModuleTwo的Test类下试图引入ModuleOne的Person类，会发现是行不通的：</p><p><img src="img/QQ截图20190213095624.png" alt="QQ截图20190213095624.png"></p><p>正如上面所说，模块里的东西默认都是隐藏的，要让其可以被别的模块使用，需要通过<strong>exports</strong>关键字来暴露它们。</p><p>在ModuleOne模块下的src上右键，新建一个module-info.java：</p><p><img src="img/QQ截图20190213095840.png" alt="QQ截图20190213095840.png"></p><p>代码如下所示:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> ModuleOne &#123;</span><br><span class="line">    <span class="comment">// 导出包</span></span><br><span class="line">    <span class="keyword">exports</span> cc.mrbird.domain;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>上面代码中导出了<code>cc.mrbird.domain</code>包下的所有内容，对别的模块来说，它们是可见的了。</p><p>然后同样地在ModuleTwo模块下的src上右键，也新建一个module-info.java，代码如下所示:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> ModuleTwo &#123;</span><br><span class="line">    <span class="comment">// 导入模块</span></span><br><span class="line">    <span class="keyword">requires</span> ModuleOne;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们主要做的是将ModuleOne导入进来，所以其暴露的<code>cc.mrbird.domain</code>包下的内容就可以在ModuleTwo下被使用了。</p><p>这时候回到ModuleTwo模块下的Test类，IDEA会自动帮我们导入需要的类，代码就不会报错了：</p><p><img src="img/QQ截图20190213100532.png" alt="QQ截图20190213100532.png"></p><p>我们继续在Test类中加入一些内容：</p><p><img src="img/QQ截图20190213101203.png" alt="QQ截图20190213101203.png"></p><p>上面我们使用了<code>java.util.logging.Logger</code>来打印日志，但是代码编译是不通过的，使用<code>Alt+Enter</code>快捷键后选择第一项，IDEA会自动帮我们在module-info.java文件中导入需要的包，非常方便。</p><p>导入后，module-info.java下的代码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> ModuleTwo &#123;</span><br><span class="line">    <span class="comment">// 导入模块</span></span><br><span class="line">    <span class="keyword">requires</span> ModuleOne;</span><br><span class="line">    <span class="keyword">requires</span> java.logging;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>总的来说，通过模块化来构建项目可以带来以下好处:</p><ol><li><p>减少内存的开销；</p></li><li><p>简化各种类库和大型应用的开发和维护；</p></li><li><p>改进其安全性，可维护性，提高性能。</p></li></ol><h2 id="jshell命令"><a href="#jshell命令" class="headerlink" title="jshell命令"></a>jshell命令</h2><p>在Java 9 之前，我们要想使用Java来输出一句hello world或者计算两个数的和都必须创建一个Java项目，然后创建类在里面写main方法来运行。Java 9 后就不必这样了，其提供了REPL工具：jshell。利用 jshell 在没有创建类的情况下直接声明变量，计算表达式，执行语句。即开发时可以在命令行里直接运行 Java 的代码，而无需创建 Java 文件。</p><p>在JDK 9 的bin目录下有个jshell.exe文件，我们运行它：</p><p><img src="img/QQ截图20190213103825.png" alt="QQ截图20190213103825.png"></p><p>下面演示一些jshell的常用操作。</p><p><strong>基本使用</strong></p><p><img src="img/QQ截图20190213104253.png" alt="QQ截图20190213104253.png"></p><div class="note info"><p>在jshell中，代码末尾的<code>;</code>是可选的。</p></div><p><strong>导包操作</strong></p><p><img src="img/QQ截图20190213104534.png" alt="QQ截图20190213104534.png"></p><p><strong>查看所有已经导入的包</strong></p><p><img src="img/QQ截图20190213104610.png" alt="QQ截图20190213104610.png"></p><p><strong>使用Tab键补全代码</strong></p><p><img src="img/QQ截图20190213104732.png" alt="QQ截图20190213104732.png"></p><p><strong>查看当前环境下所有有效代码</strong></p><p><img src="img/QQ截图20190213104840.png" alt="QQ截图20190213104840.png"></p><p><strong>查看当前环境下所有变量</strong></p><p><img src="img/QQ截图20190213104941.png" alt="QQ截图20190213104941.png"></p><p><strong>查看当前环境下所有方法</strong></p><p><img src="img/QQ截图20190213105231.png" alt="QQ截图20190213105231.png"></p><p><strong>使用外部代码编辑器来修改add方法</strong></p><p><img src="img/QQ截图20190213105412.png" alt="QQ截图20190213105412.png"></p><p>界面弹出：</p><p><img src="img/QQ截图20190213105500.png" alt="QQ截图20190213105500.png"></p><p>修改完毕点击Accept和Exit按钮即可：</p><p><img src="img/QQ截图20190213105553.png" alt="QQ截图20190213105553.png"></p><p><strong>加载外部代码</strong></p><p>在桌面新建一个Hello.java文件：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"hello world"</span>);</span><br><span class="line">&#125;</span><br><span class="line">hello();</span><br></pre></td></tr></table></figure><p></p><p>然后使用<code>/open</code>命令执行这个文件：</p><p><img src="img/QQ截图20190213110050.png" alt="QQ截图20190213110050.png"></p><p>更多关于jshell的功能介绍，可以使用<code>/help</code>命令来查看。</p><h2 id="接口中的私有方法"><a href="#接口中的私有方法" class="headerlink" title="接口中的私有方法"></a>接口中的私有方法</h2><p>我们都知道，在JDK 8之前，接口只能包含<code>public static final</code>的成员变量和<code>public abstract</code>修饰的抽象方法；而在JDK 8中，接口中可以定义静态方法和默认方法了；JDK 9的接口又加了新的特性，其允许接口中包含私有的方法，下面这个接口定义在JDK 9 中是合法的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">TestInterface</span> </span>&#123;</span><br><span class="line">    <span class="comment">// before jdk 7 :</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// jdk 8:</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"mehtod2"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">method3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"mehtod3"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// jdk 9:</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">method4</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"mehtod4"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h2 id="Diamond-Operator使用升级"><a href="#Diamond-Operator使用升级" class="headerlink" title="Diamond Operator使用升级"></a>Diamond Operator使用升级</h2><p>在Java 9 之前的版本中，我们不能将钻石操作符（Diamond Operator）和匿名实现类放在一起使用，比如下面这个例子在Java 9 之前的版本中编译是不通过的：</p><p><img src="img/QQ截图20190214091025.png" alt="QQ截图20190214091025.png"></p><p>而在Java 9中取消了这个限制，我们可以通过这个特性来进行一些初始化操作:</p><p><img src="img/QQ截图20190214091154.png" alt="QQ截图20190214091154.png"></p><h2 id="try使用升级"><a href="#try使用升级" class="headerlink" title="try使用升级"></a>try使用升级</h2><p>在Java 9 之前，我们可以使用下面这种优雅的方式来进行流的关闭操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> (InputStreamReader reader = <span class="keyword">new</span> InputStreamReader(System.in)) &#123;</span><br><span class="line">    reader.read();</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>在<code>try</code>后面的括号中声明初始化的流Java会自动帮我们进行关闭操作。Java 9 对这个特性进行了升级，我们可以在<code>try</code>后面的括号中使用已经初始化过的资源，此时的资源是<code>final</code>的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">InputStreamReader reader = <span class="keyword">new</span> InputStreamReader(System.in);</span><br><span class="line"><span class="keyword">try</span> (reader) &#123;</span><br><span class="line">    reader.read();</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>如果对<code>reader</code>再次进行赋值操作，编译将不通过：</p><p><img src="img/QQ截图20190214093344.png" alt="QQ截图20190214093344.png"></p><h2 id="下划线标识符的限制"><a href="#下划线标识符的限制" class="headerlink" title="下划线标识符的限制"></a>下划线标识符的限制</h2><p>Java 8 中，我们可以使用下划线<code>_</code>作为标识符使用，比如下面这段代码是合法的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String _ = <span class="string">"mrbird"</span>;</span><br><span class="line">System.out.println(_);</span><br></pre></td></tr></table></figure><p></p><p>而在Java 9 中，下划线<code>_</code>已经不能用于标识符了：</p><p><img src="img/QQ截图20190214094709.png" alt="QQ截图20190214094709.png"></p><h2 id="String存储结构变更"><a href="#String存储结构变更" class="headerlink" title="String存储结构变更"></a>String存储结构变更</h2><p>Java 9 之前，字符串的底层是用<code>char[]</code>进行存储的，Java 9 中，字符串改用成了<code>byte[]</code>进行存储:</p><p><img src="img/QQ截图20190214101945.png" alt="QQ截图20190214101945.png"></p><p>之所以做出这个改变是因为：大多数<code>String</code>类型对象存储的都是拉丁字符，这些字符只占一个字节，而<code>char</code>能够存储两个字节，所以大部分情况下都浪费了一半的存储空间。Java 9 将<code>String</code>类的内部表示从<code>UTF-16</code>的<code>char</code>数组更改为<code>byte</code>数组加上<code>encoding-flag</code>字段。新<code>String</code>类将根据字符串的内容存储编码为<code>ISO-8859-1</code> / Latin-1（每个字符一个字节）或<code>UTF-16</code>（每个字符两个字节）的字符。<code>encoding-flag</code>编码标志将指示使用哪种编码。</p><p>基于<code>String</code>的类如<code>StringBuffer</code>和<code>StringBuilder</code>等也是做出了相同的改变。</p><p>具体可参考：<a href="http://openjdk.java.net/jeps/254" target="_blank" rel="noopener">http://openjdk.java.net/jeps/254</a>。</p><h2 id="集合的of方法"><a href="#集合的of方法" class="headerlink" title="集合的of方法"></a>集合的<code>of</code>方法</h2><p>Java 9 之前我们可以使用下面的方式来创建不可变集合：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; list = Collections.unmodifiableList(Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>));</span><br><span class="line"></span><br><span class="line">Set&lt;Integer&gt; set = Collections.unmodifiableSet(<span class="keyword">new</span> HashSet&lt;&gt;(Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)));</span><br><span class="line"></span><br><span class="line">Map&lt;String, Object&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">map.put(<span class="string">"mrbird"</span>, <span class="number">18</span>);</span><br><span class="line">map.put(<span class="string">"kangkang"</span>, <span class="number">20</span>);</span><br><span class="line">Map&lt;String, Object&gt; map1 = Collections.unmodifiableMap(map);</span><br></pre></td></tr></table></figure><p></p><p>Java 9 中的集合类都添加了一个<code>of</code>方法，可以快速的构造不可变集合：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; list = List.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">Set&lt;Integer&gt; set = Set.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">Map&lt;String, Object&gt; map1 = Map.of(<span class="string">"mrbird"</span>, <span class="number">18</span>, <span class="string">"kangkang"</span>, <span class="number">20</span>);</span><br></pre></td></tr></table></figure><p></p><p>对不可变集合进行赋值操作将抛出异常：</p><p><img src="img/QQ截图20190214112738.png" alt="QQ截图20190214112738.png"></p><h2 id="增强的Steam-API"><a href="#增强的Steam-API" class="headerlink" title="增强的Steam API"></a>增强的Steam API</h2><p>在 Java 9 中，Stream API变得更好，Stream接口中添加了 4 个新的方法：<code>dropWhile</code>, <code>takeWhile</code>, <code>ofNullable</code>，还有个 <code>iterate</code>方法的新重载方法，可以让你提供一个<code>Predicate</code>（判断条件）来指定什么时候结束迭代。</p><p>下面举例来演示这几个的用法：</p><p><strong>takeWhile</strong></p><p>takeWhile用于从Stream中获取一部分数据，接收一个Predicate来进行选择。在有序的Stream中，takeWhile返回从开头开始的尽量多的元素。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; list = Arrays.asList(<span class="number">45</span>, <span class="number">43</span>, <span class="number">76</span>, <span class="number">87</span>, <span class="number">42</span>, <span class="number">77</span>, <span class="number">90</span>, <span class="number">73</span>, <span class="number">67</span>, <span class="number">88</span>);</span><br><span class="line">list.stream().takeWhile(x -&gt; x &lt; <span class="number">50</span>).forEach(System.out::println);</span><br></pre></td></tr></table></figure><p></p><p>结果输出:</p><p><img src="img/QQ截图20190214135831.png" alt="QQ截图20190214135831.png"></p><p>程序从头开始判断当前值是否小于50，当判断到第三个元素76时，发现不满足，于是程序就结束了。所以<code>takeWhile</code>不同于过滤器。</p><p><strong>dropWhile</strong></p><p>dropWhile的行为与takeWhile相反，返回剩余的元素：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; list = Arrays.asList(<span class="number">45</span>, <span class="number">43</span>, <span class="number">76</span>, <span class="number">87</span>, <span class="number">42</span>, <span class="number">77</span>, <span class="number">90</span>, <span class="number">73</span>, <span class="number">67</span>, <span class="number">88</span>);</span><br><span class="line">list.stream().dropWhile(x -&gt; x &lt; <span class="number">50</span>).forEach(System.out::println);</span><br></pre></td></tr></table></figure><p></p><p>程序输出:</p><p><img src="img/QQ截图20190214140313.png" alt="QQ截图20190214140313.png"></p><p><strong>ofNullable</strong></p><p>Java 8 中Stream不能完全为null（只有一个元素，且为null），否则会报空指针异常。而Java 9 中的ofNullable 方法允许我们创建一个单元素 Stream，可以包含一个非空元素，也可以创建一个空 Stream：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 报 NullPointerException</span></span><br><span class="line"><span class="comment">// Stream&lt;Object&gt; stream1 = Stream.of(null);</span></span><br><span class="line"><span class="comment">// System.out.println(stream1.count());</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 不报异常，允许通过</span></span><br><span class="line">Stream&lt;String&gt; stringStream = Stream.of(<span class="string">"AA"</span>, <span class="string">"BB"</span>, <span class="keyword">null</span>);</span><br><span class="line">System.out.println(stringStream.count()); <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 不报异常，允许通过</span></span><br><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">list.add(<span class="string">"AA"</span>);</span><br><span class="line">list.add(<span class="keyword">null</span>);</span><br><span class="line">System.out.println(list.stream().count()); <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ofNullable()：允许值完全为 null</span></span><br><span class="line">Stream&lt;Object&gt; stream1 = Stream.ofNullable(<span class="keyword">null</span>);</span><br><span class="line">System.out.println(stream1.count()); <span class="comment">// 0</span></span><br><span class="line"></span><br><span class="line">Stream&lt;String&gt; stream = Stream.ofNullable(<span class="string">"hello world"</span>);</span><br><span class="line">System.out.println(stream.count()); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><p></p><p><strong>Steam iterator的重载方法</strong></p><p><img src="img/QQ截图20190214141552.png" alt="QQ截图20190214141552.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Java 8 中的</span></span><br><span class="line">Stream.iterate(<span class="number">0</span>, x -&gt; x + <span class="number">1</span>).limit(<span class="number">10</span>).forEach(System.out::println);</span><br><span class="line"><span class="comment">// 等价于 Java 9 中的</span></span><br><span class="line">Stream.iterate(<span class="number">0</span>, x -&gt; x &lt; <span class="number">10</span>, x -&gt; x + <span class="number">1</span>).forEach(System.out::println);</span><br></pre></td></tr></table></figure><p>除了上面几个新特性外，Java 9 还支持将optional转换为流的操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">list.add(<span class="string">"mrbird"</span>);</span><br><span class="line">list.add(<span class="string">"kangkang"</span>);</span><br><span class="line">list.add(<span class="string">"maria"</span>);</span><br><span class="line"></span><br><span class="line">Optional&lt;List&lt;String&gt;&gt; optional = Optional.of(list);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 流中的元素为 list</span></span><br><span class="line">Stream&lt;List&lt;String&gt;&gt; stream = optional.stream();</span><br><span class="line">stream.forEach(System.out::println);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 流中的元素为 list中的每个元素</span></span><br><span class="line">Stream&lt;String&gt; stringStream = optional.stream().flatMap(Collection::stream);</span><br><span class="line">stringStream.forEach(System.out::println);</span><br></pre></td></tr></table></figure><p></p><p>程序输出：</p><p><img src="img/QQ截图20190214143228.png" alt="QQ截图20190214143228.png"></p><h2 id="HTTP-Client"><a href="#HTTP-Client" class="headerlink" title="HTTP Client"></a>HTTP Client</h2><p>Java 9 中新增了全新的<code>HttpClient</code>来替代<code>HttpURLConnection</code>，其可以从<code>jdk.incubator.httpclient</code>模块中获取。因为在默认情况下，这个模块是不能根据<code>classpath</code>获取的，需要使用<code>add modules</code>命令选项配置这个模块，将这个模块添加到 classpath中。</p><p>我们在src下的module-info.java中引入这个模块：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">requires</span> jdk.incubator.httpclient;</span><br></pre></td></tr></table></figure><p></p><p>写个基于<code>HttpClient</code>的例子:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">HttpClient client = HttpClient.newHttpClient();</span><br><span class="line">HttpRequest req = HttpRequest.newBuilder(URI.create(<span class="string">"https://mrbird.cc"</span>))</span><br><span class="line">                .GET()</span><br><span class="line">                .build();</span><br><span class="line">HttpResponse&lt;String&gt; response = client.send(req, HttpResponse.BodyHandler.asString());</span><br><span class="line">System.out.println(response.statusCode());</span><br><span class="line">System.out.println(response.version().name());</span><br><span class="line">System.out.println(response.body());</span><br></pre></td></tr></table></figure><p></p><p>输出结果：</p><p><img src="img/QQ截图20190214145555.png" alt="QQ截图20190214145555.png"></p><blockquote><p>参考自：<a href="https://www.jianshu.com/u/5f70a16b98e7" target="_blank" rel="noopener">https://www.jianshu.com/u/5f70a16b98e7</a></p></blockquote><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Thu Mar 21 2019 09:22:42 GMT+0800 (GMT+08:00) --&gt;&lt;p&gt;在Java 8 发布3年多后，Java 9 终于在2017年9月21日正式发布。Java 9 提供了超过150项新功能特性，包括备受期待的模块化系统、 可交互的REPL工具jShell、JDK编译工具、Java公共API和私有代码，以及安全增强、扩展提升和性能管理改善等。在学习这些新特性之前，我们得先安装好JDK 9，JDK 9 下载地址：&lt;a href=&quot;https://www.oracle.com/technetwork/cn/java/javase/downloads/jdk9-downloads-3848520-zhs.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.oracle.com/technetwork/cn/java/javase/downloads/jdk9-downloads-3848520-zhs.html&lt;/a&gt;。
    
    </summary>
    
    
      <category term="Java" scheme="http://mrbird.cc/tags/Java/"/>
    
      <category term="Java 9" scheme="http://mrbird.cc/tags/Java-9/"/>
    
  </entry>
  
  <entry>
    <title>Spring Boot 中的异步调用</title>
    <link href="http://mrbird.cc/Spring-Boot-Async.html"/>
    <id>http://mrbird.cc/Spring-Boot-Async.html</id>
    <published>2018-10-15T06:42:06.000Z</published>
    <updated>2019-03-13T10:47:59.075Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Mar 21 2019 09:22:42 GMT+0800 (GMT+08:00) --><p>通常我们开发的程序都是同步调用的，即程序按照代码的顺序一行一行的逐步往下执行，每一行代码都必须等待上一行代码执行完毕才能开始执行。而异步编程则没有这个限制，代码的调用不再是阻塞的。所以在一些情景下，通过异步编程可以提高效率，提升接口的吞吐量。这节将介绍如何在Spring Boot中进行异步编程。</p><a id="more"></a><h2 id="开启异步"><a href="#开启异步" class="headerlink" title="开启异步"></a>开启异步</h2><p>新建一个Spring Boot项目，版本为2.1.0.RELEASE，并引入<code>spring-boot-starter-web</code>依赖，项目结构如下所示：</p><p><img src="img/QQ截图20190302100710.png" alt="QQ截图20190302100710.png"></p><p>要开启异步支持，首先得在Spring Boot入口类上加上<code>@EnableAsync</code>注解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableAsync</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoApplication</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(DemoApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>接下来开始编写异步方法。</p><p>在<code>com.example.demo</code>路径下新建<code>service</code>包，并创建<code>TestService</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Logger logger = LoggerFactory.getLogger(<span class="keyword">this</span>.getClass());</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Async</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">asyncMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        sleep();</span><br><span class="line">        logger.info(<span class="string">"异步方法内部线程名称：&#123;&#125;"</span>, Thread.currentThread().getName());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">syncMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        sleep();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sleep</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>上面的Service中包含一个异步方法<code>asyncMethod</code>（开启异步支持后，只需要在方法上加上<code>@Async</code>注解便是异步方法了）和同步方法<code>syncMethod</code>。<code>sleep</code>方法用于让当前线程阻塞2秒钟。</p><p>接着在<code>com.example.demo</code>路径下新建<code>controller</code>包，然后创建<code>TestController</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Logger logger = LoggerFactory.getLogger(<span class="keyword">this</span>.getClass());</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> TestService testService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"async"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testAsync</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">        logger.info(<span class="string">"异步方法开始"</span>);</span><br><span class="line"></span><br><span class="line">        testService.asyncMethod();</span><br><span class="line"></span><br><span class="line">        logger.info(<span class="string">"异步方法结束"</span>);</span><br><span class="line">        <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">        logger.info(<span class="string">"总耗时：&#123;&#125; ms"</span>, end - start);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"sync"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSync</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">        logger.info(<span class="string">"同步方法开始"</span>);</span><br><span class="line"></span><br><span class="line">        testService.syncMethod();</span><br><span class="line"></span><br><span class="line">        logger.info(<span class="string">"同步方法结束"</span>);</span><br><span class="line">        <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">        logger.info(<span class="string">"总耗时：&#123;&#125; ms"</span>, end - start);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>启动项目，访问 <a href="http://localhost:8080/sync" target="_blank" rel="noopener">http://localhost:8080/sync</a> 请求，控制台输出如下：</p><p><img src="img/QQ截图20190302101932.png" alt="QQ截图20190302101932.png"></p><p>可看到默认程序是同步的，由于<code>sleep</code>方法阻塞的原因，<code>testSync</code>方法执行了2秒钟以上。</p><p>访问 <a href="http://localhost:8080/async" target="_blank" rel="noopener">http://localhost:8080/async</a> ，控制台输出如下：</p><p><img src="img/QQ截图20190302102327.png" alt="QQ截图20190302102327.png"></p><p>可看到<code>testAsync</code>方法耗时极少，因为异步的原因，程序并没有被<code>sleep</code>方法阻塞，这就是异步调用的好处。同时异步方法内部会新启一个线程来执行，这里线程名称为task - 1。</p><p>默认情况下的异步线程池配置使得线程不能被重用，每次调用异步方法都会新建一个线程，我们可以自己定义异步线程池来优化。</p><h2 id="自定义异步线程池"><a href="#自定义异步线程池" class="headerlink" title="自定义异步线程池"></a>自定义异步线程池</h2><p>在<code>com.example.demo</code>下新建<code>config</code>包，然后创建<code>AsyncPoolConfig</code>配置类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AsyncPoolConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ThreadPoolTaskExecutor <span class="title">asyncThreadPoolTaskExecutor</span><span class="params">()</span></span>&#123;</span><br><span class="line">        ThreadPoolTaskExecutor executor = <span class="keyword">new</span> ThreadPoolTaskExecutor();</span><br><span class="line">        executor.setCorePoolSize(<span class="number">20</span>);</span><br><span class="line">        executor.setMaxPoolSize(<span class="number">200</span>);</span><br><span class="line">        executor.setQueueCapacity(<span class="number">25</span>);</span><br><span class="line">        executor.setKeepAliveSeconds(<span class="number">200</span>);</span><br><span class="line">        executor.setThreadNamePrefix(<span class="string">"asyncThread"</span>);</span><br><span class="line">        executor.setWaitForTasksToCompleteOnShutdown(<span class="keyword">true</span>);</span><br><span class="line">        executor.setAwaitTerminationSeconds(<span class="number">60</span>);</span><br><span class="line"></span><br><span class="line">        executor.setRejectedExecutionHandler(<span class="keyword">new</span> ThreadPoolExecutor.CallerRunsPolicy());</span><br><span class="line"></span><br><span class="line">        executor.initialize();</span><br><span class="line">        <span class="keyword">return</span> executor;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面我们通过<code>ThreadPoolTaskExecutor</code>的一些方法自定义了一个线程池，这些方法的含义如下所示：</p><ul><li><p><code>corePoolSize</code>：线程池核心线程的数量，默认值为1（这就是默认情况下的异步线程池配置使得线程不能被重用的原因）。</p></li><li><p><code>maxPoolSize</code>：线程池维护的线程的最大数量，只有当核心线程都被用完并且缓冲队列满后，才会开始申超过请核心线程数的线程，默认值为<code>Integer.MAX_VALUE</code>。</p></li><li><p><code>queueCapacity</code>：缓冲队列。</p></li><li><p><code>keepAliveSeconds</code>：超出核心线程数外的线程在空闲时候的最大存活时间，默认为60秒。</p></li><li><p><code>threadNamePrefix</code>：线程名前缀。</p></li><li><p><code>waitForTasksToCompleteOnShutdown</code>：是否等待所有线程执行完毕才关闭线程池，默认值为false。</p></li><li><p><code>awaitTerminationSeconds</code>：<code>waitForTasksToCompleteOnShutdown</code>的等待的时长，默认值为0，即不等待。</p></li><li><p><code>rejectedExecutionHandler</code>：当没有线程可以被使用时的处理策略（拒绝任务），默认策略为<code>abortPolicy</code>，包含下面四种策略：</p><p><img src="img/QQ截图20190302111014.png" alt="QQ截图20190302111014.png"></p><ol><li><p><code>callerRunsPolicy</code>：用于被拒绝任务的处理程序，它直接在 execute 方法的调用线程中运行被拒绝的任务；如果执行程序已关闭，则会丢弃该任务。</p></li><li><p><code>abortPolicy</code>：直接抛出<code>java.util.concurrent.RejectedExecutionException</code>异常。</p></li><li><p><code>discardOldestPolicy</code>：当线程池中的数量等于最大线程数时、抛弃线程池中最后一个要执行的任务，并执行新传入的任务。</p></li><li><p><code>discardPolicy</code>：当线程池中的数量等于最大线程数时，不做任何动作。</p></li></ol></li></ul><p>要使用该线程池，只需要在<code>@Async</code>注解上指定线程池Bean名称即可：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestService</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Async</span>(<span class="string">"asyncThreadPoolTaskExecutor"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">asyncMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       ......</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重启项目，再次访问 <a href="http://localhost:8080/async" target="_blank" rel="noopener">http://localhost:8080/async</a> ，控制台输出入下：</p><p><img src="img/QQ截图20190302112759.png" alt="QQ截图20190302112759.png"></p><h2 id="处理异步回调"><a href="#处理异步回调" class="headerlink" title="处理异步回调"></a>处理异步回调</h2><p>如果异步方法具有返回值的话，需要使用<code>Future</code>来接收回调值。我们修改<code>TestService</code>的<code>asyncMethod</code>方法，给其添加返回值：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Async</span>(<span class="string">"asyncThreadPoolTaskExecutor"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> Future&lt;String&gt; <span class="title">asyncMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sleep();</span><br><span class="line">    logger.info(<span class="string">"异步方法内部线程名称：&#123;&#125;"</span>, Thread.currentThread().getName());</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> AsyncResult&lt;&gt;(<span class="string">"hello async"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>泛型指定返回值的类型，<code>AsyncResult</code>为Spring实现的<code>Future</code>实现类：</p><p><img src="img/QQ截图20190302140425.png" alt="QQ截图20190302140425.png"></p><p>接着改造<code>TestController</code>的<code>testAsync</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"async"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">testAsync</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">    logger.info(<span class="string">"异步方法开始"</span>);</span><br><span class="line"></span><br><span class="line">    Future&lt;String&gt; stringFuture = testService.asyncMethod();</span><br><span class="line">    String result = stringFuture.get();</span><br><span class="line">    logger.info(<span class="string">"异步方法返回值：&#123;&#125;"</span>, result);</span><br><span class="line">    </span><br><span class="line">    logger.info(<span class="string">"异步方法结束"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">    logger.info(<span class="string">"总耗时：&#123;&#125; ms"</span>, end - start);</span><br><span class="line">    <span class="keyword">return</span> stringFuture.get();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p><code>Future</code>接口的<code>get</code>方法用于获取异步调用的返回值。</p><p>重启项目，访问 <a href="http://localhost:8080/async" target="_blank" rel="noopener">http://localhost:8080/async</a> 控制台输出如下所示:</p><p><img src="img/QQ截图20190302141055.png" alt="QQ截图20190302141055.png"></p><p>通过返回结果我们可以看出<code>Future</code>的<code>get</code>方法为阻塞方法，只有当异步方法返回内容了，程序才会继续往下执行。<code>get</code>还有一个<code>get(long timeout, TimeUnit unit)</code>重载方法，我们可以通过这个重载方法设置超时时间，即异步方法在设定时间内没有返回值的话，直接抛出<code>java.util.concurrent.TimeoutException</code>异常。</p><p>比如设置超时时间为60秒：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String result = stringFuture.get(<span class="number">60</span>, TimeUnit.SECONDS);</span><br></pre></td></tr></table></figure><blockquote><p>源码链接：<a href="https://github.com/wuyouzhuguli/SpringAll/tree/master/49.Spring-Boot-Async" target="_blank" rel="noopener">https://github.com/wuyouzhuguli/SpringAll/tree/master/49.Spring-Boot-Async</a></p></blockquote><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Thu Mar 21 2019 09:22:42 GMT+0800 (GMT+08:00) --&gt;&lt;p&gt;通常我们开发的程序都是同步调用的，即程序按照代码的顺序一行一行的逐步往下执行，每一行代码都必须等待上一行代码执行完毕才能开始执行。而异步编程则没有这个限制，代码的调用不再是阻塞的。所以在一些情景下，通过异步编程可以提高效率，提升接口的吞吐量。这节将介绍如何在Spring Boot中进行异步编程。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Spring" scheme="http://mrbird.cc/tags/Spring/"/>
    
      <category term="Spring Boot" scheme="http://mrbird.cc/tags/Spring-Boot/"/>
    
  </entry>
  
  <entry>
    <title>Spring Boot 中处理跨域</title>
    <link href="http://mrbird.cc/Spring-Boot-Deal-CORS.html"/>
    <id>http://mrbird.cc/Spring-Boot-Deal-CORS.html</id>
    <published>2018-09-22T02:08:47.000Z</published>
    <updated>2019-03-13T10:48:29.195Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Mar 21 2019 09:22:41 GMT+0800 (GMT+08:00) --><p>HTML 5中新增的跨域资源访问（Cross-Origin Resource Sharing）特性可以让我们在开发后端系统的时候决定资源是否允许被跨域访问。所谓跨域指的是域名不同或者端口不同或者协议不同，比如当从mrbrid.cc网站访问mrbird.cc:8080网站资源就会存在跨域问题。Spring从4.2版本开始就提供了跨域的支持，开箱即用。这里介绍如何在Spring Boot开发中解决跨域的问题，主要分为注解驱动和接口编程的方式。</p><a id="more"></a><h2 id="模拟跨域"><a href="#模拟跨域" class="headerlink" title="模拟跨域"></a>模拟跨域</h2><p>要解决跨域问题，我们就得先模拟一个跨域情景。新建Spring Boot项目，版本为2.1.0.RELEASE，并引如下依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-thymeleaf<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p></p><p>项目结构如下所示：</p><p><img src="img/QQ截图20190301150006.png" alt="QQ截图20190301150006.png"></p><p>在<code>com.example.demo</code>路径下新建<code>controller</code>包，并创建<code>TestController</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"index"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">index</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"index"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"hello"</span>)</span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"hello"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>然后在resources/templates下新建index.html：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>跨域测试<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"http://libs.baidu.com/jquery/1.11.3/jquery.min.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"hello"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">    $(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        $.get(<span class="string">"http://test.mrbird.cc:8080/hello"</span>, <span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">            $(<span class="string">"#hello"</span>).text(data);</span></span><br><span class="line"><span class="undefined">        &#125;)</span></span><br><span class="line"><span class="undefined">    &#125;)</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p></p><p>编辑本地hosts文件，将<a href="http://test.mrbird.cc" target="_blank" rel="noopener">http://test.mrbird.cc</a>网址映射到127.0.0.1上：</p><p><img src="img/QQ截图20190301150336.png" alt="QQ截图20190301150336.png"></p><p>启动项目访问<a href="http://localhost:8080/" target="_blank" rel="noopener">http://localhost:8080/</a>，会发现页面并没有成功显示hello，并且F12观察浏览器控制台会发现其报错了：</p><p><img src="img/QQ截图20190301150534.png" alt="QQ截图20190301150534.png"></p><p>这是因为我们在<a href="http://localhost:8080/" target="_blank" rel="noopener">http://localhost:8080/</a>域名下试图访问<a href="http://test.mrbird.cc:8080" target="_blank" rel="noopener">http://test.mrbird.cc:8080</a>下的hello接口，这就存在跨域问题，接下来我们来解决这个问题。</p><h2 id="注解驱动"><a href="#注解驱动" class="headerlink" title="注解驱动"></a>注解驱动</h2><p>Spring 4.2后提供了<code>@CrossOrigin</code>注解，该注解可以标注于方法或者类上，包含了以下属性:</p><table><tr><th>属性</th><th>含义</th></tr><tr><td>value</td><td>指定所支持域的集合，<code>*</code>表示所有域都支持，默认值为<code>*</code>。这些值对应HTTP请求头中的<code>Access-Control-Allow-Origin</code></td></tr><tr><td>origins</td><td>同value</td></tr><tr><td>allowedHeaders</td><td>允许请求头中的header，默认都支持</td></tr><tr><td>exposedHeaders</td><td>响应头中允许访问的header，默认为空</td></tr><tr><td>methods</td><td>支持请求的方法，比如<code>GET</code>，<code>POST</code>，<code>PUT</code>等，默认和Controller中的方法上标注的一致。</td></tr><tr><td>allowCredentials</td><td>是否允许cookie随请求发送，使用时必须指定具体的域</td></tr><tr><td>maxAge</td><td>预请求的结果的有效期，默认30分钟</td></tr></table><p>我们来改造<code>TestController</code>中的<code>hello</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"hello"</span>)</span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="meta">@CrossOrigin</span>(value = <span class="string">"*"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"hello"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>表示允许所有域都支持，重启项目，再次访问<a href="http://localhost:8080/" target="_blank" rel="noopener">http://localhost:8080/</a>：</p><p><img src="img/QQ截图20190301153418.png" alt="QQ截图20190301153418.png"></p><h2 id="接口编程"><a href="#接口编程" class="headerlink" title="接口编程"></a>接口编程</h2><p>除了使用<code>@CrossOrigin</code>注解外，我们可以使用接口编程的方式进行统一配置。</p><p>在<code>com.example.demo</code>路径下新建<code>config</code>包，然后创建<code>WebConfigurer</code>，实现<code>WebMvcConfigurer</code>，重写<code>addCorsMappings</code>默认实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebConfigurer</span> <span class="keyword">implements</span> <span class="title">WebMvcConfigurer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addCorsMappings</span><span class="params">(CorsRegistry registry)</span> </span>&#123;</span><br><span class="line">        registry.addMapping(<span class="string">"/**"</span>)</span><br><span class="line">                .allowedOrigins(<span class="string">"*"</span>)</span><br><span class="line">                .allowedMethods(<span class="string">"GET"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>上面配置表示允许所有请求支持跨域访问，并且不限定域，但是支持持GET方法。将<code>hello</code>方法上的<code>@CrossOrigin</code>注解注释掉，重启项目，再次访问<a href="http://localhost:8080/" target="_blank" rel="noopener">http://localhost:8080/</a>，结果也是OK的。</p><h2 id="过滤器实现"><a href="#过滤器实现" class="headerlink" title="过滤器实现"></a>过滤器实现</h2><p>查看官方文档，发现其还提供了基于过滤器的实现方式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> FilterRegistrationBean <span class="title">corsFilter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    UrlBasedCorsConfigurationSource source = <span class="keyword">new</span> UrlBasedCorsConfigurationSource();</span><br><span class="line">    CorsConfiguration config = <span class="keyword">new</span> CorsConfiguration();</span><br><span class="line">    config.setAllowCredentials(<span class="keyword">true</span>);</span><br><span class="line">    config.addAllowedOrigin(<span class="string">"*"</span>);</span><br><span class="line">    source.registerCorsConfiguration(<span class="string">"/**"</span>, config);</span><br><span class="line">    FilterRegistrationBean bean = <span class="keyword">new</span> FilterRegistrationBean(<span class="keyword">new</span> CorsFilter(source));</span><br><span class="line">    bean.setOrder(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> bean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h2 id="Actuator跨域"><a href="#Actuator跨域" class="headerlink" title="Actuator跨域"></a>Actuator跨域</h2><p>如果项目里集成了<code>Actuator</code>相关功能，其暴露的接口也支持跨域，只需要在配置文件中添加如下配置即可：</p><p>ENDPOINTS CORS CONFIGURATION (<a href="https://github.com/spring-projects/spring-boot/blob/v2.1.0.RELEASE/spring-boot-project/spring-boot-actuator-autoconfigure/src/main/java/org/springframework/boot/actuate/autoconfigure/endpoint/web/CorsEndpointProperties.java" target="_blank" rel="noopener">CorsEndpointProperties</a>)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">management.endpoints.web.cors.allow-credentials= # Whether credentials are supported. When not set, credentials are not supported.</span><br><span class="line">management.endpoints.web.cors.allowed-headers= # Comma-separated list of headers to allow in a request. &apos;*&apos; allows all headers.</span><br><span class="line">management.endpoints.web.cors.allowed-methods= # Comma-separated list of methods to allow. &apos;*&apos; allows all methods. When not set, defaults to GET.</span><br><span class="line">management.endpoints.web.cors.allowed-origins= # Comma-separated list of origins to allow. &apos;*&apos; allows all origins. When not set, CORS support is disabled.</span><br><span class="line">management.endpoints.web.cors.exposed-headers= # Comma-separated list of headers to include in a response.</span><br><span class="line">management.endpoints.web.cors.max-age=1800s # How long the response from a pre-flight request can be cached by clients. If a duration suffix is not specified, seconds will be used.</span><br></pre></td></tr></table></figure><p></p><blockquote><p>源码链接：<a href="https://github.com/wuyouzhuguli/SpringAll/tree/master/48.Spring-Boot-CORS-Support" target="_blank" rel="noopener">https://github.com/wuyouzhuguli/SpringAll/tree/master/48.Spring-Boot-CORS-Support</a></p></blockquote><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Thu Mar 21 2019 09:22:41 GMT+0800 (GMT+08:00) --&gt;&lt;p&gt;HTML 5中新增的跨域资源访问（Cross-Origin Resource Sharing）特性可以让我们在开发后端系统的时候决定资源是否允许被跨域访问。所谓跨域指的是域名不同或者端口不同或者协议不同，比如当从mrbrid.cc网站访问mrbird.cc:8080网站资源就会存在跨域问题。Spring从4.2版本开始就提供了跨域的支持，开箱即用。这里介绍如何在Spring Boot开发中解决跨域的问题，主要分为注解驱动和接口编程的方式。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Spring" scheme="http://mrbird.cc/tags/Spring/"/>
    
      <category term="Spring Boot" scheme="http://mrbird.cc/tags/Spring-Boot/"/>
    
  </entry>
  
  <entry>
    <title>自定义Spring Boot 内容协商</title>
    <link href="http://mrbird.cc/Spring-Boot-Diy-Resolver.html"/>
    <id>http://mrbird.cc/Spring-Boot-Diy-Resolver.html</id>
    <published>2018-09-16T02:08:27.000Z</published>
    <updated>2019-03-13T10:49:45.558Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Mar 21 2019 09:22:44 GMT+0800 (GMT+08:00) --><p><strong>内容协商</strong>机制是指客户端和服务器端就响应的资源内容进行交涉，然后提供给客户端最为适合的资源。内容协商会以响应资源的语言、字符集、编码方式等作为判断的基准。HTTP请求头中Content-Type，Accept等内容就是内容协商判断的标准。在Spring Boot中，一个完整的内容协商过程如下图所示：</p><a id="more"></a><p><img src="img/askfljasdfneiw.png" alt="askfljasdfneiw.png"></p><p>这个过程的核心组件：</p><table><tr><th>组件</th><th>名称</th><th>说明</th></tr><tr><td>ContentNegotiationManager</td><td>内容协商管理器</td><td>ContentNegotiationStrategy 控制策略</td></tr><tr><td>MediaType</td><td>媒体类型</td><td>HTTP 消息媒体类型，如 text/html</td></tr><tr><td>@RequestMapping#consumes</td><td>消费媒体类型</td><td>请求头 Content-Type 媒体类型映射</td></tr><tr><td>@RequestMapping#produces</td><td>生产媒体类型</td><td>响应头 Content-Type 媒体类型映射</td></tr><tr><td>HttpMessageConverter</td><td>HTTP消息转换器接口</td><td>HTTP 消息转换器，用于反序列化 HTTP 请求或序列化响应</td></tr><tr><td>WebMvcConfigurer</td><td>Web MVC 配置器</td><td>配置 REST 相关的组件</td></tr><tr><td>HandlerMethod</td><td>处理方法</td><td>@RequestMapping 标注的方法</td></tr><tr><td>HandlerMethodArgumentResolver</td><td>处理方法参数解析器</td><td>用于 HTTP 请求中解析 HandlerMethod 参数内容</td></tr><tr><td>HandlerMethodReturnValueHandler</td><td>处理方法返回值解析器</td><td>用于 HandlerMethod 返回值解析为 HTTP 响应内容</td></tr></table><p><code>HttpMessageConverter</code>为HTTP消息转换接口，Spring根据不同的媒体类型进行了相应的实现。比如上图中Accept为application/json，所以在第7步中，会选择使用<code>HttpMessageConverter</code>的实现类<code>MappingJackson2HttpMessageConverter</code>来处理返回值。</p><h2 id="自定义HttpMessageConverter"><a href="#自定义HttpMessageConverter" class="headerlink" title="自定义HttpMessageConverter"></a>自定义HttpMessageConverter</h2><p>除了Spring给我们提供的<code>HttpMessageConverter</code>实现外，我们也可以自定义<code>HttpMessageConverter</code>的实现，来处理一些实际业务需求。</p><p>假如现在要实现一个用于处理 Content-Type 为 text/properties 媒体类型的 HttpMessageConverter 实现类 PropertiesHttpMessageConverter，当我们在请求体中传输下面内容时：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">name:mrbrid</span><br><span class="line">age:18</span><br></pre></td></tr></table></figure><p></p><p>能够自动转换为Properties对象。</p><p>我们可以参照<code>MappingJackson2HttpMessageConverter</code>的实现方式来进行实现，查看<code>MappingJackson2HttpMessageConverter</code>的原型图：</p><p><img src="img/QQ截图20190228110016.png" alt="QQ截图20190228110016.png"></p><p>所以我们可以通过继承<code>AbstractGenericHttpMessageConverter</code>的方式来实现<code>HttpMessageConverter</code>接口。</p><p>新建Spring Boot项目，版本为2.1.0.RELEASE，并引入<code>spring-boot-starter-web</code>依赖，项目结构如下所示:</p><p><img src="img/QQ截图20190228110545.png" alt="QQ截图20190228110545.png"></p><p>我们在<code>com.example.demo</code>路径下新建<code>converter</code>包，然后创建<code>PropertiesHttpMessageConverter</code>，继承<code>AbstractGenericHttpMessageConverter</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PropertiesHttpMessageConverter</span> <span class="keyword">extends</span> <span class="title">AbstractGenericHttpMessageConverter</span>&lt;<span class="title">Properties</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">writeInternal</span><span class="params">(Properties properties, Type type, HttpOutputMessage outputMessage)</span> <span class="keyword">throws</span> IOException, HttpMessageNotWritableException </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Properties <span class="title">readInternal</span><span class="params">(Class&lt;? extends Properties&gt; clazz, HttpInputMessage inputMessage)</span> <span class="keyword">throws</span> IOException, HttpMessageNotReadableException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Properties <span class="title">read</span><span class="params">(Type type, Class&lt;?&gt; contextClass, HttpInputMessage inputMessage)</span> <span class="keyword">throws</span> IOException, HttpMessageNotReadableException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>其中<code>readxxx</code>为反序列化过程，即将HTTP请求反序列化为参数的过程；<code>writeInternal</code>为序列化过程，将响应序列化。</p><h3 id="反序列化过程"><a href="#反序列化过程" class="headerlink" title="反序列化过程"></a>反序列化过程</h3><p>我们继续编写<code>PropertiesHttpMessageConverter</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PropertiesHttpMessageConverter</span> <span class="keyword">extends</span> <span class="title">AbstractGenericHttpMessageConverter</span>&lt;<span class="title">Properties</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">writeInternal</span><span class="params">(Properties properties, Type type, HttpOutputMessage outputMessage)</span> <span class="keyword">throws</span> IOException, HttpMessageNotWritableException </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Properties <span class="title">readInternal</span><span class="params">(Class&lt;? extends Properties&gt; clazz, HttpInputMessage inputMessage)</span> <span class="keyword">throws</span> IOException, HttpMessageNotReadableException </span>&#123;</span><br><span class="line">        Properties properties = <span class="keyword">new</span> Properties();</span><br><span class="line">        <span class="comment">// 获取请求头</span></span><br><span class="line">        HttpHeaders headers = inputMessage.getHeaders();</span><br><span class="line">        <span class="comment">// 获取 content-type</span></span><br><span class="line">        MediaType contentType = headers.getContentType();</span><br><span class="line">        <span class="comment">// 获取编码</span></span><br><span class="line">        Charset charset = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (contentType != <span class="keyword">null</span>) &#123;</span><br><span class="line">            charset = contentType.getCharset();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        charset = charset == <span class="keyword">null</span> ? Charset.forName(<span class="string">"UTF-8"</span>) : charset;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取请求体</span></span><br><span class="line">        InputStream body = inputMessage.getBody();</span><br><span class="line">        InputStreamReader inputStreamReader = <span class="keyword">new</span> InputStreamReader(body, charset);</span><br><span class="line">        </span><br><span class="line">        properties.load(inputStreamReader);</span><br><span class="line">        <span class="keyword">return</span> properties;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Properties <span class="title">read</span><span class="params">(Type type, Class&lt;?&gt; contextClass, HttpInputMessage inputMessage)</span> <span class="keyword">throws</span> IOException, HttpMessageNotReadableException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> readInternal(<span class="keyword">null</span>, inputMessage);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>在<code>readInternal</code>方法中，我们获取了HTTP请求体中的输入流和编码，然后调用Properties对象的<code>load</code>方法来将流转换为Properties对象。反序列化过程完成了，我们还需将<code>PropertiesHttpMessageConverter</code>添加到<code>HttpMessageConverter</code>集合中。</p><p>在<code>com.example.demo</code>路径下新建<code>config</code>包，然后创建<code>WebConfigurer</code>配置类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebConfigurer</span> <span class="keyword">implements</span> <span class="title">WebMvcConfigurer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">extendMessageConverters</span><span class="params">(List&lt;HttpMessageConverter&lt;?&gt;&gt; converters)</span> </span>&#123;</span><br><span class="line">        converters.add(<span class="keyword">new</span> PropertiesHttpMessageConverter());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p><code>extendMessageConverters</code>方法为<code>WebMvcConfigurer</code>的默认方法，这里我们重写这个方法，用于将<code>PropertiesHttpMessageConverter</code>添加到消息转换器集合中。</p><p>接着创建一个Controller来测试一波，在<code>com.example.demo</code>路径下新建<code>controller</code>包，然后创建<code>TestController</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(value = <span class="string">"test"</span>, consumes = <span class="string">"text/properties"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Properties <span class="title">test</span><span class="params">(@RequestBody Properties properties)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> properties;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>我们通过<code>@GetMapping</code>注解的<code>consumes</code>属性指定了方法接收的媒体类型为<code>text/properties</code>，如果方法能够成功被调用，并且可以返回<code>Properties</code>对象，则说明我们自定义的HTTP消息转换器是可行的。</p><p>启动项目，使用PostMan访问：</p><p><img src="img/QQ截图20190228142903.png" alt="QQ截图20190228142903.png"></p><p>请求头中指定Content-Type为text/properties，请求体内容如下所示:</p><p><img src="img/QQ截图20190228142955.png" alt="QQ截图20190228142955.png"></p><p>访问后，控制台输出错误如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Resolved [org.springframework.http.converter.HttpMessageNotReadableException: Required request body is missing: public java.util.Properties com.example.demo.controller.TestController.test(java.util.Properties)]</span><br></pre></td></tr></table></figure><p></p><p>为什么呢？因为我们在自定义<code>PropertiesHttpMessageConverter</code>的时候需要在其构造器中指定它能够处理的媒体类型，我们查看<code>MappingJackson2HttpMessageConverter</code>的构造器，看看它是怎么实现的：</p><p><img src="img/QQ截图20190228143338.png" alt="QQ截图20190228143338.png"></p><p>所以我们在<code>PropertiesHttpMessageConverter</code>的构造器中添加相应的媒体类型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">PropertiesHttpMessageConverter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(<span class="keyword">new</span> MediaType(<span class="string">"text"</span>, <span class="string">"properties"</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>这时候，重启项目，再次访问上面的请求，可看到响应如下所示:</p><p><img src="img/QQ截图20190228143600.png" alt="QQ截图20190228143600.png"></p><h3 id="序列化过程"><a href="#序列化过程" class="headerlink" title="序列化过程"></a>序列化过程</h3><p>序列化的过程就是处理HTTP响应的过程，对应<code>PropertiesHttpMessageConverter</code>的<code>writeInternal</code>方法。那为什么我们都还实现这个方法，上面的Controller请求却能返回正常的JSON内容呢？两个原因：</p><ol><li><p>这里我们定义的是REST接口，所以响应默认会被序列化为JSON格式；</p></li><li><p>由于使用<code>converters.add(new PropertiesHttpMessageConverter());</code>这种方式来添加自定义HTTP消息处理器默认会被添加到集合的末尾，在处理JSON响应的时候被排在前面的<code>MappingJackson2HttpMessageConverter</code>优先处理了。</p></li></ol><p>我们可以通过debug来查看<code>PropertiesHttpMessageConverter</code>是否真的被添加到集合末尾了：</p><p><img src="img/QQ截图20190228144601.png" alt="QQ截图20190228144601.png"></p><p><img src="img/QQ截图20190228144626.png" alt="QQ截图20190228144626.png"></p><p>所以我们要换下面这种方式来添加自定义HTTP处理器：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebConfigurer</span> <span class="keyword">implements</span> <span class="title">WebMvcConfigurer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">extendMessageConverters</span><span class="params">(List&lt;HttpMessageConverter&lt;?&gt;&gt; converters)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// converters.add(new PropertiesHttpMessageConverter());</span></span><br><span class="line">        <span class="comment">// 指定顺序，这里为第一个</span></span><br><span class="line">        converters.add(<span class="number">0</span>, <span class="keyword">new</span> PropertiesHttpMessageConverter());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>我们重启项目，再次debug：</p><p><img src="img/QQ截图20190228145054.png" alt="QQ截图20190228145054.png"></p><p>可看到，<code>PropertiesHttpMessageConverter</code>已经排在第一个了。这时候再次访问上面的请求，响应如下所示:</p><p><img src="img/QQ截图20190228145215.png" alt="QQ截图20190228145215.png"></p><p>没有任何返回值，这是因为我们还没实现<code>writeInternal</code>呢。继续实现<code>writeInternal</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PropertiesHttpMessageConverter</span> <span class="keyword">extends</span> <span class="title">AbstractGenericHttpMessageConverter</span>&lt;<span class="title">Properties</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">writeInternal</span><span class="params">(Properties properties, Type type, HttpOutputMessage outputMessage)</span> <span class="keyword">throws</span> IOException, HttpMessageNotWritableException </span>&#123;</span><br><span class="line">        <span class="comment">// 获取请求头</span></span><br><span class="line">        HttpHeaders headers = outputMessage.getHeaders();</span><br><span class="line">        <span class="comment">// 获取 content-type</span></span><br><span class="line">        MediaType contentType = headers.getContentType();</span><br><span class="line">        <span class="comment">// 获取编码</span></span><br><span class="line">        Charset charset = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (contentType != <span class="keyword">null</span>) &#123;</span><br><span class="line">            charset = contentType.getCharset();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        charset = charset == <span class="keyword">null</span> ? Charset.forName(<span class="string">"UTF-8"</span>) : charset;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取请求体</span></span><br><span class="line">        OutputStream body = outputMessage.getBody();</span><br><span class="line">        OutputStreamWriter outputStreamWriter = <span class="keyword">new</span> OutputStreamWriter(body, charset);</span><br><span class="line"></span><br><span class="line">        properties.store(outputStreamWriter, <span class="string">"Serialized by PropertiesHttpMessageConverter#writeInternal"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>过程和反序化差不多，这里是通过<code>Properties</code>对象的<code>store</code>方法来进行写操作。</p><p>重启项目，再次访问上面的请求，响应如下所示：</p><p><img src="img/QQ截图20190228145908.png" alt="QQ截图20190228145908.png"></p><h2 id="自定义HandlerMethodArgumentResolver"><a href="#自定义HandlerMethodArgumentResolver" class="headerlink" title="自定义HandlerMethodArgumentResolver"></a>自定义HandlerMethodArgumentResolver</h2><p>上面这种方式必须依赖于<code>@RequestBody</code>和<code>@ResponseBody</code>注解，除此之外我们还可以通过自定义<code>HandlerMethodArgumentResolver</code>和<code>HandlerMethodReturnValueHandler</code>实现类的方式来处理内容协商。</p><p><code>HandlerMethodArgumentResolver</code>俗称方法参数解析器，用于解析由<code>@RequestMapping</code>注解（或其派生的注解）所标注的方法的参数。这里我们开始通过实现<code>HandlerMethodArgumentResolver</code>的方式来将HTTP请求体的内容自动解析为Properties对象。</p><p>在<code>com.example.demo</code>路径下新建<code>resolver</code>包，然后创建<code>PropertiesHandlerMethodReturnValueHandler</code>实现<code>HandlerMethodArgumentResolver</code>接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PropertiesHandlerMethodArgumentResolver</span> <span class="keyword">implements</span> <span class="title">HandlerMethodArgumentResolver</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">supportsParameter</span><span class="params">(MethodParameter parameter)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Properties.class.equals(parameter.getParameterType());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">resolveArgument</span><span class="params">(MethodParameter parameter, ModelAndViewContainer mavContainer, NativeWebRequest webRequest, WebDataBinderFactory binderFactory)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ServletWebRequest servletWebRequest = (ServletWebRequest) webRequest;</span><br><span class="line">        HttpServletRequest request = servletWebRequest.getRequest();</span><br><span class="line">        String contentType = request.getHeader(<span class="string">"Content-Type"</span>);</span><br><span class="line"></span><br><span class="line">        MediaType mediaType = MediaType.parseMediaType(contentType);</span><br><span class="line">        <span class="comment">// 获取编码</span></span><br><span class="line">        Charset charset = mediaType.getCharset() == <span class="keyword">null</span> ? Charset.forName(<span class="string">"UTF-8"</span>) : mediaType.getCharset();</span><br><span class="line">        <span class="comment">// 获取输入流</span></span><br><span class="line">        InputStream inputStream = request.getInputStream();</span><br><span class="line">        InputStreamReader inputStreamReader = <span class="keyword">new</span> InputStreamReader(inputStream, charset);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 输入流转换为 Properties</span></span><br><span class="line">        Properties properties = <span class="keyword">new</span> Properties();</span><br><span class="line">        properties.load(inputStreamReader);</span><br><span class="line">        <span class="keyword">return</span> properties;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>方法<code>supportsParameter</code>用于指定支持解析的参数类型，这里为Properties类型。<code>resolveArgument</code>方法用于实现解析逻辑，解析过程和上面定义的<code>PropertiesHttpMessageConverter</code>的<code>readInternal</code>方法类似。</p><p>接着，我们还需将<code>PropertiesHandlerMethodArgumentResolver</code>添加到Spring自带的<code>HandlerMethodArgumentResolver</code>实现类集合中。值得注意的是，我们不能在配置类<code>WebMvcConfigurer</code>中通过重写<code>addArgumentResolvers</code>的方式来添加，查看该方法源码上的注释：</p><p><img src="img/QQ截图20190228185749.png" alt="QQ截图20190228185749.png"></p><p>大致意思是通过这个方法来添加的方法参数解析器不会覆盖Spring内置的方法参数解析器，如果需要这么做的话，可以直接通过修改<code>RequestMappingHandlerAdapter</code>来实现。</p><p>所以我们可以通过下面这个方式来实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebConfigurer</span> <span class="keyword">implements</span> <span class="title">WebMvcConfigurer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RequestMappingHandlerAdapter requestMappingHandlerAdapter;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 获取当前 RequestMappingHandlerAdapter 所有的 ArgumentResolver对象</span></span><br><span class="line">        List&lt;HandlerMethodArgumentResolver&gt; argumentResolvers = requestMappingHandlerAdapter.getArgumentResolvers();</span><br><span class="line">        List&lt;HandlerMethodArgumentResolver&gt; newArgumentResolvers = <span class="keyword">new</span> ArrayList&lt;&gt;(argumentResolvers.size() + <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 添加 PropertiesHandlerMethodArgumentResolver 到集合第一个位置</span></span><br><span class="line">        newArgumentResolvers.add(<span class="number">0</span>, <span class="keyword">new</span> PropertiesHandlerMethodArgumentResolver());</span><br><span class="line">        <span class="comment">// 将原 ArgumentResolver 添加到集合中</span></span><br><span class="line">        newArgumentResolvers.addAll(argumentResolvers);</span><br><span class="line">        <span class="comment">// 重新设置 ArgumentResolver对象集合</span></span><br><span class="line">        requestMappingHandlerAdapter.setArgumentResolvers(newArgumentResolvers);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>我们在<code>WebConfigurer</code>配置类装配完毕的时候，通过<code>requestMappingHandlerAdapter</code>对象的<code>setArgumentResolvers</code>方法来重新设置方法解析器集合，将<code>PropertiesHandlerMethodArgumentResolver</code>添加到集合的第一个位置。</p><p>之所以要将<code>PropertiesHandlerMethodArgumentResolver</code>添加到第一个位置是因为Properties本质也是一个Map对象，而Spring内置的<code>MapMethodProcessor</code>就是用于处理Map参数类型的，如果不将<code>PropertiesHandlerMethodArgumentResolver</code>优先级提高，那么Properties类型参数会被<code>MapMethodProcessor</code>解析，从而出错。</p><p>配置完毕后，我们改造一下<code>TestController</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// @RestController</span></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(value = <span class="string">"test"</span>, consumes = <span class="string">"text/properties"</span>)</span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Properties <span class="title">test</span><span class="params">(@RequestBody Properties properties)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> properties;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(value = <span class="string">"test1"</span>, consumes = <span class="string">"text/properties"</span>)</span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Properties <span class="title">test1</span><span class="params">(Properties properties)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> properties;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p><code>test1</code>方法的参数没有被<code>@RequestBody</code>标注，启动项目，访问下面这个请求：</p><p><img src="img/QQ截图20190228190930.png" alt="QQ截图20190228190930.png"></p><p>可以看到方法成功执行，并且返回了正确的内容，说明我们自定义的方法参数解析器<code>PropertiesHandlerMethodArgumentResolver</code>是可行的。</p><p>但是方法的返回值还是由<code>PropertiesHttpMessageConverter</code>的<code>writeInternal</code>方法解析的，并且依赖于<code>@ResponseBody</code>注解，接着我们开始实现自定义方法返回值解析器，并且不依赖于<code>@ResponseBody</code>注解。</p><h2 id="自定义HandlerMethodReturnValueHandler"><a href="#自定义HandlerMethodReturnValueHandler" class="headerlink" title="自定义HandlerMethodReturnValueHandler"></a>自定义HandlerMethodReturnValueHandler</h2><p><code>HandlerMethodArgumentResolver</code>俗称方法返回值解析器，用于解析由<code>@RequestMapping</code>注解（或其派生的注解）所标注的方法的返回值。这里我们开始通过实现<code>HandlerMethodReturnValueHandler</code>的方式来自定义一个用于处理返回值类型为Properties类型的解析器。</p><p>在<code>com.example.demo</code>路径下新建<code>handler</code>包，然后创建<code>PropertiesHandlerMethodReturnValueHandler</code>实现<code>HandlerMethodReturnValueHandler</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PropertiesHandlerMethodReturnValueHandler</span> <span class="keyword">implements</span> <span class="title">HandlerMethodReturnValueHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">supportsReturnType</span><span class="params">(MethodParameter returnType)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Properties.class.equals(returnType.getMethod().getReturnType());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleReturnValue</span><span class="params">(Object returnValue, MethodParameter returnType, ModelAndViewContainer mavContainer, NativeWebRequest webRequest)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Properties properties = (Properties) returnValue;</span><br><span class="line"></span><br><span class="line">        ServletWebRequest servletWebRequest = (ServletWebRequest) webRequest;</span><br><span class="line"></span><br><span class="line">        HttpServletResponse response = servletWebRequest.getResponse();</span><br><span class="line">        ServletServerHttpResponse servletServerHttpResponse = <span class="keyword">new</span> ServletServerHttpResponse(response);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取请求头</span></span><br><span class="line">        HttpHeaders headers = servletServerHttpResponse.getHeaders();</span><br><span class="line"></span><br><span class="line">        MediaType contentType = headers.getContentType();</span><br><span class="line">        <span class="comment">// 获取编码</span></span><br><span class="line">        Charset charset = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (contentType != <span class="keyword">null</span>) &#123;</span><br><span class="line">            charset = contentType.getCharset();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        charset = charset == <span class="keyword">null</span> ? Charset.forName(<span class="string">"UTF-8"</span>) : charset;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取请求体</span></span><br><span class="line">        OutputStream body = servletServerHttpResponse.getBody();</span><br><span class="line">        OutputStreamWriter outputStreamWriter = <span class="keyword">new</span> OutputStreamWriter(body, charset);</span><br><span class="line"></span><br><span class="line">        properties.store(outputStreamWriter, <span class="string">"Serialized by PropertiesHandlerMethodReturnValueHandler#handleReturnValue"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p><code>supportsReturnType</code>方法指定了处理返回值的类型，<code>handleReturnValue</code>方法用于处理返回值，这里的逻辑和<code>PropertiesHttpMessageConverter</code>的<code>writeInternal</code>方法基本一致，不再赘述。</p><p>接着将<code>PropertiesHandlerMethodReturnValueHandler</code>添加到到Spring自带的<code>HandlerMethodReturnValueHandler</code>实现类集合中，添加方式和自定义<code>HandlerMethodArgumentResolver</code>一致：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebConfigurer</span> <span class="keyword">implements</span> <span class="title">WebMvcConfigurer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RequestMappingHandlerAdapter requestMappingHandlerAdapter;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 获取当前 RequestMappingHandlerAdapter 所有的 ArgumentResolver对象</span></span><br><span class="line">        List&lt;HandlerMethodArgumentResolver&gt; argumentResolvers = requestMappingHandlerAdapter.getArgumentResolvers();</span><br><span class="line">        List&lt;HandlerMethodArgumentResolver&gt; newArgumentResolvers = <span class="keyword">new</span> ArrayList&lt;&gt;(argumentResolvers.size() + <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 添加 PropertiesHandlerMethodArgumentResolver 到集合第一个位置</span></span><br><span class="line">        newArgumentResolvers.add(<span class="number">0</span>, <span class="keyword">new</span> PropertiesHandlerMethodArgumentResolver());</span><br><span class="line">        <span class="comment">// 将原 ArgumentResolver 添加到集合中</span></span><br><span class="line">        newArgumentResolvers.addAll(argumentResolvers);</span><br><span class="line">        <span class="comment">// 重新设置 ArgumentResolver对象集合</span></span><br><span class="line">        requestMappingHandlerAdapter.setArgumentResolvers(newArgumentResolvers);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取当前 RequestMappingHandlerAdapter 所有的 returnValueHandlers对象</span></span><br><span class="line">        List&lt;HandlerMethodReturnValueHandler&gt; returnValueHandlers = requestMappingHandlerAdapter.getReturnValueHandlers();</span><br><span class="line">        List&lt;HandlerMethodReturnValueHandler&gt; newReturnValueHandlers = <span class="keyword">new</span> ArrayList&lt;&gt;(returnValueHandlers.size() + <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 添加 PropertiesHandlerMethodReturnValueHandler 到集合第一个位置</span></span><br><span class="line">        newReturnValueHandlers.add(<span class="number">0</span>, <span class="keyword">new</span> PropertiesHandlerMethodReturnValueHandler());</span><br><span class="line">        <span class="comment">// 将原 returnValueHandlers 添加到集合中</span></span><br><span class="line">        newReturnValueHandlers.addAll(returnValueHandlers);</span><br><span class="line">        <span class="comment">// 重新设置 ReturnValueHandlers对象集合</span></span><br><span class="line">        requestMappingHandlerAdapter.setReturnValueHandlers(newReturnValueHandlers);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>配置好后，我们将<code>TestController</code>的<code>test1</code>方法的<code>@ResponseBody</code>注解去掉，重启项目，再次访问:</p><p><img src="img/QQ截图20190228192419.png" alt="QQ截图20190228192419.png"></p><p>可以看到，返回值成功被<code>PropertiesHandlerMethodReturnValueHandler</code>的<code>handleReturnValue</code>方法解析了。</p><p>但是这里还有一个问题，我们查看控制台，会发现如下异常:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">javax.servlet.ServletException: Circular view path [test1]: would dispatch back to the current handler URL [/test1] again. Check your ViewResolver setup! (Hint: This may be the result of an unspecified view, due to default view name generation.)</span><br><span class="line">	at org.springframework.web.servlet.view.InternalResourceView.prepareForRendering(InternalResourceView.java:209) ~[spring-webmvc-5.1.2.RELEASE.jar:5.1.2.RELEASE]</span><br><span class="line">	at org.springframework.web.servlet.view.InternalResourceView.renderMergedOutputModel(InternalResourceView.java:147) ~[spring-webmvc-5.1.2.RELEASE.jar:5.1.2.RELEASE]</span><br><span class="line">	at org.springframework.web.servlet.view.AbstractView.render(AbstractView.java:316) ~[spring-webmvc-5.1.2.RELEASE.jar:5.1.2.RELEASE]</span><br><span class="line">	at org.springframework.web.servlet.DispatcherServlet.render(DispatcherServlet.java:1370) ~[spring-webmvc-5.1.2.RELEASE.jar:5.1.2.RELEASE]</span><br><span class="line">	at org.springframework.web.servlet.DispatcherServlet.processDispatchResult(DispatcherServlet.java:1116) ~[spring-webmvc-5.1.2.RELEASE.jar:5.1.2.RELEASE]</span><br><span class="line">	at org.springframework.web.servlet.DispatcherServlet.doDispatch(DispatcherServlet.java:1055) ~[spring-webmvc-5.1.2.RELEASE.jar:5.1.2.RELEASE]</span><br><span class="line">	at org.springframework.web.servlet.DispatcherServlet.doService(DispatcherServlet.java:942) ~[spring-webmvc-5.1.2.RELEASE.jar:5.1.2.RELEASE]</span><br><span class="line">	at org.springframework.web.servlet.FrameworkServlet.processRequest(FrameworkServlet.java:998) ~[spring-webmvc-5.1.2.RELEASE.jar:5.1.2.RELEASE]</span><br><span class="line">	at org.springframework.web.servlet.FrameworkServlet.doGet(FrameworkServlet.java:890) ~[spring-webmvc-5.1.2.RELEASE.jar:5.1.2.RELEASE]</span><br><span class="line">	at javax.servlet.http.HttpServlet.service(HttpServlet.java:634) ~[tomcat-embed-core-9.0.12.jar:9.0.12]</span><br><span class="line">	at org.springframework.web.servlet.FrameworkServlet.service(FrameworkServlet.java:875) ~[spring-webmvc-5.1.2.RELEASE.jar:5.1.2.RELEASE]</span><br><span class="line">	at javax.servlet.http.HttpServlet.service(HttpServlet.java:741) ~[tomcat-embed-core-9.0.12.jar:9.0.12]</span><br><span class="line">	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:231) ~[tomcat-embed-core-9.0.12.jar:9.0.12]</span><br><span class="line">	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) ~[tomcat-embed-core-9.0.12.jar:9.0.12]</span><br><span class="line">	at org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:53) ~[tomcat-embed-websocket-9.0.12.jar:9.0.12]</span><br><span class="line">	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) ~[tomcat-embed-core-9.0.12.jar:9.0.12]</span><br><span class="line">	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) ~[tomcat-embed-core-9.0.12.jar:9.0.12]</span><br><span class="line">	at org.springframework.web.filter.RequestContextFilter.doFilterInternal(RequestContextFilter.java:99) ~[spring-web-5.1.2.RELEASE.jar:5.1.2.RELEASE]</span><br><span class="line">	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107) ~[spring-web-5.1.2.RELEASE.jar:5.1.2.RELEASE]</span><br><span class="line">	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) ~[tomcat-embed-core-9.0.12.jar:9.0.12]</span><br><span class="line">	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) ~[tomcat-embed-core-9.0.12.jar:9.0.12]</span><br><span class="line">	at org.springframework.web.filter.FormContentFilter.doFilterInternal(FormContentFilter.java:92) ~[spring-web-5.1.2.RELEASE.jar:5.1.2.RELEASE]</span><br><span class="line">	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107) ~[spring-web-5.1.2.RELEASE.jar:5.1.2.RELEASE]</span><br><span class="line">	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) ~[tomcat-embed-core-9.0.12.jar:9.0.12]</span><br><span class="line">	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) ~[tomcat-embed-core-9.0.12.jar:9.0.12]</span><br><span class="line">	at org.springframework.web.filter.HiddenHttpMethodFilter.doFilterInternal(HiddenHttpMethodFilter.java:93) ~[spring-web-5.1.2.RELEASE.jar:5.1.2.RELEASE]</span><br><span class="line">	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107) ~[spring-web-5.1.2.RELEASE.jar:5.1.2.RELEASE]</span><br><span class="line">	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) ~[tomcat-embed-core-9.0.12.jar:9.0.12]</span><br><span class="line">	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) ~[tomcat-embed-core-9.0.12.jar:9.0.12]</span><br><span class="line">	at org.springframework.web.filter.CharacterEncodingFilter.doFilterInternal(CharacterEncodingFilter.java:200) ~[spring-web-5.1.2.RELEASE.jar:5.1.2.RELEASE]</span><br><span class="line">	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107) ~[spring-web-5.1.2.RELEASE.jar:5.1.2.RELEASE]</span><br><span class="line">	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) ~[tomcat-embed-core-9.0.12.jar:9.0.12]</span><br><span class="line">	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) ~[tomcat-embed-core-9.0.12.jar:9.0.12]</span><br><span class="line">	at org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:199) ~[tomcat-embed-core-9.0.12.jar:9.0.12]</span><br><span class="line">	at org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:96) [tomcat-embed-core-9.0.12.jar:9.0.12]</span><br><span class="line">	at org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:490) [tomcat-embed-core-9.0.12.jar:9.0.12]</span><br><span class="line">	at org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:139) [tomcat-embed-core-9.0.12.jar:9.0.12]</span><br><span class="line">	at org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:92) [tomcat-embed-core-9.0.12.jar:9.0.12]</span><br><span class="line">	at org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:74) [tomcat-embed-core-9.0.12.jar:9.0.12]</span><br><span class="line">	at org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:343) [tomcat-embed-core-9.0.12.jar:9.0.12]</span><br><span class="line">	at org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:408) [tomcat-embed-core-9.0.12.jar:9.0.12]</span><br><span class="line">	at org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:66) [tomcat-embed-core-9.0.12.jar:9.0.12]</span><br><span class="line">	at org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:770) [tomcat-embed-core-9.0.12.jar:9.0.12]</span><br><span class="line">	at org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1415) [tomcat-embed-core-9.0.12.jar:9.0.12]</span><br><span class="line">	at org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:49) [tomcat-embed-core-9.0.12.jar:9.0.12]</span><br><span class="line">	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149) [na:1.8.0_171]</span><br><span class="line">	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624) [na:1.8.0_171]</span><br><span class="line">	at org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:61) [tomcat-embed-core-9.0.12.jar:9.0.12]</span><br><span class="line">	at java.lang.Thread.run(Thread.java:748) [na:1.8.0_171]</span><br></pre></td></tr></table></figure><p>这是因为，在Spring中如果Controller中的方法没有被<code>@ResponseBody</code>标注的话，默认会把返回值当成视图的名称，而这里我们并不希望解析的Properties值被当成视图名称，所以我们需要在<code>PropertiesHandlerMethodReturnValueHandler</code>的<code>handleReturnValue</code>方法最后一行添加如下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 告诉 Spring MVC 请求已经处理完毕</span></span><br><span class="line">mavContainer.setRequestHandled(<span class="keyword">true</span>);</span><br></pre></td></tr></table></figure><p>这行代码告诉Spring，请求已经成功完成了，无需进行后续的处理。重启项目再次访问上面的请求，控制台便不再抛异常了。</p><blockquote><p>源码链接：<a href="https://github.com/wuyouzhuguli/SpringAll/tree/master/47.Spring-Boot-Content-Negotiation" target="_blank" rel="noopener">https://github.com/wuyouzhuguli/SpringAll/tree/master/47.Spring-Boot-Content-Negotiation</a></p></blockquote><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Thu Mar 21 2019 09:22:44 GMT+0800 (GMT+08:00) --&gt;&lt;p&gt;&lt;strong&gt;内容协商&lt;/strong&gt;机制是指客户端和服务器端就响应的资源内容进行交涉，然后提供给客户端最为适合的资源。内容协商会以响应资源的语言、字符集、编码方式等作为判断的基准。HTTP请求头中Content-Type，Accept等内容就是内容协商判断的标准。在Spring Boot中，一个完整的内容协商过程如下图所示：&lt;/p&gt;
    
    </summary>
    
    
      <category term="Spring" scheme="http://mrbird.cc/tags/Spring/"/>
    
      <category term="Spring Boot" scheme="http://mrbird.cc/tags/Spring-Boot/"/>
    
  </entry>
  
  <entry>
    <title>Spring Boot配合Hibernate Validator参数校验</title>
    <link href="http://mrbird.cc/Spring-Boot-Hibernate-Validator-Params-Check.html"/>
    <id>http://mrbird.cc/Spring-Boot-Hibernate-Validator-Params-Check.html</id>
    <published>2018-09-14T02:01:45.000Z</published>
    <updated>2019-03-13T10:50:11.216Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Mar 21 2019 09:22:41 GMT+0800 (GMT+08:00) --><p>Spring Boot中结合Hibernate Validator可以实现优雅的参数校验，而不必在业务代码中写一大堆的参数校验逻辑。Hibernate Validator的基本使用可以参考<a href="/Spring表单校验.html">Spring表单校验</a>，这里介绍一种结合全局异常捕获的方式来实现低耦合简洁的参数校验解决方案。</p><a id="more"></a><h2 id="方法参数校验"><a href="#方法参数校验" class="headerlink" title="方法参数校验"></a>方法参数校验</h2><p>新建一个Spring Boot工程，版本为2.1.0.RELEASE，<code>artifactId</code>为<code>validator</code>，并引入<code>spring-boot-starter-web</code>和<code>commons-lang3</code>依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.commons<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-lang3<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><p></p><p>项目结构如下所示：</p><p><img src="img/QQ截图20190227113219.png" alt="QQ截图20190227113219.png"></p><p><code>spring-boot-starter-web</code>已经包含了<code>hibernate-validator</code>，所以无需单独引入： <img src="img/QQ截图20190227114315.png" alt="QQ截图20190227114315.png"></p><p>在<code>com.example.demo</code>下新建<code>controller</code>包，然后创建<code>TestController</code>，定义一个<code>test1</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@Validated</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"test1"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">test1</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">            @NotBlank(message = <span class="string">"&#123;required&#125;"</span>)</span> String name,</span></span><br><span class="line"><span class="function">            @<span class="title">Email</span><span class="params">(message = <span class="string">"&#123;invalid&#125;"</span>)</span> String email) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"success"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p><code>test1</code>方法的<code>name</code>参数使用<code>@NotBlank</code>标注，表示不能为空，提示信息为<code>{required}</code>占位符里的内容；<code>email</code>参数使用<code>@Email</code>注解标注，表示必须为一个合法的邮箱值（可以为空），提示信息为<code>{invalid}</code>占位符里的内容。要让参数校验生效，我们还需在类上使用<code>@Validated</code>注解标注。</p><p>接下来定义上面两个占位符的内容。在resources目录下新建ValidationMessages.properties文件，内容如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">required=\u4e0d\u80fd\u4e3a\u7a7a</span><br><span class="line">invalid=\u683c\u5f0f\u4e0d\u5408\u6cd5</span><br></pre></td></tr></table></figure><p></p><p>内容为中文转Unicode后的值，可以使用<a href="http://tool.chinaz.com/tools/unicode.aspx" target="_blank" rel="noopener">http://tool.chinaz.com/tools/unicode.aspx</a>网站转换，<code>\u4e0d\u80fd\u4e3a\u7a7a</code>转为中文为“不能为空”，<code>\u683c\u5f0f\u4e0d\u5408\u6cd5</code>转为中文为“格式不合法”。</p><p>启动项目，使用Postman进行测试，参数内容如下所示：</p><p><img src="img/QQ截图20190227140409.png" alt="QQ截图20190227140409.png"></p><p>这里<code>name</code>参数值为空，<code>email</code>参数值为123，访问后，控制台输出异常如下：</p><p><img src="img/QQ截图20190227140521.png" alt="QQ截图20190227140521.png"></p><p>可见，使用这种方式参数校验不通过时，会抛出<code>javax.validation.ConstraintViolationException</code>，我们使用全局异常捕获来处理这种异常：</p><p>在<code>com.example.demo</code>下新建<code>handler</code>包，然后创建<code>GlobalExceptionHandler</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestControllerAdvice</span></span><br><span class="line"><span class="meta">@Order</span>(value = Ordered.HIGHEST_PRECEDENCE)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GlobalExceptionHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 统一处理请求参数校验(普通传参)</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> e ConstraintViolationException</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> FebsResponse</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@ExceptionHandler</span>(value = ConstraintViolationException.class)</span><br><span class="line">    <span class="meta">@ResponseStatus</span>(HttpStatus.BAD_REQUEST)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">handleConstraintViolationException</span><span class="params">(ConstraintViolationException e)</span> </span>&#123;</span><br><span class="line">        StringBuilder message = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        Set&lt;ConstraintViolation&lt;?&gt;&gt; violations = e.getConstraintViolations();</span><br><span class="line">        <span class="keyword">for</span> (ConstraintViolation&lt;?&gt; violation : violations) &#123;</span><br><span class="line">            Path path = violation.getPropertyPath();</span><br><span class="line">            String[] pathArr = StringUtils.splitByWholeSeparatorPreserveAllTokens(path.toString(), <span class="string">"."</span>);</span><br><span class="line">            message.append(pathArr[<span class="number">1</span>]).append(violation.getMessage()).append(<span class="string">","</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        message = <span class="keyword">new</span> StringBuilder(message.substring(<span class="number">0</span>, message.length() - <span class="number">1</span>));</span><br><span class="line">        <span class="keyword">return</span> message.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>上面主要的逻辑是获取校验不通过的参数名称，然后拼接上提示信息，并且HTTP返回状态码为400。重启项目，再次访问刚刚的链接，响应如下所示：</p><p><img src="img/QQ截图20190227141744.png" alt="QQ截图20190227141744.png"></p><h2 id="使用实体传参"><a href="#使用实体传参" class="headerlink" title="使用实体传参"></a>使用实体传参</h2><p>当参数较少的时候可以使用上面这种方式，但如果参数众多上面的方式就略显繁琐了。这时候我们可以使用实体对象来进行传参。</p><p>为了模拟这种情况，我们在<code>com.example.demo</code>路径下新建<code>domain</code>包，然后新建<code>User</code>类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">2731598327208972274L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@NotBlank</span>(message = <span class="string">"&#123;required&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Email</span>(message = <span class="string">"&#123;invalid&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String email;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getEmail</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> email;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setEmail</span><span class="params">(String email)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.email = email;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>接着在<code>TestController</code>里创建一个<code>test2</code>方法:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"test2"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">test2</span><span class="params">(@Valid User user)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"success"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>使用实体对象传参的方式参数校验需要在相应的参数前加上<code>@Valid</code>注解。重启项目，再次访问下面这个请求： <img src="img/QQ截图20190227140409.png" alt="QQ截图20190227140409.png"></p><p>控制台会输出如下信息:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Resolved [org.springframework.validation.BindException: org.springframework.validation.BeanPropertyBindingResult: 2 errors</span><br><span class="line">Field error in object &apos;user&apos; on field &apos;name&apos;: rejected value []; codes [NotBlank.user.name,NotBlank.name,NotBlank.java.lang.String,NotBlank]; arguments [org.springframework.context.support.DefaultMessageSourceResolvable: codes [user.name,name]; arguments []; default message [name]]; default message [不能为空]</span><br><span class="line">Field error in object &apos;user&apos; on field &apos;email&apos;: rejected value [123]; codes [Email.user.email,Email.email,Email.java.lang.String,Email]; arguments [org.springframework.context.support.DefaultMessageSourceResolvable: codes [user.email,email]; arguments []; default message [email],[Ljavax.validation.constraints.Pattern$Flag;@5fb82092,org.springframework.validation.beanvalidation.SpringValidatorAdapter$ResolvableAttribute@cc0c307]; default message [格式不合法]]</span><br></pre></td></tr></table></figure><p>这时候我们需要在<code>GlobalExceptionHandler</code>捕获<code>org.springframework.validation.BindException</code>异常：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 统一处理请求参数校验(实体对象传参)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> e BindException</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> FebsResponse</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@ExceptionHandler</span>(BindException.class)</span><br><span class="line"><span class="meta">@ResponseStatus</span>(HttpStatus.BAD_REQUEST)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">validExceptionHandler</span><span class="params">(BindException e)</span> </span>&#123;</span><br><span class="line">    StringBuilder message = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    List&lt;FieldError&gt; fieldErrors = e.getBindingResult().getFieldErrors();</span><br><span class="line">    <span class="keyword">for</span> (FieldError error : fieldErrors) &#123;</span><br><span class="line">        message.append(error.getField()).append(error.getDefaultMessage()).append(<span class="string">","</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    message = <span class="keyword">new</span> StringBuilder(message.substring(<span class="number">0</span>, message.length() - <span class="number">1</span>));</span><br><span class="line">    <span class="keyword">return</span> message.toString();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>重启项目，再次访问刚刚的请求，响应如下所示:</p><p><img src="img/QQ截图20190227143248.png" alt="QQ截图20190227143248.png"></p><p>我们将请求参数改为合法的内容：</p><p><img src="img/QQ截图20190227143400.png" alt="QQ截图20190227143400.png"></p><p>点击访问，响应如下所示:</p><p><img src="img/QQ截图20190227143434.png" alt="QQ截图20190227143434.png"></p><blockquote><p>源码链接：<a href="https://github.com/wuyouzhuguli/SpringAll/tree/master/46.Spring-Boot-Hibernate-Validator" target="_blank" rel="noopener">https://github.com/wuyouzhuguli/SpringAll/tree/master/46.Spring-Boot-Hibernate-Validator</a></p></blockquote><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Thu Mar 21 2019 09:22:41 GMT+0800 (GMT+08:00) --&gt;&lt;p&gt;Spring Boot中结合Hibernate Validator可以实现优雅的参数校验，而不必在业务代码中写一大堆的参数校验逻辑。Hibernate Validator的基本使用可以参考&lt;a href=&quot;/Spring表单校验.html&quot;&gt;Spring表单校验&lt;/a&gt;，这里介绍一种结合全局异常捕获的方式来实现低耦合简洁的参数校验解决方案。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Spring" scheme="http://mrbird.cc/tags/Spring/"/>
    
      <category term="Spring Boot" scheme="http://mrbird.cc/tags/Spring-Boot/"/>
    
  </entry>
  
  <entry>
    <title>深入学习Spring Boot中的SpringApplication</title>
    <link href="http://mrbird.cc/deepin-springboot-application.html"/>
    <id>http://mrbird.cc/deepin-springboot-application.html</id>
    <published>2018-09-04T06:54:26.000Z</published>
    <updated>2019-03-13T10:50:36.507Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Mar 21 2019 09:22:43 GMT+0800 (GMT+08:00) --><p>在Spring Boot的入口类中，我们通常是通过调用<code>SpringApplication</code>的run方法来启动Spring Boot项目。这节我们来深入学习下SpringApplication的一些细节。</p><h2 id="自定义SpringApplication"><a href="#自定义SpringApplication" class="headerlink" title="自定义SpringApplication"></a>自定义SpringApplication</h2><p>默认的我们都是直接通过<code>SpringApplication</code>的run方法来直接启动Spring Boot，其实我们可以通过一些API来调整某些行为。<a id="more"></a></p><h3 id="通过SpringApplication-API调整"><a href="#通过SpringApplication-API调整" class="headerlink" title="通过SpringApplication API调整"></a>通过SpringApplication API调整</h3><p>我们新建一个SpringBoot项目，Spring Boot版本为2.1.0.RELEASE，<code>artifactId</code>为SpringApplication，并引入<code>spring-boot-starter-web</code>依赖。项目结构如下所示:</p><p><img src="img/QQ截图20190223103358.png" alt="QQ截图20190223103358.png"></p><p>我们将入口类的代码改为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SpringApplication application = <span class="keyword">new</span> SpringApplication(DemoApplication.class);</span><br><span class="line">application.setBannerMode(Banner.Mode.OFF);</span><br><span class="line">application.setWebApplicationType(WebApplicationType.NONE);</span><br><span class="line">application.setAdditionalProfiles(<span class="string">"dev"</span>);</span><br><span class="line">application.run(args);</span><br></pre></td></tr></table></figure><p></p><p>通过调用<code>SpringApplication</code>的方法，我们关闭了Banner的打印，设置应用环境为非WEB应用，profiles指定为dev。除此之外，<code>SpringApplication</code>还包含了许多别的方法，具体可以查看源码或者官方文档：</p><p><img src="img/QQ截图20190223101959.png" alt="QQ截图20190223101959.png"></p><h3 id="通过SpringApplicationBuilder-API调整"><a href="#通过SpringApplicationBuilder-API调整" class="headerlink" title="通过SpringApplicationBuilder API调整"></a>通过SpringApplicationBuilder API调整</h3><p><code>SpringApplicationBuilder</code>提供了Fluent API，可以实现链式调用，下面的代码和上面的效果一致，但在编写上较为方便：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> SpringApplicationBuilder(DemoApplication.class)</span><br><span class="line">        .bannerMode(Banner.Mode.OFF)</span><br><span class="line">        .web(WebApplicationType.NONE)</span><br><span class="line">        .profiles(<span class="string">"dev"</span>)</span><br><span class="line">        .run(args);</span><br></pre></td></tr></table></figure><h2 id="SpringApplication准备阶段"><a href="#SpringApplication准备阶段" class="headerlink" title="SpringApplication准备阶段"></a>SpringApplication准备阶段</h2><p><code>SpringApplicaiton</code>的生命周期阶段大致可以分为准备阶段和运行阶段。</p><p>我们通过源码来查看<code>SpringApplication</code>的有参构造器：</p><p><img src="img/QQ截图20190223102806.png" alt="QQ截图20190223102806.png"></p><p>通过有参构造器里的代码我们可以将<code>SpringApplication</code>的准备阶段分为以下几个步骤：</p><h3 id="配置源"><a href="#配置源" class="headerlink" title="配置源"></a>配置源</h3><p>构造器中<code>this.primarySources = new LinkedHashSet&lt;&gt;(Arrays.asList(primarySources));</code>这行代码用于加载我们配置的Spring Boot Bean源。通常我们使用<code>SpringApplication</code>或者<code>SpringApplicationBuilder</code>的构造器来直接指定源。</p><p>所谓的Spring Boot Bean源指的是某个被<code>@SpringBootApplication</code>注解标注的类，比如入口类：</p><p><img src="img/QQ截图20190223104742.png" alt="QQ截图20190223104742.png"></p><p>我们也可以将上面的代码改为下面这种方式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication application = <span class="keyword">new</span> SpringApplication(ApplicationResource.class);</span><br><span class="line">        application.run(args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SpringBootApplication</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ApplicationResource</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>这样也是可行的。查看<code>SpringApplicaiton</code>的单个参数构造器：</p><p><img src="img/QQ截图20190223105200.png" alt="QQ截图20190223105200.png"></p><p>说明我们除了配置单个源外，还可以配置多个源。</p><h3 id="推断应用类型"><a href="#推断应用类型" class="headerlink" title="推断应用类型"></a>推断应用类型</h3><p>构造器中这行<code>this.webApplicationType = WebApplicationType.deduceFromClasspath();</code>代码用于推断当前Spring Boot应用类型。</p><p>Spring Boot 2.0后，应用可以分为下面三种类型：</p><ol><li><p><code>WebApplicationType.NONE</code>：非WEB类型；</p></li><li><p><code>WebApplicationType.REACTIVE</code>：Web Reactive类型；</p></li><li><p><code>WebApplicationType.SERVLET</code>：Web Servlet类型。</p></li></ol><p><code>WebApplicationType.deduceFromClasspath()</code>或根据当前应用ClassPath中是否存在相关的实现类来判断应用类型到底是哪个，<code>deduceFromClasspath</code>方法的源码如下所示:</p><p><img src="img/QQ截图20190223105842.png" alt="QQ截图20190223105842.png"></p><p>我们也可以直接通过<code>SpringApplication</code>的<code>setWebApplicationType</code>方法或者<code>SpringApplicationBuilder</code>的<code>web</code>方法来指定当前应用的类型。</p><h3 id="加载应用上下文初始器"><a href="#加载应用上下文初始器" class="headerlink" title="加载应用上下文初始器"></a>加载应用上下文初始器</h3><p>接着下一行代码<code>setInitializers((Collection) getSpringFactoriesInstances(ApplicationContextInitializer.class));</code>用于加载应用上下文初始器<code>ApplicationContextInitializer</code>。</p><p><code>getSpringFactoriesInstances</code>方法的源码如下所示：</p><p><img src="img/QQ截图20190223110924.png" alt="QQ截图20190223110924.png"></p><p>上面代码利用Spring工厂加载机制，实例化<code>ApplicationContextInitializer</code>实现类，并进行排序。</p><p>所以我们可以通过实现<code>ApplicationContextInitializer</code>接口用于在Spring Boot应用初始化之前执行一些自定义操作。</p><p>举个例子，在<code>com.example.demo</code>下新建<code>initializer</code>包，然后创建一个<code>HelloApplicationContextInitializer</code>类，实现<code>ApplicationContextInitializer</code>接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Order</span>(Ordered.HIGHEST_PRECEDENCE)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloApplicationContextInitializer</span> <span class="keyword">implements</span> <span class="title">ApplicationContextInitializer</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initialize</span><span class="params">(ConfigurableApplicationContext applicationContext)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"ConfigurableApplicationContext.id - "</span> + applicationContext.getId());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>上面代码中实现了initialize方法，并且使用<code>@Order</code>注解指定优先级。其中<code>Ordered.HIGHEST_PRECEDENCE</code>等于<code>Integer.MIN_VALUE</code>，<code>Ordered.LOWEST_PRECEDENCE</code>等于<code>Integer.MAX_VALUE</code>。所以数值越小，优先级越高。</p><p>除了使用<code>@Order</code>注解来指定优先级外，我们也可以通过实现<code>org.springframework.core.Ordered</code>接口的<code>getOrder</code>方法来指定优先级。</p><p>接着我们来创建一个优先级比<code>HelloApplicationContextInitializer</code>低的Initializer —— <code>AfterHelloApplicationContextInitializer</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AfterHelloApplicationContextInitializer</span> <span class="keyword">implements</span> <span class="title">ApplicationContextInitializer</span>, <span class="title">Ordered</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initialize</span><span class="params">(ConfigurableApplicationContext applicationContext)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"AfterHelloApplicationContextInitializer: "</span> + applicationContext.getId());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Ordered.LOWEST_PRECEDENCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>上面通过<code>getOrder</code>方法来指定了优先级为最低优先级。</p><p>创建好后，我们还需在工厂配置文件里配置这两个实现类。在resources目录下新建META-INF目录，并创建spring.factories文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># Initializers</span><br><span class="line">org.springframework.context.ApplicationContextInitializer=\</span><br><span class="line">com.example.demo.initializer.HelloApplicationContextInitializer,\</span><br><span class="line">com.example.demo.initializer.AfterHelloApplicationContextInitializer</span><br></pre></td></tr></table></figure><p></p><p>这时候，启动Spring Boot项目，会发现控制台在打印Banner后就执行了这两个初始化器，并且<code>HelloApplicationContextInitializer</code>的<code>initialize</code>方法执行时机先于<code>AfterHelloApplicationContextInitializer</code>的<code>initialize</code>方法：</p><p><img src="img/QQ截图20190223155233.png" alt="QQ截图20190223155233.png"></p><h3 id="加载应用事件监听器"><a href="#加载应用事件监听器" class="headerlink" title="加载应用事件监听器"></a>加载应用事件监听器</h3><p>在加载完应用上下文初始器后，下一行的<code>setListeners((Collection) getSpringFactoriesInstances(ApplicationListener.class));</code>代码加载了应用事件监听器。与加载事件上下文初始器类似，Spring Boot也是通过Spring的工厂方法来实例化<code>ApplicationListener</code>的实现类，并进行排序。</p><p>既然是事件监听，那么其可以监听什么事件呢？其监听的是<code>ApplicationEvent</code>接口的实现类，我们查看一下都有哪些事件实现了这个接口：</p><p><img src="img/QQ截图20190223162205.png" alt="QQ截图20190223162205.png"></p><p>这里我们以<code>ContextClosedEvent</code>为例子来编写自定义的应用事件监听器，监听Spring上下文关闭事件。</p><p>在<code>com.example.demo</code>下新建<code>listener</code>包，然后创建一个<code>ContextClosedEventListener</code>类，实现<code>ApplicationListener</code>接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Order</span>(Ordered.HIGHEST_PRECEDENCE)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ContextClosedEventListener</span> <span class="keyword">implements</span> <span class="title">ApplicationListener</span>&lt;<span class="title">ContextClosedEvent</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onApplicationEvent</span><span class="params">(ContextClosedEvent event)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"ContextClosedEvent: "</span> + event.getApplicationContext().getId());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>上面代码实现了对<code>ContextClosedEvent</code>事件的监听，并且分配了最高优先级。</p><p>接着创建一个优先级比<code>ContextClosedEventListener</code>低的上面代码实现了对<code>ContextClosedEvent</code>事件监听器<code>AfterContextClosedEventListener</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AfterContextClosedEventListener</span> <span class="keyword">implements</span> <span class="title">ApplicationListener</span>&lt;<span class="title">ContextClosedEvent</span>&gt;, <span class="title">Ordered</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onApplicationEvent</span><span class="params">(ContextClosedEvent event)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"AfterContextClosedEventr: "</span> + event.getApplicationContext().getId());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Ordered.HIGHEST_PRECEDENCE + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>最后，别忘了在Spring工厂配置文件里进行配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># Application Listeners</span><br><span class="line">org.springframework.context.ApplicationListener=\</span><br><span class="line">com.example.demo.listener.ContextClosedEventListener,\</span><br><span class="line">com.example.demo.listener.AfterContextClosedEventListener</span><br></pre></td></tr></table></figure><p></p><p>在Spring Boot入口类中将环境指定为非WEB环境（这样在启动后应用会马上关闭）:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> SpringApplicationBuilder(DemoApplication.class)</span><br><span class="line">                .web(WebApplicationType.NONE)</span><br><span class="line">                .run(args);</span><br></pre></td></tr></table></figure><p></p><p>运行Spring Boot入口类，控制台输出如下： <img src="img/QQ截图20190223162948.png" alt="QQ截图20190223162948.png"></p><h3 id="推断入口类"><a href="#推断入口类" class="headerlink" title="推断入口类"></a>推断入口类</h3><p>接着构造器里的代码下一行<code>this.mainApplicationClass = deduceMainApplicationClass();</code>用于推断运行Spring Boot应用的入口类。查看<code>deduceMainApplicationClass</code>方法源码：</p><p><img src="img/QQ截图20190225093317.png" alt="QQ截图20190225093317.png"></p><p>代码主要逻辑是根据Main线程执行堆栈判断实际的入口类。</p><p>准备阶段介绍完毕后，接下来开始介绍运行阶段。</p><h2 id="SpringApplication运行阶段"><a href="#SpringApplication运行阶段" class="headerlink" title="SpringApplication运行阶段"></a>SpringApplication运行阶段</h2><p>SpringApplication的运行阶段对应<code>SpringApplication</code>的<code>run</code>方法，我们查看其源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ConfigurableApplicationContext <span class="title">run</span><span class="params">(String... args)</span> </span>&#123;</span><br><span class="line">    StopWatch stopWatch = <span class="keyword">new</span> StopWatch();</span><br><span class="line">    stopWatch.start();</span><br><span class="line">    ConfigurableApplicationContext context = <span class="keyword">null</span>;</span><br><span class="line">    Collection&lt;SpringBootExceptionReporter&gt; exceptionReporters = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    configureHeadlessProperty();</span><br><span class="line">    SpringApplicationRunListeners listeners = getRunListeners(args);</span><br><span class="line">    listeners.starting();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ApplicationArguments applicationArguments = <span class="keyword">new</span> DefaultApplicationArguments(</span><br><span class="line">                args);</span><br><span class="line">        ConfigurableEnvironment environment = prepareEnvironment(listeners,</span><br><span class="line">                applicationArguments);</span><br><span class="line">        configureIgnoreBeanInfo(environment);</span><br><span class="line">        Banner printedBanner = printBanner(environment);</span><br><span class="line">        context = createApplicationContext();</span><br><span class="line">        exceptionReporters = getSpringFactoriesInstances(</span><br><span class="line">                SpringBootExceptionReporter.class,</span><br><span class="line">                <span class="keyword">new</span> Class[]&#123;ConfigurableApplicationContext.class&#125;, context);</span><br><span class="line">        prepareContext(context, environment, listeners, applicationArguments,</span><br><span class="line">                printedBanner);</span><br><span class="line">        refreshContext(context);</span><br><span class="line">        afterRefresh(context, applicationArguments);</span><br><span class="line">        stopWatch.stop();</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.logStartupInfo) &#123;</span><br><span class="line">            <span class="keyword">new</span> StartupInfoLogger(<span class="keyword">this</span>.mainApplicationClass)</span><br><span class="line">                    .logStarted(getApplicationLog(), stopWatch);</span><br><span class="line">        &#125;</span><br><span class="line">        listeners.started(context);</span><br><span class="line">        callRunners(context, applicationArguments);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">        handleRunFailure(context, ex, exceptionReporters, listeners);</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(ex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        listeners.running(context);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">        handleRunFailure(context, ex, exceptionReporters, <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(ex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> context;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>运行阶段大致可以分为下面这几个过程：</p><h3 id="开启时间监听"><a href="#开启时间监听" class="headerlink" title="开启时间监听"></a>开启时间监听</h3><p><code>run</code>方法开头的这两行代码用于开启时间监听：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">StopWatch stopWatch = <span class="keyword">new</span> StopWatch();</span><br><span class="line">stopWatch.start();</span><br></pre></td></tr></table></figure><p></p><p>上面代码用于开启Spring Boot应用启动时间监听，配合下面的<code>stopWatch.stop();</code>便可以计算出完整的启动时间。</p><h3 id="开启运行监听器"><a href="#开启运行监听器" class="headerlink" title="开启运行监听器"></a>开启运行监听器</h3><p><code>run</code>方法的这几行代码用于加载Spring应用运行监听器（SpringApplicationRunListener）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SpringApplicationRunListeners listeners = getRunListeners(args);</span><br><span class="line">listeners.started();</span><br></pre></td></tr></table></figure><p></p><p><code>getRunListeners</code>方法源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> SpringApplicationRunListeners <span class="title">getRunListeners</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Class&lt;?&gt;[] types = <span class="keyword">new</span> Class&lt;?&gt;[] &#123; SpringApplication.class, String[].class &#125;;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> SpringApplicationRunListeners(logger, getSpringFactoriesInstances(</span><br><span class="line">        SpringApplicationRunListener.class, types, <span class="keyword">this</span>, args));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>上面代码通过<code>SpringFactoriesLoader</code>检索META-INF/spring.factories找到声明的所有<code>SpringApplicationRunListener</code>的实现类并将其实例化，然后装配到<code>List&lt;SpringApplicationRunListener&gt;</code>运行监听器集合中。</p><p><code>listeners.started();</code>用于遍历运行监听器集合中的所有<code>SpringApplicationRunListener</code>的实现类，并逐一调用它们的<code>starting</code>方法，广播Spring Boot应用要开始启动了。</p><p>在Spring Boot中<code>SpringApplicationRunListener</code>接口用于监听整个Spring Boot应用生命周期，其代码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">SpringApplicationRunListener</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">starting</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">environmentPrepared</span><span class="params">(ConfigurableEnvironment environment)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">contextPrepared</span><span class="params">(ConfigurableApplicationContext context)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">contextLoaded</span><span class="params">(ConfigurableApplicationContext context)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">started</span><span class="params">(ConfigurableApplicationContext context)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">running</span><span class="params">(ConfigurableApplicationContext context)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">failed</span><span class="params">(ConfigurableApplicationContext context, Throwable exception)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>这些方法对应着Spring Boot应用生命周期的各个阶段：</p><table><tr><th>方法名称</th><th>对应生命周期</th><th>Spring Boot起始版本</th></tr><tr><td>starting()</td><td>Spring 应用刚启动</td><td>1.0</td></tr><tr><td>environmentPrepared(ConfigurableEnvironment)</td><td>ConfigurableEnvironment 准备完毕，允许将其调整</td><td>1.0</td></tr><tr><td>contextPrepared(ConfigurableApplicationContext)</td><td>ConfigurableApplicationContext 准备完毕，允许将其调整</td><td>1.0</td></tr><tr><td>contextLoaded(ConfigurableApplicationContext)</td><td>ConfigurableApplicationContext 已装载，但仍未启动</td><td>1.0</td></tr><tr><td>started(ConfigurableApplicationContext)</td><td>ConfigurableApplicationContext 已启动，此时 Spring Bean 已初始化完成</td><td>2.0</td></tr><tr><td>running(ConfigurableApplicationContext)</td><td>Spring 应用正在运行</td><td>2.0</td></tr><tr><td>failed(ConfigurableApplicationContext,Throwable)</td><td>Spring 应用运行失败</td><td>2.0</td></tr></table><p>我们在<code>com.example.demo.linstener</code>下自定义一个<code>SpringApplicationRunListener</code>接口实现类<code>HelloSpringApplicationRunListener</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloApplicationRunListener</span> <span class="keyword">implements</span> <span class="title">SpringApplicationRunListener</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HelloApplicationRunListener</span><span class="params">(SpringApplication application, String[] args)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">starting</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"HelloApplicationRunListener starting......"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">environmentPrepared</span><span class="params">(ConfigurableEnvironment environment)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">contextPrepared</span><span class="params">(ConfigurableApplicationContext context)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">contextLoaded</span><span class="params">(ConfigurableApplicationContext context)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">started</span><span class="params">(ConfigurableApplicationContext context)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">running</span><span class="params">(ConfigurableApplicationContext context)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">failed</span><span class="params">(ConfigurableApplicationContext context, Throwable exception)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>通过这个实现类，我们可以在Spring Boot应用刚启动的时候在控制台输出<code>HelloApplicationRunListener starting......</code>。</p><p>因为其基于Spring的工厂方法来实现，所以我们需要在spring.factories文件里配置这个实现类:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># Run Listeners</span><br><span class="line">org.springframework.boot.SpringApplicationRunListener=\</span><br><span class="line">com.example.demo.run.HelloApplicationRunListener</span><br></pre></td></tr></table></figure><p></p><p>启动Spring Boot应用便可以在控制台看到如下输出了：</p><p><img src="img/QQ截图20190225101411.png" alt="QQ截图20190225101411.png"></p><h3 id="创建-Environment"><a href="#创建-Environment" class="headerlink" title="创建 Environment"></a>创建 Environment</h3><p><code>run</code>方法中的这行代码用于创建并配置当前SpringBoot应用将要使用的Environment（包括配置要使用的PropertySource以及Profile）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ConfigurableEnvironment environment = prepareEnvironment(listeners, applicationArguments);</span><br></pre></td></tr></table></figure><p></p><p>我们已经在准备阶段里推断出了应用类型，这里只要根据相应的应用类型来创建相应的应用环境即可，类型和环境对应关系如下：</p><ul><li><p>Web Reactive： StandardReactiveWebEnvironment</p></li><li><p>Web Servlet： StandardServletEnvironment</p></li><li><p>非 Web： StandardEnvironment</p></li></ul><p>在<code>prepareEnvironment</code>方法中会执行<code>listeners.environmentPrepared(environment);</code>，用于遍历调用所有<code>SpringApplicationRunListener</code>实现类的<code>environmentPrepared()</code>方法，广播Environment准备完毕。</p><h3 id="是否打印Banner"><a href="#是否打印Banner" class="headerlink" title="是否打印Banner"></a>是否打印Banner</h3><p><code>run</code>方法中的这行代码会根据我们的配置来决定是否打印Banner：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Banner printedBanner = printBanner(environment);</span><br></pre></td></tr></table></figure><p></p><h3 id="创建Context"><a href="#创建Context" class="headerlink" title="创建Context"></a>创建Context</h3><p><code>run</code>方法中的这行代码用于创建<code>ApplicationContext</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">context = createApplicationContext();</span><br></pre></td></tr></table></figure><p></p><p>不同的环境对应不同的<code>ApplicationContext</code>：</p><ul><li><p>Web Reactive： AnnotationConfigReactiveWebServerApplicationContext</p></li><li><p>Web Servlet： AnnotationConfigServletWebServerApplicationContext</p></li><li><p>非 Web： AnnotationConfigApplicationContext</p></li></ul><h3 id="装配Context"><a href="#装配Context" class="headerlink" title="装配Context"></a>装配Context</h3><p><code>run</code>方法中的这行代码用于装配Context：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">prepareContext(context, environment, listeners, applicationArguments, printedBanner);</span><br></pre></td></tr></table></figure><p></p><p>方法<code>prepareContext</code>的源码如下所示:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">prepareContext</span><span class="params">(ConfigurableApplicationContext context,</span></span></span><br><span class="line"><span class="function"><span class="params">                            ConfigurableEnvironment environment, SpringApplicationRunListeners listeners,</span></span></span><br><span class="line"><span class="function"><span class="params">                            ApplicationArguments applicationArguments, Banner printedBanner)</span> </span>&#123;</span><br><span class="line">    context.setEnvironment(environment);</span><br><span class="line">    postProcessApplicationContext(context);</span><br><span class="line">    applyInitializers(context);</span><br><span class="line">    listeners.contextPrepared(context);</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.logStartupInfo) &#123;</span><br><span class="line">        logStartupInfo(context.getParent() == <span class="keyword">null</span>);</span><br><span class="line">        logStartupProfileInfo(context);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Add boot specific singleton beans</span></span><br><span class="line">    ConfigurableListableBeanFactory beanFactory = context.getBeanFactory();</span><br><span class="line">    beanFactory.registerSingleton(<span class="string">"springApplicationArguments"</span>, applicationArguments);</span><br><span class="line">    <span class="keyword">if</span> (printedBanner != <span class="keyword">null</span>) &#123;</span><br><span class="line">        beanFactory.registerSingleton(<span class="string">"springBootBanner"</span>, printedBanner);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (beanFactory <span class="keyword">instanceof</span> DefaultListableBeanFactory) &#123;</span><br><span class="line">        ((DefaultListableBeanFactory) beanFactory)</span><br><span class="line">                .setAllowBeanDefinitionOverriding(<span class="keyword">this</span>.allowBeanDefinitionOverriding);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Load the sources</span></span><br><span class="line">    Set&lt;Object&gt; sources = getAllSources();</span><br><span class="line">    Assert.notEmpty(sources, <span class="string">"Sources must not be empty"</span>);</span><br><span class="line">    load(context, sources.toArray(<span class="keyword">new</span> Object[<span class="number">0</span>]));</span><br><span class="line">    listeners.contextLoaded(context);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p><code>prepareContext</code>方法开头为<code>ApplicationContext</code>加载了environment，之后通过<code>applyInitializers</code>方法逐个执行<code>ApplicationContextInitializer</code>的<code>initialize</code>方法来进一步封装<code>ApplicationContext</code>，并调用所有的<code>SpringApplicationRunListener</code>实现类的<code>contextPrepared</code>方法，广播ApplicationContext已经准备完毕了。</p><p>之后初始化IOC容器，并调用<code>SpringApplicationRunListener</code>实现类的<code>contextLoaded</code>方法，广播<code>ApplicationContext</code>加载完成，这里就包括通过<code>@EnableAutoConfiguration</code>导入的各种自动配置类。</p><h3 id="Refresh-Context"><a href="#Refresh-Context" class="headerlink" title="Refresh Context"></a>Refresh Context</h3><p><code>run</code>方法中的这行代码用于初始化所有自动配置类，并调用<code>ApplicationContext</code>的<code>refresh</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">refreshContext(context);</span><br></pre></td></tr></table></figure><p></p><h3 id="广播应用已启动"><a href="#广播应用已启动" class="headerlink" title="广播应用已启动"></a>广播应用已启动</h3><p><code>run</code>方法中的这行代码用于广播Spring Boot应用已启动：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">listeners.started(context);</span><br></pre></td></tr></table></figure><p></p><p><code>started</code>方法会调用所有的<code>SpringApplicationRunListener</code>的<code>finished</code>方法，广播SpringBoot应用已经成功启动。</p><h3 id="执行Runner"><a href="#执行Runner" class="headerlink" title="执行Runner"></a>执行Runner</h3><p><code>run</code>方法中的这行代码<code>callRunners(context, applicationArguments);</code>遍历所有<code>ApplicationRunner</code>和<code>CommandLineRunner</code>的实现类，并执行其<code>run</code>方法。我们可以实现自己的<code>ApplicationRunner</code>或者<code>CommandLineRunner</code>，来对Spring Boot的启动过程进行扩展。</p><p>我们在<code>com.example.demo</code>下新建<code>runner</code>包，然后创建一个<code>ApplicationRunner</code>的实现类<code>HelloApplicationRunner</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloApplicationRunner</span> <span class="keyword">implements</span> <span class="title">ApplicationRunner</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(ApplicationArguments args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"HelloApplicationRunner: hello spring boot"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>这里我们需要将<code>HelloApplicationRunner</code>使用<code>@Component</code>注解标注，让其注册到IOC容器中。</p><p>然后再创建一个<code>CommandLineRunner</code>的实现类<code>HelloCommandLineRunner</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloCommandLineRunner</span> <span class="keyword">implements</span> <span class="title">CommandLineRunner</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(String... args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"HelloCommandLineRunner: hello spring boot"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>启动Spring Boot应用，便可以在应用刚启动好后看到如下输出：</p><p><img src="img/QQ截图20190225112601.png" alt="QQ截图20190225112601.png"></p><h3 id="广播应用运行中"><a href="#广播应用运行中" class="headerlink" title="广播应用运行中"></a>广播应用运行中</h3><p><code>run</code>方法中的这行代码<code>listeners.running(context);</code>用于调用<code>SpringApplicationRunListener</code>的<code>running</code>方法，广播Spring Boot应用正在运行中。</p><p>当<code>run</code>方法运行出现异常时，便会调用<code>handleRunFailure</code>方法来处理异常，该方法里会通过<code>listeners.failed(context, exception);</code>来调用<code>SpringApplicationRunListener</code>的<code>failed</code>方法，广播应用启动失败，并将异常扩散出去。</p><div class="note info"><p>上面所有的广播事件都是使用Spring的应用事件广播器接口<code>ApplicationEventMulticaster</code>的实现类<code>SimpleApplicationEventMulticaster</code>来进行广播的。</p></div><blockquote><p>源码链接：<a href="https://github.com/wuyouzhuguli/SpringAll/tree/master/45.Spring-Boot-SpringApplication" target="_blank" rel="noopener">https://github.com/wuyouzhuguli/SpringAll/tree/master/45.Spring-Boot-SpringApplication</a></p></blockquote><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Thu Mar 21 2019 09:22:43 GMT+0800 (GMT+08:00) --&gt;&lt;p&gt;在Spring Boot的入口类中，我们通常是通过调用&lt;code&gt;SpringApplication&lt;/code&gt;的run方法来启动Spring Boot项目。这节我们来深入学习下SpringApplication的一些细节。&lt;/p&gt;&lt;h2 id=&quot;自定义SpringApplication&quot;&gt;&lt;a href=&quot;#自定义SpringApplication&quot; class=&quot;headerlink&quot; title=&quot;自定义SpringApplication&quot;&gt;&lt;/a&gt;自定义SpringApplication&lt;/h2&gt;&lt;p&gt;默认的我们都是直接通过&lt;code&gt;SpringApplication&lt;/code&gt;的run方法来直接启动Spring Boot，其实我们可以通过一些API来调整某些行为。
    
    </summary>
    
    
      <category term="Spring" scheme="http://mrbird.cc/tags/Spring/"/>
    
      <category term="Spring Boot" scheme="http://mrbird.cc/tags/Spring-Boot/"/>
    
  </entry>
  
  <entry>
    <title>深入学习Spring Boot自动装配</title>
    <link href="http://mrbird.cc/deepin-springboot-autoconfig.html"/>
    <id>http://mrbird.cc/deepin-springboot-autoconfig.html</id>
    <published>2018-09-02T06:54:26.000Z</published>
    <updated>2019-03-13T10:50:56.148Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Mar 21 2019 09:22:43 GMT+0800 (GMT+08:00) --><h2 id="模式注解"><a href="#模式注解" class="headerlink" title="模式注解"></a>模式注解</h2><p>Stereotype Annotation俗称为模式注解，Spring中常见的模式注解有<code>@Service</code>，<code>@Repository</code>，<code>@Controller</code>等，它们都“派生”自<code>@Component</code>注解。我们都知道，凡是被<code>@Component</code>标注的类都会被Spring扫描并纳入到IOC容器中，那么由<code>@Component</code>派生的注解所标注的类也会被扫描到IOC容器中。下面我们主要来通过自定义模式注解来了解<code>@Component</code>的“派生性”和“层次性”。</p><a id="more"></a><h3 id="Component-“派生性”"><a href="#Component-“派生性”" class="headerlink" title="@Component “派生性”"></a>@Component “派生性”</h3><p>新建一个Spring Boot工程，Spring Boot版本为2.1.0.RELEASE，<code>artifactId</code>为autoconfig，并引入<code>spring-boot-starter-web</code>依赖。项目结构如下所示:</p><p><img src="img/QQ截图20190220151447.png" alt="QQ截图20190220151447.png"></p><p>在<code>com.example.demo</code>下新建<code>annotation</code>包，然后创建一个<code>FirstLevelService</code>注解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(&#123;ElementType.TYPE&#125;)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> FirstLevelService &#123;</span><br><span class="line">    <span class="function">String <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个注解定义由<code>@Service</code>标注，查看<code>@Service</code>的源码会发现其被<code>@Component</code>注解标注，所以它们的层次关系为:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">└─@Component</span><br><span class="line">   └─@Service</span><br><span class="line">      └─@FirstLevelService</span><br></pre></td></tr></table></figure><p></p><p>即<code>@FirstLevelService</code>为<code>@Component</code>派生出来的模式注解，我们来测试一下被它标注的类是否能够被扫描到IOC容器中：</p><p>在<code>com.example.demo</code>下新建<code>service</code>包，然后创建一个<code>TestService</code>类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SecondLevelService</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestService</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>在<code>com.example.demo</code>下新建<code>bootstrap</code>包，然后创建一个<code>ServiceBootStrap</code>类，用于测试注册<code>TestService</code>并从IOC容器中获取它：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ComponentScan</span>(<span class="string">"com.example.demo.service"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServiceBootstrap</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ConfigurableApplicationContext context = <span class="keyword">new</span> SpringApplicationBuilder(ServiceBootstrap.class)</span><br><span class="line">                .web(WebApplicationType.NONE)</span><br><span class="line">                .run(args);</span><br><span class="line">        TestService testService = context.getBean(<span class="string">"testService"</span>, TestService.class);</span><br><span class="line">        System.out.println(<span class="string">"TestService Bean: "</span> + testService);</span><br><span class="line">        context.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>运行该类的main方法，控制台输出如下：</p><p><img src="img/QQ截图20190220152939.png" alt="QQ截图20190220152939.png"></p><h3 id="Component-“层次性”"><a href="#Component-“层次性”" class="headerlink" title="@Component “层次性”"></a>@Component “层次性”</h3><p>我们在<code>com.example.demo.annotation</code>路径下再创建一个<code>SecondLevelService</code>注解定义，该注解由上面的<code>@FirstLevelService</code>标注：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(&#123;ElementType.TYPE&#125;)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@FirstLevelService</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> SecondLevelService &#123;</span><br><span class="line">    <span class="function">String <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>这时候层次关系为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">└─@Component</span><br><span class="line">   └─@Service</span><br><span class="line">      └─@FirstLevelService</span><br><span class="line">            └─@SecondLevelService</span><br></pre></td></tr></table></figure><p></p><p>我们将<code>TestService</code>上的注解换成<code>@SecondLevelService</code>，然后再次运行<code>ServiceBootStrap</code>的main方法，输出如下：</p><p><img src="img/QQ截图20190220152939.png" alt="QQ截图20190220152939.png"></p><p>可见结果也是成功的。</p><div class="note danger"><p>这里有一点需要注意的是：<code>@Component</code>注解只包含一个value属性定义，所以其“派生”的注解也只能包含一个vlaue属性定义。</p></div><h2 id="Enable模块驱动"><a href="#Enable模块驱动" class="headerlink" title="@Enable模块驱动"></a>@Enable模块驱动</h2><p><code>@Enable</code>模块驱动在Spring Framework 3.1后开始支持。这里的模块通俗的来说就是一些为了实现某个功能的组件的集合。通过<code>@Enable</code>模块驱动，我们可以开启相应的模块功能。</p><p><code>@Enable</code>模块驱动可以分为“注解驱动”和“接口编程”两种实现方式，下面逐一进行演示：</p><h3 id="注解驱动"><a href="#注解驱动" class="headerlink" title="注解驱动"></a>注解驱动</h3><p>Spring中，基于注解驱动的示例可以查看<code>@EnableWebMvc</code>源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Target</span>(&#123;ElementType.TYPE&#125;)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Import</span>(&#123;DelegatingWebMvcConfiguration.class&#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnableWebMvc &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>该注解通过<code>@Import</code>导入一个配置类<code>DelegatingWebMvcConfiguration</code>：</p><p><img src="img/QQ截图20190220170120.png" alt="QQ截图20190220170120.png"></p><p>该配置类又继承自<code>WebMvcConfigurationSupport</code>，里面定义了一些Bean的声明。</p><div class="note info"><p>所以，基于注解驱动的<code>@Enable</code>模块驱动其实就是通过<code>@Import</code>来导入一个配置类，以此实现相应模块的组件注册，当这些组件注册到IOC容器中，这个模块对应的功能也就可以使用了。</p></div><p>我们来定义一个基于注解驱动的<code>@Enable</code>模块驱动。</p><p>在<code>com.example.demo</code>下新建<code>configuration</code>包，然后创建一个<code>HelloWorldConfiguration</code>配置类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorldConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"hello world"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>这个配置类里定义了一个名为<code>hello</code>的Bean，内容为<code>hello world</code>。</p><p>在<code>com.example.demo.annotation</code>下创建一个<code>EnableHelloWorld</code>注解定义：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(&#123;ElementType.TYPE&#125;)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Import</span>(HelloWorldConfiguration.class)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnableHelloWorld &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>我们在该注解类上通过<code>@Import</code>导入了刚刚创建的配置类。</p><p>接着在<code>com.example.demo.bootstrap</code>下创建一个<code>TestEnableBootstap</code>启动类来测试<code>@EnableHelloWorld</code>注解是否生效：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableHelloWorld</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestEnableBootstap</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ConfigurableApplicationContext context = <span class="keyword">new</span> SpringApplicationBuilder(TestEnableBootstap.class)</span><br><span class="line">                .web(WebApplicationType.NONE)</span><br><span class="line">                .run(args);</span><br><span class="line">        String hello = context.getBean(<span class="string">"hello"</span>, String.class);</span><br><span class="line">        System.out.println(<span class="string">"hello Bean: "</span> + hello);</span><br><span class="line">        context.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>运行该类的main方法，控制台输出如下：</p><p><img src="img/QQ截图20190220171218.png" alt="QQ截图20190220171218.png"></p><p>说明我们自定义的基于注解驱动的<code>@EnableHelloWorld</code>是可行的。</p><h3 id="接口编程"><a href="#接口编程" class="headerlink" title="接口编程"></a>接口编程</h3><p>除了使用上面这个方式外，我们还可以通过接口编程的方式来实现<code>@Enable</code>模块驱动。Spring中，基于接口编程方式的有<code>@EnableCaching</code>注解，查看其源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(&#123;ElementType.TYPE&#125;)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Import</span>(&#123;CachingConfigurationSelector.class&#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnableCaching &#123;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">proxyTargetClass</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">false</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">AdviceMode <span class="title">mode</span><span class="params">()</span> <span class="keyword">default</span> AdviceMode.PROXY</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">order</span><span class="params">()</span> <span class="keyword">default</span> 2147483647</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>EnableCaching</code>注解通过<code>@Import</code>导入了<code>CachingConfigurationSelector</code>类，该类间接实现了<code>ImportSelector</code>接口，在 <a href="/Spring-Bean-Regist.html">深入学习Spring组件注册</a> 中，我们曾介绍了可以通过<code>ImportSelector</code>来实现组件注册。</p><div class="note info"><p>所以通过接口编程实现<code>@Enable</code>模块驱动的本质是：通过<code>@Import</code>来导入接口<code>ImportSelector</code>实现类，该实现类里可以定义需要注册到IOC容器中的组件，以此实现相应模块对应组件的注册。</p></div><p>接下来我们根据这个思路来自个实现一遍：</p><p>在<code>com.example.demo</code>下新建<code>selector</code>包，然后在该路径下新建一个<code>HelloWorldImportSelector</code>实现<code>ImportSelector</code>接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorldImportSelector</span> <span class="keyword">implements</span> <span class="title">ImportSelector</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String[] selectImports(AnnotationMetadata importingClassMetadata) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> String[]&#123;HelloWorldConfiguration.class.getName()&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>如果看不懂上面这段代码含义的朋友可以阅读<a href="/Spring-Bean-Regist.html">深入学习Spring组件注册</a>一文。</p><p>接着我们修改<code>EnableHelloWorld</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(&#123;ElementType.TYPE&#125;)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Import</span>(HelloWorldImportSelector.class)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnableHelloWorld &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>上面导入的是<code>HelloWorldImportSelector</code>，而非<code>HelloWorldConfiguration</code>。</p><p>再次运行<code>TestEnableBootstap</code>的main方法，你会发现输出是一样的。</p><h2 id="自动装配"><a href="#自动装配" class="headerlink" title="自动装配"></a>自动装配</h2><p>Spring Boot中的自动装配技术底层主要用到了下面这些技术:</p><ol><li><p>Spring 模式注解装配</p></li><li><p>Spring @Enable 模块装配</p></li><li><p>Spring 条件装配装（<a href="/Spring-Bean-Regist.html">深入学习Spring组件注册</a>中有介绍）</p></li><li><p>Spring 工厂加载机制</p></li></ol><p>Spring 工厂加载机制的实现类为<code>SpringFactoriesLoader</code>，查看其源码：</p><p><img src="img/QQ截图20190221110551.png" alt="QQ截图20190221110551.png"></p><p>该类的方法会读取META-INF目录下的spring.factories配置文件，我们查看spring-boot-autoconfigure-2.1.0.RELEASE.jar下的该文件：</p><p><img src="img/QQ截图20190221110753.png" alt="QQ截图20190221110753.png"></p><p><img src="img/QQ截图20190221110907.png" alt="QQ截图20190221110907.png"></p><p>当启动类被<code>@EnableAutoConfiguration</code>标注后，上面截图中的所有类Spring都会去扫描，看是否可以纳入到IOC容器中进行管理。</p><p>比如我们查看<code>org.springframework.boot.autoconfigure.data.redis.RedisAutoConfiguration</code>的源码：</p><p><img src="img/QQ截图20190221111400.png" alt="QQ截图20190221111400.png"></p><p>可看到该类上标注了一些注解，其中<code>@Configuration</code>为模式注解，<code>@EnableConfigurationProperties</code>为模块装配技术，<code>ConditionalOnClass</code>为条件装配技术。这和我们上面列出的Spring Boot自动装配底层主要技术一致，所以我们可以根据这个思路来自定义一个自动装配实现。</p><p>新建一个配置类<code>HelloWorldAutoConfiguration</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableHelloWorld</span></span><br><span class="line"><span class="meta">@ConditionalOnProperty</span>(name = <span class="string">"helloworld"</span>, havingValue = <span class="string">"true"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorldAutoConfiguration</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>然后在resources目录下新建META-INF目录，并创建spring.factories文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># Auto Configure</span><br><span class="line">org.springframework.boot.autoconfigure.EnableAutoConfiguration=\</span><br><span class="line">com.example.demo.configuration.HelloWorldAutoConfiguration</span><br></pre></td></tr></table></figure><p>接着在配置文件application.properties中添加<code>helloworld=true</code>配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">helloworld=true</span><br></pre></td></tr></table></figure><p></p><p>最后创建<code>EnableAutoConfigurationBootstrap</code>，测试下<code>HelloWorldAutoConfiguration</code>是否生效：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableAutoConfiguration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EnableAutoConfigurationBootstrap</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ConfigurableApplicationContext context = <span class="keyword">new</span> SpringApplicationBuilder(EnableAutoConfigurationBootstrap.class)</span><br><span class="line">                .web(WebApplicationType.NONE)</span><br><span class="line">                .run(args);</span><br><span class="line">        String hello = context.getBean(<span class="string">"hello"</span>, String.class);</span><br><span class="line">        System.out.println(<span class="string">"hello Bean: "</span> + hello);</span><br><span class="line">        context.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>运行该main方法，控制台输出如下：</p><p><img src="img/QQ截图20190221112922.png" alt="QQ截图20190221112922.png"></p><p>说明我们自定义的自动装配已经成功了。</p><p>下面简要分析下代码的运行逻辑：</p><ol><li><p>Spring 的工厂加载机制会自动读取META-INF目录下spring.factories文件内容；</p></li><li><p>我们在spring.factories定义了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">org.springframework.boot.autoconfigure.EnableAutoConfiguration=\</span><br><span class="line">com.example.demo.configuration.HelloWorldAutoConfiguration</span><br></pre></td></tr></table></figure><p>我们在测试类上使用了<code>@EnableAutoConfiguration</code>注解标注，那么<code>HelloWorldAutoConfiguration</code>就会被Spring扫描，看是否符合要求，如果符合则纳入到IOC容器中；</p></li><li><p><code>HelloWorldAutoConfiguration</code>上的<code>@ConditionalOnProperty</code>的注解作用为：当配置文件中配置了<code>helloworld=true</code>（我们确实添加了这个配置，所以符合要求）则这个类符合扫描规则；<code>@EnableHelloWorld</code>注解是我们前面例子中自定义的模块驱动注解，其引入了hello这个Bean，所以IOC容器中便会存在hello这个Bean了；</p></li><li><p>通过上面的步骤，我们就可以通过上下文获取到hello这个Bean了。</p></li></ol><blockquote><p>源码链接： <a href="https://github.com/wuyouzhuguli/SpringAll/tree/master/44.Spring-Boot-Autoconfiguration" target="_blank" rel="noopener">https://github.com/wuyouzhuguli/SpringAll/tree/master/44.Spring-Boot-Autoconfiguration</a></p></blockquote><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Thu Mar 21 2019 09:22:43 GMT+0800 (GMT+08:00) --&gt;&lt;h2 id=&quot;模式注解&quot;&gt;&lt;a href=&quot;#模式注解&quot; class=&quot;headerlink&quot; title=&quot;模式注解&quot;&gt;&lt;/a&gt;模式注解&lt;/h2&gt;&lt;p&gt;Stereotype Annotation俗称为模式注解，Spring中常见的模式注解有&lt;code&gt;@Service&lt;/code&gt;，&lt;code&gt;@Repository&lt;/code&gt;，&lt;code&gt;@Controller&lt;/code&gt;等，它们都“派生”自&lt;code&gt;@Component&lt;/code&gt;注解。我们都知道，凡是被&lt;code&gt;@Component&lt;/code&gt;标注的类都会被Spring扫描并纳入到IOC容器中，那么由&lt;code&gt;@Component&lt;/code&gt;派生的注解所标注的类也会被扫描到IOC容器中。下面我们主要来通过自定义模式注解来了解&lt;code&gt;@Component&lt;/code&gt;的“派生性”和“层次性”。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Spring" scheme="http://mrbird.cc/tags/Spring/"/>
    
      <category term="Spring Boot" scheme="http://mrbird.cc/tags/Spring-Boot/"/>
    
  </entry>
  
  <entry>
    <title>深入学习Spring Bean生命周期</title>
    <link href="http://mrbird.cc/Spring-Bean-Lifecycle.html"/>
    <id>http://mrbird.cc/Spring-Bean-Lifecycle.html</id>
    <published>2018-08-05T03:02:35.000Z</published>
    <updated>2019-03-13T10:51:44.159Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Mar 21 2019 09:22:41 GMT+0800 (GMT+08:00) --><p>所谓Spring Bean的生命周期指的是Bean从创建到初始化再到销毁的过程，这个过程由IOC容器管理。一个完整的Bean生命周期可以参考<a href="http://localhost:4001/Spring-Bean%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.html" target="_blank" rel="noopener">Spring Bean生命周期</a>。这里我们主要记录一些和Bean生命周期相关的细节。</p><h2 id="Bean的初始化和销毁"><a href="#Bean的初始化和销毁" class="headerlink" title="Bean的初始化和销毁"></a>Bean的初始化和销毁</h2><p>在整个生命周期过程中，我们可以自定义Bean的初始化和销毁钩子函数，当Bean的生命周期到达相应的阶段的时候，Spring会调用我们自定义的Bean的初始化和销毁方法。自定义Bean初始化和销毁方法有多种方式，下面逐一介绍。</p><a id="more"></a><h3 id="Bean"><a href="#Bean" class="headerlink" title="@Bean"></a>@Bean</h3><p>上一节中介绍了可以在配置类中通过<code>@Bean</code>注解来注册Bean，我们也可以通过它来指定Bean的初始化和方法。</p><p>为了演示，我们新建一个Spring Boot项目，然后创建一个<code>User</code>类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"调用无参构造器创建User"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"初始化User"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"销毁User"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>然后在配置类里注册该组件，并指定初始化和销毁方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span>(initMethod = <span class="string">"init"</span>, destroyMethod = <span class="string">"destory"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">user</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> User();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>其中<code>initMethod = &quot;init&quot;</code>和<code>destroyMethod = &quot;destory&quot;</code>与User类里的<code>init</code>，<code>destory</code>方法相对应。</p><p>在Spring Boot入口类中测试:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回 IOC 容器，使用注解配置，传入配置类</span></span><br><span class="line">AnnotationConfigApplicationContext context = <span class="keyword">new</span> AnnotationConfigApplicationContext(WebConfig.class);</span><br><span class="line">User user = context.getBean(User.class);</span><br><span class="line"><span class="comment">// 关闭 IOC 容器</span></span><br><span class="line">context.close();</span><br></pre></td></tr></table></figure><p></p><p>启动项目，观察控制台输出:</p><p><img src="img/QQ截图20190130142237.png" alt="QQ截图20190130142237.png"></p><p>从上面的输出我们看出在容器启动之前，先调用对象的无参构造器创建对象，然后调用初始化方法，在容器关闭的时候调用销毁方法。</p><p>上面的情况是对于单例而言的，如果组件是多例模式又是什么情况呢？我们把上面的组件注册配置改为多例，然后再次启动项目，观察控制台输出:</p><p><img src="img/QQ截图20190130142740.png" alt="QQ截图20190130142740.png"></p><p>控制台的输出和我们上节讨论的一致，即在多例模式下，IOC容器启动的时候并不会去创建对象，而是在每次获取的时候才会去调用方法创建对象，创建完对象后再调用初始化方法。但在容器关闭后，Spring并没有调用相应的销毁方法，这是因为在多例模式下，容器不会管理这个组件（只负责在你需要的时候创建这个组件），所以容器在关闭的时候并不会调用相应的销毁方法。</p><h3 id="InitializingBean-amp-DisposableBean"><a href="#InitializingBean-amp-DisposableBean" class="headerlink" title="InitializingBean&amp;DisposableBean"></a>InitializingBean&amp;DisposableBean</h3><p>除了上面这种方式指定初始化和销毁方法外，Spring还为我们提供了和初始化，销毁相对应的接口：</p><ul><li><p><code>InitializingBean</code>接口包含一个<code>afterPropertiesSet</code>方法，我们可以通过实现该接口，然后在这个方法中编写初始化逻辑。</p></li><li><p><code>DisposableBean</code>接口包含一个<code>destory</code>方法，我们可以通过实现该接口，然后再这个方法中编写销毁逻辑。</p></li></ul><p>新建一个类，名称为<code>Bird</code>，然后实现这两个接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Bird</span> <span class="keyword">implements</span> <span class="title">InitializingBean</span>, <span class="title">DisposableBean</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Bird</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"调用无参构造器创建Bird"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"销毁Bird"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterPropertiesSet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"初始化Bird"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在配置类中注册这个组件:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Bird <span class="title">bird</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Bird();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>测试一波：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">AnnotationConfigApplicationContext context = <span class="keyword">new</span> AnnotationConfigApplicationContext(WebConfig.class);</span><br><span class="line">System.out.println(<span class="string">"容器创建完毕"</span>);</span><br><span class="line">context.close();</span><br></pre></td></tr></table></figure><p></p><p>启动项目，观察控制台输出:</p><p><img src="img/QQ截图20190130145406.png" alt="QQ截图20190130145406.png"></p><h3 id="PostConstruct-amp-PreDestroy"><a href="#PostConstruct-amp-PreDestroy" class="headerlink" title="@PostConstruct&amp;@PreDestroy"></a>@PostConstruct&amp;@PreDestroy</h3><p>除了上面两种指定初始化和销毁方法的方式外，我们还可以使用<code>@PostConstruct</code>和<code>@PreDestroy</code>注解修饰方法来指定相应的初始化和销毁方法。</p><p>新建一个类，名称为Fish：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Fish</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Fish</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"调用无参构造器创建Fish"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"初始化Fish"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PreDestroy</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"销毁Fish"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>在配置类中注册这个组件:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Fish <span class="title">fish</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Fish();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>测试一波：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">AnnotationConfigApplicationContext context = <span class="keyword">new</span> AnnotationConfigApplicationContext(WebConfig.class);</span><br><span class="line">System.out.println(<span class="string">"容器创建完毕"</span>);</span><br><span class="line">context.close();</span><br></pre></td></tr></table></figure><p></p><p>启动项目，观察控制台输出:</p><p><img src="img/QQ截图20190130150534.png" alt="QQ截图20190130150534.png"></p><p>效果和上面两种方式一致。</p><div class="note info"><p>这两个注解并非Spring提供，而是JSR250规范提供。</p></div><h2 id="BeanPostProcessor"><a href="#BeanPostProcessor" class="headerlink" title="BeanPostProcessor"></a>BeanPostProcessor</h2><p>Spring提供了一个<code>BeanPostProcessor</code>接口，俗称<strong>Bean后置通知处理器</strong>，它提供了两个方法<code>postProcessBeforeInitialization</code>和<code>postProcessAfterInitialization</code>。其中<code>postProcessBeforeInitialization</code>在组件的初始化方法调用之前执行，<code>postProcessAfterInitialization</code>在组件的初始化方法调用之后执行。它们都包含两个入参：</p><ol><li><p>bean：当前组件对象；</p></li><li><p>beanName：当前组件在容器中的名称。</p></li></ol><p>两个方法都返回一个Object类型，我们可以直接返回当前组件对象，或者包装后返回。</p><p>我们来定义一个<code>BeanPostProcessor</code>接口的实现类<code>MyBeanPostProcessor</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBeanPostProcessor</span> <span class="keyword">implements</span> <span class="title">BeanPostProcessor</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">postProcessBeforeInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        System.out.println(beanName + <span class="string">" 初始化之前调用"</span>);</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">postProcessAfterInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        System.out.println(beanName + <span class="string">" 初始化之后调用"</span>);</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>在配置类中注册该组件:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> MyBeanPostProcessor <span class="title">myBeanPostProcessor</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> MyBeanPostProcessor();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>再次启动项目，观察控制台输出:</p><p><img src="img/QQ截图20190130153607.png" alt="QQ截图20190130153607.png"></p><p><img src="img/QQ截图20190130153450.png" alt="QQ截图20190130153450.png"></p><p>可以看到，BeanPostProcessor对IOC容器中所有组件都生效。</p><blockquote><p>源码链接：<a href="https://github.com/wuyouzhuguli/SpringAll/tree/master/51.Spring-Bean-Lifecycle" target="_blank" rel="noopener">https://github.com/wuyouzhuguli/SpringAll/tree/master/51.Spring-Bean-Lifecycle</a></p></blockquote><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Thu Mar 21 2019 09:22:41 GMT+0800 (GMT+08:00) --&gt;&lt;p&gt;所谓Spring Bean的生命周期指的是Bean从创建到初始化再到销毁的过程，这个过程由IOC容器管理。一个完整的Bean生命周期可以参考&lt;a href=&quot;http://localhost:4001/Spring-Bean%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Spring Bean生命周期&lt;/a&gt;。这里我们主要记录一些和Bean生命周期相关的细节。&lt;/p&gt;&lt;h2 id=&quot;Bean的初始化和销毁&quot;&gt;&lt;a href=&quot;#Bean的初始化和销毁&quot; class=&quot;headerlink&quot; title=&quot;Bean的初始化和销毁&quot;&gt;&lt;/a&gt;Bean的初始化和销毁&lt;/h2&gt;&lt;p&gt;在整个生命周期过程中，我们可以自定义Bean的初始化和销毁钩子函数，当Bean的生命周期到达相应的阶段的时候，Spring会调用我们自定义的Bean的初始化和销毁方法。自定义Bean初始化和销毁方法有多种方式，下面逐一介绍。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Spring" scheme="http://mrbird.cc/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>深入学习Spring组件注册</title>
    <link href="http://mrbird.cc/Spring-Bean-Regist.html"/>
    <id>http://mrbird.cc/Spring-Bean-Regist.html</id>
    <published>2018-08-01T06:36:09.000Z</published>
    <updated>2019-03-13T10:51:24.357Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Mar 21 2019 09:22:44 GMT+0800 (GMT+08:00) --><p>接触过Spring的同学肯定都听过IOC。在传统的Java编程中，当需要用到某个对象的时候，我们都是主动地显示创建一个对象实例（new）。使用Spring后就不需要这样做了，因为Spring会帮我们在需要用到某些对象的地方自动注入该对象，而无须我们自己去创建。这种模式俗称控制反转，即IOC（Inversion of Control）。那么Spring是从什么地方获取到我们所需要的对象呢？其实Spring给我们提供了一个IOC容器，里面管理着所有我们需要的对象，组件注册就是我们去告诉Spring哪些类需要交给IOC容器管理。</p><p>这里主要记录组件注册的一些细节。<a id="more"></a></p><h2 id="通过-Bean注册组件"><a href="#通过-Bean注册组件" class="headerlink" title="通过@Bean注册组件"></a>通过@Bean注册组件</h2><p>在较早版本的Spring中，我们都是通过XML的方式来往IOC容器中注册组件的，下面这段代码大家肯定不会陌生：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回 IOC 容器，基于 XML配置，传入配置文件的位置</span></span><br><span class="line">ApplicationContext applicationContext = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"xxx.xml"</span>);</span><br><span class="line">User user = (User) applicationContext.getBean(<span class="string">"user"</span>);</span><br></pre></td></tr></table></figure><p></p><p>Spring 4后推荐我们使用Java Config的方式来注册组件。</p><p>为了演示，我们通过<a href="http://start.spring.io/" target="_blank" rel="noopener">http://start.spring.io/</a>搭建一个简单Spring Boot应用，然后引入Lombok依赖（编辑器也需要安装Lombok插件）：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p></p><p>然后创建一个User类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ToString</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>接着创建一个配置类，在里面通过<code>@Bean</code>注解注册User类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span>()</span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">user</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> User(<span class="string">"mrbird"</span>, <span class="number">18</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>通过<code>@Bean</code>注解，我们向IOC容器注册了一个名称为<code>user</code>（Bean名称默认为方法名，我们也可以通过<code>@Bean(&quot;myUser&quot;)</code>方式来将组件名称指定为<code>myUser</code>）。</p><p>组件注册完毕后，我们测试一下从IOC容器中获取这个组件。在Spring Boot入口类中编写如下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoApplication</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    	SpringApplication.run(DemoApplication.class, args);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 返回 IOC 容器，使用注解配置，传入配置类</span></span><br><span class="line">        ApplicationContext context = <span class="keyword">new</span> AnnotationConfigApplicationContext(WebConfig.class);</span><br><span class="line">        User user = context.getBean(User.class);</span><br><span class="line">        System.out.println(user);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>因为我们是通过注解方式来注册组件的，所以需要使用<code>AnnotationConfigApplicationContext</code>来获取相应的IOC容器，入参为配置类。</p><p>启动项目，看下控制台输出：</p><p><img src="img/QQ截图20181207155127.png" alt="QQ截图20181207155127.png"></p><p>说明组件注册成功。</p><p>我们将组件的名称改为<code>myUser</code>，然后看看IOC容器中，User类型组件是否叫<code>myUser</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoApplication</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(DemoApplication.class, args);</span><br><span class="line"></span><br><span class="line">        ApplicationContext context = <span class="keyword">new</span> AnnotationConfigApplicationContext(WebConfig.class);</span><br><span class="line">        <span class="comment">// 查看 User 这个类在 Spring 容器中叫啥玩意</span></span><br><span class="line">        String[] beanNames = context.getBeanNamesForType(User.class);</span><br><span class="line">        Arrays.stream(beanNames).forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>启动项目，观察控制台输出:</p><p><img src="img/QQ截图20181207155718.png" alt="QQ截图20181207155718.png"></p><h2 id="使用-ComponentScan扫描"><a href="#使用-ComponentScan扫描" class="headerlink" title="使用@ComponentScan扫描"></a>使用@ComponentScan扫描</h2><p>在使用XML配置组件扫描的时候，我们都是这样配置的：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">""</span>&gt;</span><span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br></pre></td></tr></table></figure><p></p><p>其中<code>base-package</code>指定了扫描的路径。路径下所有被<code>@Controller</code>、<code>@Service</code>、<code>@Repository</code>和<code>@Component</code>注解标注的类都会被纳入IOC容器中。</p><p>现在我们脱离XML配置后，可以使用<code>@ComponentScan</code>注解来扫描组件并注册。</p><p>在使用<code>@ComponentScan</code>扫描之前，我们先创建一个Controller，一个Service，一个Dao，并标注上相应的注解。</p><p>然后修改配置类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan</span>(<span class="string">"cc.mrbird.demo"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// @Bean("myUser")</span></span><br><span class="line">    <span class="comment">// public User user() &#123;</span></span><br><span class="line">    <span class="comment">//     return new User("mrbird", 18);</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>在配置类中，我们通过<code>@ComponentScan(&quot;cc.mrbird.demo&quot;)</code>配置了扫描路径，并且将User组件注册注释掉了，取而代之的是在User类上加上<code>@Component</code>注解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ToString</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><div class="note danger"><p>值得注意的是，我们不能将Spring Boot的入口类纳入扫描范围中，否则项目启动将出错。</p></div><p>接下来我们看下在基于注解的IOC容器中是否包含了这些组件：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoApplication</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(DemoApplication.class, args);</span><br><span class="line"></span><br><span class="line">        ApplicationContext context = <span class="keyword">new</span> AnnotationConfigApplicationContext(WebConfig.class);</span><br><span class="line">        <span class="comment">// 查看基于注解的 IOC容器中所有组件名称</span></span><br><span class="line">        String[] beanNames = context.getBeanDefinitionNames();</span><br><span class="line">        Arrays.stream(beanNames).forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>启动项目，观察控制台：</p><p><img src="img/QQ截图20181207164418.png" alt="QQ截图20181207164418.png"></p><p>可见，组件已经成功被扫描进去了，并且名称默认为类名首字母小写。</p><p>这里，配置类WebConfig也被扫描并注册了，查看<code>@Configuration</code>源码就会发现原因：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(ElementType.TYPE)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Configuration &#123;</span><br><span class="line">    <span class="function">String <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h3 id="指定扫描策略"><a href="#指定扫描策略" class="headerlink" title="指定扫描策略"></a>指定扫描策略</h3><p><code>@ComponentScan</code>注解允许我们指定扫描策略，即指定哪些被扫描，哪些不被扫描，查看其源码可发现这两个属性：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Specifies which types are eligible for component scanning.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Further narrows the set of candidate components from everything in &#123;<span class="doctag">@link</span> #basePackages&#125;</span></span><br><span class="line"><span class="comment"> * to everything in the base packages that matches the given filter or filters.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Note that these filters will be applied in addition to the default filters, if specified.</span></span><br><span class="line"><span class="comment"> * Any type under the specified base packages which matches a given filter will be included,</span></span><br><span class="line"><span class="comment"> * even if it does not match the default filters (i.e. is not annotated with &#123;<span class="doctag">@code</span> <span class="doctag">@Component</span>&#125;).</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #resourcePattern()</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #useDefaultFilters()</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">Filter[] includeFilters() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Specifies which types are not eligible for component scanning.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #resourcePattern</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">Filter[] excludeFilters() <span class="keyword">default</span> &#123;&#125;;</span><br></pre></td></tr></table></figure><p></p><p>其中<code>Filter</code>也是一个注解:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Declares the type filter to be used as an &#123;<span class="doctag">@linkplain</span> ComponentScan#includeFilters</span></span><br><span class="line"><span class="comment"> * include filter&#125; or &#123;<span class="doctag">@linkplain</span> ComponentScan#excludeFilters exclude filter&#125;.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Target</span>(&#123;&#125;)</span><br><span class="line"><span class="meta">@interface</span> Filter &#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">FilterType <span class="title">type</span><span class="params">()</span> <span class="keyword">default</span> FilterType.ANNOTATION</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@AliasFor</span>(<span class="string">"classes"</span>)</span><br><span class="line">    Class&lt;?&gt;[] value() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@AliasFor</span>(<span class="string">"value"</span>)</span><br><span class="line">    Class&lt;?&gt;[] classes() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">    String[] pattern() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>接下来我们使用<code>excludeFilters</code>来排除一些组件的扫描：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan</span>(value = <span class="string">"cc.mrbird.demo"</span>,</span><br><span class="line">        excludeFilters = &#123;</span><br><span class="line">                <span class="meta">@Filter</span>(type = FilterType.ANNOTATION,</span><br><span class="line">                        classes = &#123;Controller.class, Repository.class&#125;),</span><br><span class="line">                <span class="meta">@Filter</span>(type = FilterType.ASSIGNABLE_TYPE, classes = User.class)</span><br><span class="line">        &#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>上面我们指定了两种排除扫描的规则：</p><ol><li><p>根据注解来排除（<code>type = FilterType.ANNOTATION</code>）,这些注解的类型为<code>classes = {Controller.class, Repository.class}</code>。即<code>Controller</code>和<code>Repository</code>注解标注的类不再被纳入到IOC容器中。</p></li><li><p>根据指定类型类排除（<code>type = FilterType.ASSIGNABLE_TYPE</code>），排除类型为<code>User.class</code>，其子类，实现类都会被排除。</p></li></ol><p>启动项目，观察控制台：</p><p><img src="img/QQ截图20190129103606.png" alt="QQ截图20190129095439.png"></p><p>可见排除成功。</p><p>除了上面两种常用的规则外，我们还可以使用别的规则，查看<code>FilterType</code>源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> FilterType &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Filter candidates marked with a given annotation.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> org.springframework.core.type.filter.AnnotationTypeFilter</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    ANNOTATION,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Filter candidates assignable to a given type.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> org.springframework.core.type.filter.AssignableTypeFilter</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    ASSIGNABLE_TYPE,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Filter candidates matching a given AspectJ type pattern expression.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> org.springframework.core.type.filter.AspectJTypeFilter</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    ASPECTJ,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Filter candidates matching a given regex pattern.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> org.springframework.core.type.filter.RegexPatternTypeFilter</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    REGEX,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Filter candidates using a given custom</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@link</span> org.springframework.core.type.filter.TypeFilter&#125; implementation.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    CUSTOM</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>可看到，我们还可以通过<code>ASPECTJ</code>表达式，<code>REGEX</code>正则表达式和<code>CUSTOM</code>自定义规则（下面详细介绍）来指定扫描策略。</p><p><code>includeFilters</code>的作用和<code>excludeFilters</code>相反，其指定的是哪些组件需要被扫描：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan</span>(value = <span class="string">"cc.mrbird.demo"</span>,</span><br><span class="line">        includeFilters = &#123;</span><br><span class="line">                <span class="meta">@Filter</span>(type = FilterType.ANNOTATION, classes = Service.class)</span><br><span class="line">        &#125;, useDefaultFilters = <span class="keyword">false</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>上面配置了只将<code>Controller</code>纳入IOC容器，并且需要用<code>useDefaultFilters = false</code>来关闭Spring默认的扫描策略才能让我们的配置生效（Spring Boot入口类的<code>@SpringBootApplication</code>注解包含了一些默认的扫描策略）。</p><p>启动项目，观察控制台：</p><p><img src="img/QQ截图20190129100306.png" alt="QQ截图20190129100306.png"></p><p>可看到，IOC容器中将不再包含dao，service。</p><h3 id="多扫描策略配置"><a href="#多扫描策略配置" class="headerlink" title="多扫描策略配置"></a>多扫描策略配置</h3><p>在Java 8之前，我们可以使用<code>@ComponentScans</code>来配置多个<code>@ComponentScan</code>以实现多扫描规则配置：</p><p><img src="img/QQ截图20190129100809.png" alt="QQ截图20190129100809.png"></p><p>而在Java 8中，新增了<code>@Repeatable</code>注解，使用该注解修饰的注解可以重复使用，查看<code>@ComponentScan</code>源码会发现其已经被该注解标注：</p><p><img src="img/QQ截图20190129101050.png" alt="QQ截图20190129101050.png"></p><p>所以除了使用<code>@ComponentScans</code>来配置多扫描规则外，我们还可以通过多次使用<code>@ComponentScan</code>来指定多个不同的扫描规则。</p><h3 id="自定义扫描策略"><a href="#自定义扫描策略" class="headerlink" title="自定义扫描策略"></a>自定义扫描策略</h3><p>自定义扫描策略需要我们实现<code>org.springframework.core.type.filter.TypeFilter</code>接口，创建<code>MyTypeFilter</code>实现该接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTypeFilter</span> <span class="keyword">implements</span> <span class="title">TypeFilter</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">match</span><span class="params">(MetadataReader metadataReader, MetadataReaderFactory metadataReaderFactory)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>该接口包含<code>match</code>方法，其两个入参<code>MetadataReader</code>和<code>MetadataReaderFactory</code>含义如下：</p><ol><li><p><code>MetadataReader</code>：当前正在扫描的类的信息；</p></li><li><p><code>MetadataReaderFactory</code>：可以通过它来获取其他类的信息。</p></li></ol><p>当<code>match</code>方法返回true时说明匹配成功，false则说明匹配失败。继续完善这个过滤规则：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTypeFilter</span> <span class="keyword">implements</span> <span class="title">TypeFilter</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">match</span><span class="params">(MetadataReader metadataReader, MetadataReaderFactory metadataReaderFactory)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 获取当前正在扫描的类的注解信息</span></span><br><span class="line">        AnnotationMetadata annotationMetadata = metadataReader.getAnnotationMetadata();</span><br><span class="line">        <span class="comment">// 获取当前正在扫描的类的类信息</span></span><br><span class="line">        ClassMetadata classMetadata = metadataReader.getClassMetadata();</span><br><span class="line">        <span class="comment">// 获取当前正在扫描的类的路径等信息</span></span><br><span class="line">        Resource resource = metadataReader.getResource();</span><br><span class="line"></span><br><span class="line">        String className = classMetadata.getClassName();</span><br><span class="line">        <span class="keyword">return</span> StringUtils.hasText(<span class="string">"er"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>上面指定了当被扫描的类名包含<code>er</code>时候，匹配成功，配合<code>excludeFilters</code>使用意指当被扫描的类名包含<code>er</code>时，该类不被纳入IOC容器中。</p><p>我们在<code>@ComponentScan</code>中使用这个自定义的过滤策略：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan</span>(value = <span class="string">"cc.mrbird.demo"</span>,</span><br><span class="line">        excludeFilters = &#123;</span><br><span class="line">            <span class="meta">@Filter</span>(type = FilterType.CUSTOM, classes = MyTypeFilter.class)</span><br><span class="line">        &#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebConfig</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>启动项目，观察输出： <img src="img/QQ截图20190129112811.png" alt="QQ截图20190129112811.png"></p><p>因为<code>User</code>，<code>UserMapper</code>，<code>UserService</code>和<code>UserController</code>等类的类名都包含<code>er</code>，所以它们都没有被纳入到IOC容器中。</p><h2 id="组件作用域-Scope"><a href="#组件作用域-Scope" class="headerlink" title="组件作用域@Scope"></a>组件作用域@Scope</h2><p>默认情况下，在Spring的IOC容器中每个组件都是单例的，即无论在任何地方注入多少次，这些对象都是同一个，我们来看下例子。</p><p>首先将User对象中的<code>@Component</code>注解去除，然后在配置类中配置User Bean：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">user</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> User(<span class="string">"mrbird"</span>, <span class="number">18</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>接着多次从IOC容器中获取这个组件，看看是否为同一个：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回 IOC 容器，使用注解配置，传入配置类</span></span><br><span class="line">ApplicationContext context = <span class="keyword">new</span> AnnotationConfigApplicationContext(WebConfig.class);</span><br><span class="line">Object user1 = context.getBean(<span class="string">"user"</span>);</span><br><span class="line">Object user2 = context.getBean(<span class="string">"user"</span>);</span><br><span class="line">System.out.println(user1 == user2);</span><br></pre></td></tr></table></figure><p></p><p>启动项目，观察控制台输出:</p><p><img src="img/QQ截图20190129135637.png" alt="QQ截图20190129135637.png"></p><p>结果证实了上面的观点。</p><p>在Spring中我们可以使用<code>@Scope</code>注解来改变组件的作用域：</p><p><img src="img/QQ截图20190129140150.png" alt="QQ截图20190129140150.png"></p><ol><li><p><code>singleton</code>：单实例（默认）,在Spring IOC容器启动的时候会调用方法创建对象然后纳入到IOC容器中，以后每次获取都是直接从IOC容器中获取（<code>map.get()</code>）；</p></li><li><p><code>prototype</code>：多实例，IOC容器启动的时候并不会去创建对象，而是在每次获取的时候才会去调用方法创建对象；</p></li><li><p><code>request</code>：一个请求对应一个实例；</p></li><li><p><code>session</code>：同一个session对应一个实例。</p></li></ol><h2 id="懒加载-Lazy"><a href="#懒加载-Lazy" class="headerlink" title="懒加载@Lazy"></a>懒加载@Lazy</h2><p>懒加载是针对单例模式而言的，正如前面所说，IOC容器中的组件默认是单例的，容器启动的时候会调用方法创建对象然后纳入到IOC容器中。</p><p>在User Bean注册的地方加入一句话以观察：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">user</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"往IOC容器中注册user bean"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> User(<span class="string">"mrbird"</span>, <span class="number">18</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>测试：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ApplicationContext context = <span class="keyword">new</span> AnnotationConfigApplicationContext(WebConfig.class);</span><br><span class="line">System.out.println(<span class="string">"容器创建完毕"</span>);</span><br></pre></td></tr></table></figure><p></p><p>启动项目观察控制台输出:</p><p><img src="img/QQ截图20190129144509.png" alt="QQ截图20190129144509.png"></p><p>可以看到，在IOC容器创建完毕之前，组件已经添加到容器中了。</p><p>将User Bean改为懒加载的方式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@Lazy</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">user</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"往IOC容器中注册user bean"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> User(<span class="string">"mrbird"</span>, <span class="number">18</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>再次启动项目，观察输出：</p><p><img src="img/QQ截图20190129144804.png" alt="QQ截图20190129144804.png"></p><p>可看到，容器创建完的时候，User Bean这个组件并未添加到容器中。</p><div class="note info"><p>所以懒加载的功能是，在单例模式中，IOC容器创建的时候不会马上去调用方法创建对象并注册，只有当组件<strong>第一次</strong>被使用的时候才会调用方法创建对象并加入到容器中。</p></div><p>测试一下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ApplicationContext context = <span class="keyword">new</span> AnnotationConfigApplicationContext(WebConfig.class);</span><br><span class="line">System.out.println(<span class="string">"容器创建完毕"</span>);</span><br><span class="line">Object user1 = context.getBean(<span class="string">"user"</span>);</span><br><span class="line">Object user2 = context.getBean(<span class="string">"user"</span>);</span><br></pre></td></tr></table></figure><p></p><p>启动项目，观察输出:</p><p><img src="img/QQ截图20190129145157.png" alt="QQ截图20190129145157.png"></p><p>结果证实了我们的观点。</p><h2 id="条件注册组件"><a href="#条件注册组件" class="headerlink" title="条件注册组件"></a>条件注册组件</h2><h3 id="Conditional"><a href="#Conditional" class="headerlink" title="@Conditional"></a>@Conditional</h3><p>使用<code>@Conditional</code>注解我们可以指定组件注册的条件，即满足特定条件才将组件纳入到IOC容器中。</p><p>在使用该注解之前，我们需要创建一个类，实现<code>Condition</code>接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyCondition</span> <span class="keyword">implements</span> <span class="title">Condition</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">matches</span><span class="params">(ConditionContext context, AnnotatedTypeMetadata metadata)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>该接口包含一个<code>matches</code>方法，包含两个入参:</p><ol><li><p><code>ConditionContext</code>：上下文信息；</p></li><li><p><code>AnnotatedTypeMetadata</code>：注解信息。</p></li></ol><p>简单完善一下这个实现类:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyCondition</span> <span class="keyword">implements</span> <span class="title">Condition</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">matches</span><span class="params">(ConditionContext context, AnnotatedTypeMetadata metadata)</span> </span>&#123;</span><br><span class="line">        String osName = context.getEnvironment().getProperty(<span class="string">"os.name"</span>);</span><br><span class="line">        <span class="keyword">return</span> osName != <span class="keyword">null</span> &amp;&amp; osName.contains(<span class="string">"Windows"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>接着将这个条件添加到User Bean注册的地方：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@Conditional</span>(MyCondition.class)</span><br><span class="line"><span class="function"><span class="keyword">public</span> User <span class="title">user</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> User(<span class="string">"mrbird"</span>, <span class="number">18</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>在Windows环境下，User这个组件将被成功注册，如果是别的操作系统，这个组件将不会被注册到IOC容器中。</p><h3 id="Profile"><a href="#Profile" class="headerlink" title="@Profile"></a>@Profile</h3><p><code>@Profile</code>可以根据不同的环境变量来注册不同的组件，下面我们来学一下它的用法。</p><p>新建一个接口<code>CalculateService</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CalculateService</span> </span>&#123;</span><br><span class="line">    <span class="function">Integer <span class="title">sum</span><span class="params">(Integer... value)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>接着添加两个实现<code>Java7CalculateServiceImpl</code>和<code>Java8CalculateServiceImpl</code>:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@Profile</span>(<span class="string">"java7"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Java7CalculateServiceImpl</span> <span class="keyword">implements</span> <span class="title">CalculateService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">sum</span><span class="params">(Integer... value)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Java 7环境下执行"</span>);</span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= value.length; i++) &#123;</span><br><span class="line">            result += i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@Profile</span>(<span class="string">"java8"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Java8CalculateServiceImpl</span> <span class="keyword">implements</span> <span class="title">CalculateService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">sum</span><span class="params">(Integer... value)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Java 8环境下执行"</span>);</span><br><span class="line">        <span class="keyword">return</span> Arrays.stream(value).reduce(<span class="number">0</span>, Integer::sum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过<code>@Profile</code>注解我们实现了：当环境变量包含<code>java7</code>的时候，<code>Java7CalculateServiceImpl</code>将会被注册到IOC容器中；当环境变量包含<code>java8</code>的时候，<code>Java8CalculateServiceImpl</code>将会被注册到IOC容器中。</p><p>测试一下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ConfigurableApplicationContext context1 = <span class="keyword">new</span> SpringApplicationBuilder(DemoApplication.class)</span><br><span class="line">                .web(WebApplicationType.NONE)</span><br><span class="line">                .profiles(<span class="string">"java8"</span>)</span><br><span class="line">                .run(args);</span><br><span class="line"></span><br><span class="line">CalculateService service = context1.getBean(CalculateService.class);</span><br><span class="line">System.out.println(<span class="string">"求合结果： "</span> + service.sum(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>));</span><br></pre></td></tr></table></figure><p></p><p>启动项目，控制台输出如下：</p><p><img src="img/QQ截图20190221094636.png" alt="QQ截图20190221094636.png"></p><p><img src="img/QQ截图20190221094658.png" alt="QQ截图20190221094658.png"></p><p>如果将<code>.profiles(&quot;java8&quot;)</code>改为<code>.profiles(&quot;java7&quot;)</code>的话，控制台输出如下：</p><p><img src="img/QQ截图20190221094849.png" alt="QQ截图20190221094849.png"></p><p><img src="img/QQ截图20190221094910.png" alt="QQ截图20190221094910.png"></p><h2 id="导入组件"><a href="#导入组件" class="headerlink" title="导入组件"></a>导入组件</h2><h3 id="Import"><a href="#Import" class="headerlink" title="@Import"></a>@Import</h3><p>到目前为止，我们可以使用包扫描和<code>@Bean</code>来实现组件注册。除此之外，我们还可以使用<code>@Import</code>来快速地往IOC容器中添加组件。</p><p>创建一个新的类<code>Hello</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hello</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>然后在配置类中导入这个组件：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@Import</span>(&#123;Hello.class&#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebConfig</span> </span>&#123;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>查看IOC容器中所有组件的名称：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ApplicationContext context = <span class="keyword">new</span> AnnotationConfigApplicationContext(WebConfig.class);</span><br><span class="line">String[] beanNames = context.getBeanDefinitionNames();</span><br><span class="line">Arrays.stream(beanNames).forEach(System.out::println);</span><br></pre></td></tr></table></figure><p></p><p>启动项目，控制台输出:</p><p><img src="img/QQ截图20190129185401.png" alt="QQ截图20190129185401.png"></p><p>可看到，通过<code>@Import</code>我们可以快速地往IOC容器中添加组件，Id默认为全类名。</p><h3 id="ImportSelector"><a href="#ImportSelector" class="headerlink" title="ImportSelector"></a>ImportSelector</h3><p>通过<code>@Import</code>我们已经实现了组件的导入，如果需要一次性导入较多组件，我们可以使用<code>ImportSelector</code>来实现。</p><p>新增三个类<code>Apple</code>，<code>Banana</code>和<code>Watermelon</code>，代码略。</p><p>查看<code>ImportSelector</code>源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ImportSelector</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Select and return the names of which class(es) should be imported based on</span></span><br><span class="line"><span class="comment">     * the &#123;<span class="doctag">@link</span> AnnotationMetadata&#125; of the importing @&#123;<span class="doctag">@link</span> Configuration&#125; class.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">     String[] selectImports(AnnotationMetadata importingClassMetadata);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p><code>ImportSelector</code>是一个接口，包含一个<code>selectImports</code>方法，方法返回类的全类名数组（即需要导入到IOC容器中组件的全类名数组），包含一个<code>AnnotationMetadata</code>类型入参，通过这个参数我们可以获取到使用<code>ImportSelector</code>的类的全部注解信息。</p><p>我们新建一个<code>ImportSelector</code>实现类<code>MyImportSelector</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyImportSelector</span> <span class="keyword">implements</span> <span class="title">ImportSelector</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String[] selectImports(AnnotationMetadata importingClassMetadata) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> String[]&#123;</span><br><span class="line">                <span class="string">"cc.mrbird.demo.domain.Apple"</span>,</span><br><span class="line">                <span class="string">"cc.mrbird.demo.domain.Banana"</span>,</span><br><span class="line">                <span class="string">"cc.mrbird.demo.domain.Watermelon"</span></span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>上面方法返回了新增的三个类的全类名数组，接着我们在配置类的<code>@Import</code>注解上使用<code>MyImportSelector</code>来把这三个组件快速地导入到IOC容器中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Import</span>(&#123;MyImportSelector.class&#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebConfig</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>查看容器中是否已经有这三个组件:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ApplicationContext context = <span class="keyword">new</span> AnnotationConfigApplicationContext(WebConfig.class);</span><br><span class="line">String[] beanNames = context.getBeanDefinitionNames();</span><br><span class="line">Arrays.stream(beanNames).forEach(System.out::println);</span><br></pre></td></tr></table></figure><p></p><p>启动项目，观察控制台：</p><p><img src="img/QQ截图20190130091140.png" alt="QQ截图20190130091140.png"></p><p>组件已经成功导入。</p><h3 id="ImportBeanDefinitionRegistrar"><a href="#ImportBeanDefinitionRegistrar" class="headerlink" title="ImportBeanDefinitionRegistrar"></a>ImportBeanDefinitionRegistrar</h3><p>除了上面两种往IOC容器导入组件的方法外，我们还可以使用<code>ImportBeanDefinitionRegistrar</code>来手动往IOC容器导入组件。</p><p>查看其源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ImportBeanDefinitionRegistrar</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerBeanDefinitions</span><span class="params">(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p><code>ImportBeanDefinitionRegistrar</code>是一个接口，包含一个<code>registerBeanDefinitions</code>方法，该方法包含两个入参：</p><ol><li><p><code>AnnotationMetadata</code>：可以通过它获取到类的注解信息；</p></li><li><p><code>BeanDefinitionRegistry</code>：Bean定义注册器，包含了一些和Bean有关的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BeanDefinitionRegistry</span> <span class="keyword">extends</span> <span class="title">AliasRegistry</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">registerBeanDefinition</span><span class="params">(String var1, BeanDefinition var2)</span> <span class="keyword">throws</span> BeanDefinitionStoreException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">removeBeanDefinition</span><span class="params">(String var1)</span> <span class="keyword">throws</span> NoSuchBeanDefinitionException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">BeanDefinition <span class="title">getBeanDefinition</span><span class="params">(String var1)</span> <span class="keyword">throws</span> NoSuchBeanDefinitionException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">containsBeanDefinition</span><span class="params">(String var1)</span></span>;</span><br><span class="line"></span><br><span class="line">    String[] getBeanDefinitionNames();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getBeanDefinitionCount</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isBeanNameInUse</span><span class="params">(String var1)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>这里我们需要借助<code>BeanDefinitionRegistry</code>的<code>registerBeanDefinition</code>方法来往IOC容器中注册Bean。该方法包含两个入参，第一个为需要注册的Bean名称（Id）,第二个参数为Bean的定义信息，它是一个接口，我们可以使用其实现类<code>RootBeanDefinition</code>来完成：</p><p><img src="img/QQ截图20190130094046.png" alt="QQ截图20190130094046.png"></p><p>为了演示<code>ImportBeanDefinitionRegistrar</code>的使用，我们先新增一个类，名称为<code>Strawberry</code>，代码略。</p><p>然后新增一个<code>ImportBeanDefinitionRegistrar</code>实现类<code>MyImportBeanDefinitionRegistrar</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyImportBeanDefinitionRegistrar</span> <span class="keyword">implements</span> <span class="title">ImportBeanDefinitionRegistrar</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerBeanDefinitions</span><span class="params">(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> String beanName = <span class="string">"strawberry"</span>;</span><br><span class="line">        <span class="keyword">boolean</span> contain = registry.containsBeanDefinition(beanName);</span><br><span class="line">        <span class="keyword">if</span> (!contain) &#123;</span><br><span class="line">            RootBeanDefinition rootBeanDefinition = <span class="keyword">new</span> RootBeanDefinition(Strawberry.class);</span><br><span class="line">            registry.registerBeanDefinition(beanName, rootBeanDefinition);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>在上面的实现类中，我们先通过<code>BeanDefinitionRegistry</code>的<code>containsBeanDefinition</code>方法判断IOC容器中是否包含了名称为<code>strawberry</code>的组件，如果没有，则手动通过<code>BeanDefinitionRegistry</code>的<code>registerBeanDefinition</code>方法注册一个。</p><p>定义好<code>MyImportBeanDefinitionRegistrar</code>后，我们同样地在配置类的<code>@Import</code>中使用它：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@Import</span>(&#123;MyImportBeanDefinitionRegistrar.class&#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebConfig</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>查看容器中是否已经有这个组件:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ApplicationContext context = <span class="keyword">new</span> AnnotationConfigApplicationContext(WebConfig.class);</span><br><span class="line">String[] beanNames = context.getBeanDefinitionNames();</span><br><span class="line">Arrays.stream(beanNames).forEach(System.out::println);</span><br></pre></td></tr></table></figure><p></p><p>启动项目，观察控制台：</p><p><img src="img/QQ截图20190130094912.png" alt="QQ截图20190130094912.png"></p><p>组件已经注册成功。</p><h2 id="使用FactoryBean注册组件"><a href="#使用FactoryBean注册组件" class="headerlink" title="使用FactoryBean注册组件"></a>使用FactoryBean注册组件</h2><p>Spring还提供了一个<code>FactoryBean</code>接口，我们可以通过实现该接口来注册组件，该接口包含了两个抽象方法和一个默认方法：</p><p><img src="img/QQ截图20190130103346.png" alt="QQ截图20190130103346.png"></p><p>为了演示<code>FactoryBean</code>的使用，我们新增一个<code>Cherry</code>类，代码略。</p><p>然后创建<code>FactoryBean</code>的实现类<code>CherryFactoryBean</code>:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CherryFactoryBean</span> <span class="keyword">implements</span> <span class="title">FactoryBean</span>&lt;<span class="title">Cherry</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Cherry <span class="title">getObject</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Cherry();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Class&lt;?&gt; getObjectType() &#123;</span><br><span class="line">        <span class="keyword">return</span> Cherry.class;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSingleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>getObject</code>返回需要注册的组件对象，<code>getObjectType</code>返回需要注册的组件类型，<code>isSingleton</code>指明该组件是否为单例。如果为多例的话，每次从容器中获取该组件都会调用其<code>getObject</code>方法。</p><p>定义好<code>CherryFactoryBean</code>后，我们在配置类中注册这个类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> CherryFactoryBean <span class="title">cherryFactoryBean</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> CherryFactoryBean();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>测试从容器中获取：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ApplicationContext context = <span class="keyword">new</span> AnnotationConfigApplicationContext(WebConfig.class);</span><br><span class="line">Object cherry = context.getBean(<span class="string">"cherryFactoryBean"</span>);</span><br><span class="line">System.out.println(cherry.getClass());</span><br></pre></td></tr></table></figure><p></p><p>启动项目，观察控制台输出：</p><p><img src="img/QQ截图20190130103934.png" alt="QQ截图20190130103934.png"></p><p>可看到，虽然我们获取的是Id为<code>cherryFactoryBean</code>的组件，但其获取到的实际是<code>getObject</code>方法里返回的对象。</p><p>如果我们要获取<code>cherryFactoryBean</code>本身，则可以这样做：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Object cherryFactoryBean = context.getBean(<span class="string">"&amp;cherryFactoryBean"</span>);</span><br><span class="line">System.out.println(cherryFactoryBean.getClass());</span><br></pre></td></tr></table></figure><p></p><p>启动项目，观察控制台：</p><p><img src="img/QQ截图20190130104606.png" alt="QQ截图20190130104606.png"></p><p>为什么加上<code>&amp;</code>前缀就可以获取到相应的工厂类了呢，查看<code>BeanFactory</code>的源码会发现原因:</p><p><img src="img/QQ截图20190130104715.png" alt="QQ截图20190130104715.png"></p><blockquote><p>源码链接：<a href="https://github.com/wuyouzhuguli/SpringAll/tree/master/50.Spring-Regist-Bean" target="_blank" rel="noopener">https://github.com/wuyouzhuguli/SpringAll/tree/master/50.Spring-Regist-Bean</a></p></blockquote><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Thu Mar 21 2019 09:22:44 GMT+0800 (GMT+08:00) --&gt;&lt;p&gt;接触过Spring的同学肯定都听过IOC。在传统的Java编程中，当需要用到某个对象的时候，我们都是主动地显示创建一个对象实例（new）。使用Spring后就不需要这样做了，因为Spring会帮我们在需要用到某些对象的地方自动注入该对象，而无须我们自己去创建。这种模式俗称控制反转，即IOC（Inversion of Control）。那么Spring是从什么地方获取到我们所需要的对象呢？其实Spring给我们提供了一个IOC容器，里面管理着所有我们需要的对象，组件注册就是我们去告诉Spring哪些类需要交给IOC容器管理。&lt;/p&gt;&lt;p&gt;这里主要记录组件注册的一些细节。
    
    </summary>
    
    
      <category term="Spring" scheme="http://mrbird.cc/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>Spring Boot整合Dubbo&amp;Zookeeper</title>
    <link href="http://mrbird.cc/Spring-Boot-Dubbo-Zookeeper.html"/>
    <id>http://mrbird.cc/Spring-Boot-Dubbo-Zookeeper.html</id>
    <published>2018-07-05T08:26:09.000Z</published>
    <updated>2018-11-02T07:06:55.272Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Mar 21 2019 09:22:42 GMT+0800 (GMT+08:00) --><p>Dubbo是一款由阿里巴巴开发的远程服务调用框架（RPC），其可以透明化的调用远程服务，就像调用本地服务一样简单。截至目前，Dubbo发布了基于Spring Boot构建的版本，版本号为2.0，这使得其与Spring Boot项目整合变得更为简单方便。而Zookeeper在这里充当的是服务注册中心的角色，我们将各个微服务提供的服务通过Dubbo注册到Zookeeper中，然后服务消费者通过Dubbo从Zookeeper中获取相应服务并消费。本文案例的架构图可以简单用下图表示：<a id="more"></a> <img src="img/QQ截图20181018183703.png" alt="QQ截图20181018183703.png"></p><p>本文案例最终项目结构如下图所示：</p><p><img src="img/QQ截图20181018183830.png" alt="QQ截图20181018183830.png"></p><p>项目采用Maven构建，各模块的作用：</p><table><tr><th>模块</th><th>描述</th></tr><tr><td>common-api</td><td>统一定义接口，供其余子模块引用</td></tr><tr><td>server-provider</td><td>服务提供者，实现common-api模块中的接口，然后暴露到Zookeeper中，供服务消费者使用</td></tr><tr><td>server-consumer</td><td>服务消费者，通过Dubbo从Zookeeper中获取服务并消费</td></tr></table><h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><h3 id="Zookeeper安装"><a href="#Zookeeper安装" class="headerlink" title="Zookeeper安装"></a>Zookeeper安装</h3><p>在搭建项目之前需要启动Zookeeper服务，Zookeeper下载地址：<a href="http://zookeeper.apache.org/releases.html#download" target="_blank" rel="noopener">http://zookeeper.apache.org/releases.html#download</a>。</p><p>下载后解压，将config目录下的zoo_sample.cfg重命名为zoo.cfg(Zookeeper配置文件，默认端口为2181，可根据实际进行修改)。然后双击bin目录下的zkServer.cmd启动即可。</p><h3 id="构建父模块"><a href="#构建父模块" class="headerlink" title="构建父模块"></a>构建父模块</h3><p>新建一个Maven项目，groupId为<code>cc.mrbird</code>，artifactId为<code>dubbo-boot</code>，packaging指定为pom。然后引入Spring Boot，dubbo-spring-boot-starter和Zookeeper相关依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>cc.mrbird<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>dubbo-boot<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>dubbo-boot<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">description</span>&gt;</span>Spring Boot-Dubbo-ZooKeeper<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0.4.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">relativePath</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.build.sourceEncoding</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">project.reporting.outputEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.reporting.outputEncoding</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">java.version</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">project.version</span>&gt;</span>1.0<span class="tag">&lt;/<span class="name">project.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- dubbo --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.spring.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>dubbo-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- zookeeper --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.zookeeper<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>zookeeper<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.4.8<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.101tec<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>zkclient<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.10<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-compiler-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">source</span>&gt;</span>$&#123;java.version&#125;<span class="tag">&lt;/<span class="name">source</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">target</span>&gt;</span>$&#123;java.version&#125;<span class="tag">&lt;/<span class="name">target</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">encoding</span>&gt;</span>$&#123;project.build.sourceEncoding&#125;<span class="tag">&lt;/<span class="name">encoding</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><p></p><h3 id="构建Common-api"><a href="#构建Common-api" class="headerlink" title="构建Common-api"></a>构建Common-api</h3><p>新建一个Maven模块，artifactId为<code>common-api</code>，目录结构如下所示：</p><p><img src="img/QQ截图20181018190650.png" alt="QQ截图20181018190650.png"></p><p>pom.xml：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>dubbo-boot<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>cc.mrbird<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>common-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><p></p><p>项目只包含一个HelloService接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cc.mrbird.common.api;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">HelloService</span> </span>&#123;</span><br><span class="line">    <span class="function">String <span class="title">hello</span><span class="params">(String message)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>至此我们可以开始构建服务提供者和服务消费者了。</p><h2 id="构建Server-Provider"><a href="#构建Server-Provider" class="headerlink" title="构建Server-Provider"></a>构建Server-Provider</h2><p>新建一个Maven模块，用于暴露Dubbo服务，artifactId为<code>server-provider</code>，目录结构如下所示：</p><p><img src="img/QQ截图20181019090553.png" alt="QQ截图20181019090553.png"></p><p>pom内容如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>dubbo-boot<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>cc.mrbird<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>server-provider<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>cc.mrbird<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>common-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;project.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><p></p><p>这里我们引入了common-api模块，用于后续实现相应的服务。</p><p>在Spring Boot启动类中我们加入<code>@EnableDubboConfiguration</code>注解，表示要开启dubbo功能:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.alibaba.dubbo.spring.boot.annotation.EnableDubboConfiguration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableDubboConfiguration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Applicaiton</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(Applicaiton.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>接着在applicaiton.yml中配置Dubbo：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line"><span class="attr">  port:</span> <span class="number">8080</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  dubbo:</span></span><br><span class="line"><span class="attr">    application:</span></span><br><span class="line">      <span class="comment"># 服务名称，保持唯一</span></span><br><span class="line"><span class="attr">      name:</span> <span class="string">server-provider</span></span><br><span class="line">    <span class="comment"># zookeeper地址，用于向其注册服务</span></span><br><span class="line"><span class="attr">    registry:</span></span><br><span class="line"><span class="attr">      address:</span> <span class="attr">zookeeper://127.0.0.1:2181</span></span><br><span class="line">    <span class="comment">#暴露服务方式</span></span><br><span class="line"><span class="attr">    protocol:</span></span><br><span class="line">      <span class="comment"># dubbo协议，固定写法</span></span><br><span class="line"><span class="attr">      name:</span> <span class="string">dubbo</span></span><br><span class="line">      <span class="comment"># 暴露服务端口 （默认是20880，不同的服务提供者端口不能重复）</span></span><br><span class="line"><span class="attr">      port:</span> <span class="number">20880</span></span><br><span class="line">    <span class="comment"># 表示服务提供者，即服务暴露方</span></span><br><span class="line"><span class="attr">    server:</span> <span class="literal">true</span></span><br><span class="line">    <span class="comment"># 扫描需要暴露服务的类路径</span></span><br><span class="line"><span class="attr">    scan:</span> <span class="string">cc.mrbird.provider.service</span></span><br></pre></td></tr></table></figure><p></p><p>如果Zookeeper是集群的话，<code>spring.dubbo.registry.address</code>配置为：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  dubbo:</span></span><br><span class="line"><span class="attr">    registry:</span></span><br><span class="line"><span class="attr">      address:</span> <span class="attr">zookeeper://127.0.0.1:2181?backup=127.0.0.1:2180,127.0.0.1:2182</span></span><br></pre></td></tr></table></figure><p></p><p>接下来我们在<code>cc.mrbird.provider.service</code>路径下创建一个<code>HelloService</code>接口的实现类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cc.mrbird.common.api.HelloService;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.dubbo.config.annotation.Service;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span>(interfaceClass = HelloService.class)</span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloServiceImpl</span> <span class="keyword">implements</span> <span class="title">HelloService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"hello,"</span> + message;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>值得注意的是<code>@Service</code>注解为Dubbo提供的<code>com.alibaba.dubbo.config.annotation.Service</code>，而非Spring的那个。其中<code>interfaceClass</code>是指要发布服务的接口。</p><p>通过上面的配置，我们已经将<code>HelloService</code>接口的实现暴露到Zookeeper中了，接下来我们继续创建一个服务消费者，来消费这个服务。</p><h2 id="搭建Server-Consumer"><a href="#搭建Server-Consumer" class="headerlink" title="搭建Server-Consumer"></a>搭建Server-Consumer</h2><p>新建一个Maven模块，用于消费Dubbo服务，artifactId为<code>server-consumer</code>，目录结构如下所示：</p><p><img src="img/QQ截图20181019163027.png" alt="QQ截图20181019163027.png"></p><p>pom内容如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>dubbo-boot<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>cc.mrbird<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>server-consumer<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>cc.mrbird<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>common-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;project.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><p></p><p>同样的，我们也在Spring Boot启动类中我们加入<code>@EnableDubboConfiguration</code>注解，表示要开启dubbo功能。</p><p>接着在applicaiton.yml中配置Dubbo：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line"><span class="attr">  port:</span> <span class="number">8081</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  dubbo:</span></span><br><span class="line"><span class="attr">    application:</span></span><br><span class="line">      <span class="comment"># 服务名称，保持唯一</span></span><br><span class="line"><span class="attr">      name:</span> <span class="string">server-consumer</span></span><br><span class="line">      <span class="comment"># zookeeper地址，用于向其注册服务</span></span><br><span class="line"><span class="attr">    registry:</span></span><br><span class="line"><span class="attr">      address:</span> <span class="attr">zookeeper://127.0.0.1:2181</span></span><br><span class="line"><span class="attr">    protocol:</span></span><br><span class="line">      <span class="comment"># dubbo协议，固定写法</span></span><br><span class="line"><span class="attr">      name:</span> <span class="string">dubbo</span></span><br><span class="line">    <span class="comment"># 扫描需要调用服务的类路径</span></span><br><span class="line"><span class="attr">    scan:</span> <span class="string">cc.mrbird.consumer.controller</span></span><br></pre></td></tr></table></figure><p></p><p>同服务提供者，我们需要指定Zookeeper的地址，协议为dubbo，服务消费的扫描路径。不同于服务提供者的地方在于，服务消费者不需要指定Dubbo端口，并且<code>spring.dubbo.server</code>为false（默认配置就是false）。</p><p>接着我们定义一个<code>TestController</code>，演示服务消费：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cc.mrbird.common.api.HelloService;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.dubbo.config.annotation.Reference;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.PathVariable;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Reference</span></span><br><span class="line">    <span class="keyword">private</span> HelloService helloService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/hello/&#123;message&#125;"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">(@PathVariable String message)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.helloService.hello(message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>通过Dubbo的<code>@Reference</code>注解注入需要使用的interface，类似于Spring的<code>@Autowired</code>。</p><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>分别启动Server-Provider和Server-Consumer，访问<a href="http://localhost:8081/hello/mrbird" target="_blank" rel="noopener">http://localhost:8081/hello/mrbird</a>：</p><p><img src="img/QQ截图20181019164239.png" alt="QQ截图20181019164239.png"></p><p>说明远程服务调用已经成功。</p><p>源码链接：<a href="https://github.com/wuyouzhuguli/SpringAll/tree/master/40.Spring-Boot-Dubbo-Zookeeper" target="_blank" rel="noopener">https://github.com/wuyouzhuguli/SpringAll/tree/master/40.Spring-Boot-Dubbo-Zookeeper</a></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Thu Mar 21 2019 09:22:42 GMT+0800 (GMT+08:00) --&gt;&lt;p&gt;Dubbo是一款由阿里巴巴开发的远程服务调用框架（RPC），其可以透明化的调用远程服务，就像调用本地服务一样简单。截至目前，Dubbo发布了基于Spring Boot构建的版本，版本号为2.0，这使得其与Spring Boot项目整合变得更为简单方便。而Zookeeper在这里充当的是服务注册中心的角色，我们将各个微服务提供的服务通过Dubbo注册到Zookeeper中，然后服务消费者通过Dubbo从Zookeeper中获取相应服务并消费。本文案例的架构图可以简单用下图表示：
    
    </summary>
    
    
      <category term="Spring" scheme="http://mrbird.cc/tags/Spring/"/>
    
      <category term="Spring Boot" scheme="http://mrbird.cc/tags/Spring-Boot/"/>
    
      <category term="Dubbo" scheme="http://mrbird.cc/tags/Dubbo/"/>
    
      <category term="Zookeeper" scheme="http://mrbird.cc/tags/Zookeeper/"/>
    
  </entry>
  
  <entry>
    <title>使用WireMock快速伪造RESTful服务</title>
    <link href="http://mrbird.cc/WireMock-mock-RESTful.html"/>
    <id>http://mrbird.cc/WireMock-mock-RESTful.html</id>
    <published>2018-07-03T13:31:40.000Z</published>
    <updated>2018-07-05T01:08:10.721Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Mar 21 2019 09:22:41 GMT+0800 (GMT+08:00) --><p>前后端分离的开发模式已经越来越流行，但是前后端的开发进度并不能完全保持一致，当前端需要调用后端尚未开发的RESTful接口时不得不等待后端开发完毕，这将影响并行开发的效率。<a href="http://wiremock.org" target="_blank" rel="noopener">http://wiremock.org</a>就是一款用于解决这个问题的开源框架。WireMock可以快速的伪造RESTful接口并返回伪造的JSON数据。这里简单记录下WireMock的使用方法。<a id="more"></a></p><h2 id="搭建WireMock服务器"><a href="#搭建WireMock服务器" class="headerlink" title="搭建WireMock服务器"></a>搭建WireMock服务器</h2><p>我们在本地搭建一个WireMock服务器。通过<a href="http://repo1.maven.org/maven2/com/github/tomakehurst/wiremock-standalone/2.18.0/wiremock-standalone-2.18.0.jar" target="_blank" rel="noopener">http://repo1.maven.org/maven2/com/github/tomakehurst/wiremock-standalone/2.18.0/wiremock-standalone-2.18.0.jar</a>下载<code>wiremock-standalone-x.xx.xx.jar</code>，然后使用<code>java -jar</code>命令运行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar wiremock-standalone-2.18.0.jar --port=8080</span><br></pre></td></tr></table></figure><p></p><p>启动界面： <img src="img/QQ截图20180704165259.png" alt="QQ截图20180704165259.png"></p><h2 id="WireMock的简单使用"><a href="#WireMock的简单使用" class="headerlink" title="WireMock的简单使用"></a>WireMock的简单使用</h2><p>为了方便，我们在Spring Boot环境里进行编写。</p><p>在项目中引入WireMock依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.github.tomakehurst<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>wiremock<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.18.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p></p><p>新建一个MockServer类，包含main方法，并引入<code>com.github.tomakehurst.wiremock.client.WireMock</code>的所有静态方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> com.github.tomakehurst.wiremock.client.WireMock.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MockService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 配置WireMock服务器的地址 http://localhost:8080</span></span><br><span class="line">        configureFor(<span class="string">"127.0.0.1"</span>, <span class="number">8080</span>);</span><br><span class="line">        <span class="comment">// 清除WireMock服务器里之前的配置</span></span><br><span class="line">        removeAllMappings();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//伪造一个get请求，请求地址为 /user/1，然后返回体包含JSON数据，状态为200</span></span><br><span class="line">        stubFor(get(urlEqualTo(<span class="string">"/user/1"</span>))</span><br><span class="line">                .willReturn(aResponse()</span><br><span class="line">                        .withBody(<span class="string">"&#123;\"name\":\"mrbird\",\"url\":\"https://mrbird.cc\",\"age\":18&#125;"</span>)</span><br><span class="line">                        .withStatus(<span class="number">200</span>)));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>上面代码主要分为三个步骤：</p><ol><li><p>使用<code>configureFor</code>方法配置WireMock服务器的地址为<code>http://localhost:8080</code>；</p></li><li><p>调用<code>removeAllMappings</code>清除WireMock服务器里所有配置；</p></li><li><p>调用<code>stubFor</code>打桩，并模拟了一个HTTP GET请求，然后返回200状态码，返回报文头部包含JSON信息。这里URL使用方法<code>urlEqualTo</code>全匹配，WireMock也提供了正则表达式匹配URL的方法。</p></li></ol><p>在配置完了后运行main方法，就可以将我们的配置写到WireMock服务器里，这时候在浏览器中调用<a href="http://localhost:8080/user/1" target="_blank" rel="noopener">http://localhost:8080/user/1</a>便能看到我们模拟的输出结果：</p><p><img src="img/QQ截图20180705085004.png" alt="QQ截图20180705085004.png"></p><p>这里推荐个在线JSON编辑器：<a href="https://www.bejson.com/jsoneditoronline/" target="_blank" rel="noopener">https://www.bejson.com/jsoneditoronline/</a>。</p><h2 id="简单封装"><a href="#简单封装" class="headerlink" title="简单封装"></a>简单封装</h2><p>我们可以对上面的代码进行简单的封装，方便重用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.commons.io.FileUtils;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.lang3.StringUtils;</span><br><span class="line"><span class="keyword">import</span> org.springframework.core.io.ClassPathResource;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">getMock</span><span class="params">(String url, String file)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    ClassPathResource resource = <span class="keyword">new</span> ClassPathResource(<span class="string">"mock/response/"</span> + file);</span><br><span class="line">    String content = StringUtils.join(FileUtils.readLines(resource.getFile(), <span class="string">"UTF-8"</span>).toArray(), <span class="string">"\n"</span>);</span><br><span class="line">    stubFor(get(urlPathEqualTo(url)).willReturn(aResponse().withBody(content).withStatus(<span class="number">200</span>)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>上面代码封装了一个<code>getMock</code>方法，用于处理<code>get</code>类型的Mock，参数为模拟URL和模拟JSON文件。</p><p>我们在<code>src/main/resource/mock/response</code>目录下创建一个user.json文件：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"name"</span>: <span class="string">"mrbird"</span>,</span><br><span class="line">  <span class="attr">"url"</span>: <span class="string">"https://mrbird.cc"</span>,</span><br><span class="line">  <span class="attr">"age"</span>: <span class="number">18</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>后面我们只需要像下面这样调用就行了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">getMock(<span class="string">"/user/1"</span>, <span class="string">"user.json"</span>);</span><br></pre></td></tr></table></figure><p></p><p>WireMock还提供了许多别的功能，具体可以参考官方文档 <a href="http://wiremock.org/docs/" target="_blank" rel="noopener">http://wiremock.org/docs/</a>。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Thu Mar 21 2019 09:22:41 GMT+0800 (GMT+08:00) --&gt;&lt;p&gt;前后端分离的开发模式已经越来越流行，但是前后端的开发进度并不能完全保持一致，当前端需要调用后端尚未开发的RESTful接口时不得不等待后端开发完毕，这将影响并行开发的效率。&lt;a href=&quot;http://wiremock.org&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://wiremock.org&lt;/a&gt;就是一款用于解决这个问题的开源框架。WireMock可以快速的伪造RESTful接口并返回伪造的JSON数据。这里简单记录下WireMock的使用方法。
    
    </summary>
    
    
      <category term="WireMock" scheme="http://mrbird.cc/tags/WireMock/"/>
    
  </entry>
  
  <entry>
    <title>使用Spring Cloud Sleuth跟踪微服务</title>
    <link href="http://mrbird.cc/Spring-Cloud-sleuth.html"/>
    <id>http://mrbird.cc/Spring-Cloud-sleuth.html</id>
    <published>2018-06-25T07:43:11.000Z</published>
    <updated>2018-12-06T09:24:55.036Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Mar 21 2019 09:22:42 GMT+0800 (GMT+08:00) --><p>在微服务数量较多的系统架构中，一个完整的HTTP请求可能需要经过好几个微服务。如果想要跟踪一条完整的HTTP请求链路所产生的日志，我们需要到各个微服务上去查看日志并检索出我们需要的信息。随着业务发展，微服务的数量也会越来越多，这个过程也变得愈发困难。不过不用担心，<a href="https://github.com/spring-cloud/spring-cloud-sleuth" target="_blank" rel="noopener">Spring Cloud Sleuth</a>为我们提供了分布式服务跟踪的解决方案。为了演示如何使用Spring Cloud Sleuth，我们需要构建一个小型的微服务系统。<a id="more"></a></p><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>这里我们需要创建两个微服务Server-Provider1和Server-Provider2，它们都具有一个名为hello的REST接口，Server-Provider1的hello接口依赖于Server-Provider2的hello接口。并将这两个服务注册到Eureka-Server服务注册中心集群。Eureka-Server服务注册中心集群直接使用<a href="https://mrbird.cc/Spring-Cloud-Eureka.html">https://mrbird.cc/Spring-Cloud-Eureka.html</a>里构建的即可，这里不再赘述。</p><h3 id="创建Server-Provider1"><a href="#创建Server-Provider1" class="headerlink" title="创建Server-Provider1"></a>创建Server-Provider1</h3><p>新建一个Spring Boot工程，<code>artifactId</code>为Server-Provider1，并引入如下依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>Edgware.SR3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-eureka<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-ribbon<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-sleuth<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><p></p><p><code>spring-cloud-starter-eureka</code>用于注册微服务，<code>spring-cloud-starter-ribbon</code>用于调用Server-Provider2提供的服务，<code>spring-cloud-starter-sleuth</code>为Spring Cloud Sleuth依赖，用于跟踪微服务请求。</p><p>接着在配置文件application.yml里添加如下配置:</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  application:</span></span><br><span class="line"><span class="attr">    name:</span> <span class="string">server-provider1</span></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line"><span class="attr">  port:</span> <span class="number">9000</span></span><br><span class="line"></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line"><span class="attr">  client:</span></span><br><span class="line"><span class="attr">    serviceUrl:</span></span><br><span class="line"><span class="attr">      defaultZone:</span> <span class="attr">http://mrbird:123456@peer1:8080/eureka/,http://mrbird:123456@peer2:8081/eureka/</span></span><br></pre></td></tr></table></figure><p></p><p>配置中指定了微服务名称为<code>server-provider1</code>，端口号为9000以及服务注册中心地址。</p><p>然后我们在入口类中添加<code>@EnableDiscoveryClient</code>注解，开启服务的注册与发现。并且注册<code>RestTemplate</code>，用于Ribbon服务远程调用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableDiscoveryClient</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@LoadBalanced</span></span><br><span class="line">    <span class="function">RestTemplate <span class="title">restTemplate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> RestTemplate();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(DemoApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>最后编写REST接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"hello"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Logger logger = LoggerFactory.getLogger(<span class="keyword">this</span>.getClass());</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RestTemplate restTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        logger.info(<span class="string">"调用server-provider1的hello接口"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.restTemplate.getForEntity(<span class="string">"http://server-provider2/hello"</span>, String.class).getBody();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>在hello接口中，我们通过<code>RestTemplate</code>远程调用了server-provider2的hello接口。</p><h3 id="创建Server-Provider2"><a href="#创建Server-Provider2" class="headerlink" title="创建Server-Provider2"></a>创建Server-Provider2</h3><p>新建一个新建一个Spring Boot工程，<code>artifactId</code>为Server-Provider2，依赖和Server-Provider1相同。</p><p>在application.yml中添加如下配置：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  application:</span></span><br><span class="line"><span class="attr">    name:</span> <span class="string">server-provider2</span></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line"><span class="attr">  port:</span> <span class="number">9001</span></span><br><span class="line"></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line"><span class="attr">  client:</span></span><br><span class="line"><span class="attr">    serviceUrl:</span></span><br><span class="line"><span class="attr">      defaultZone:</span> <span class="attr">http://mrbird:123456@peer1:8080/eureka/,http://mrbird:123456@peer2:8081/eureka/</span></span><br></pre></td></tr></table></figure><p></p><p>在入口类中添加<code>@EnableDiscoveryClient</code>注解，开启服务注册与发现。</p><p>最后编写一个REST接口，供Server-Provider1调用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"hello"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Logger logger = LoggerFactory.getLogger(<span class="keyword">this</span>.getClass());</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        logger.info(<span class="string">"调用server-provider2的hello接口"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"hello world"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>至此，Server-Provider2也搭建完了。</p><h2 id="测试Spring-Cloud-Sleuth"><a href="#测试Spring-Cloud-Sleuth" class="headerlink" title="测试Spring Cloud Sleuth"></a>测试Spring Cloud Sleuth</h2><p>启动8080和8081Eureka-Server集群，然后分别启动Server-Provider1和Server-Provider2。访问<a href="http://localhost:8080/" target="_blank" rel="noopener">http://localhost:8080/</a>查看服务是否都启动成功：</p><p><img src="img/QQ截图20181206101026.png" alt="QQ截图20181206101026.png"></p><p>可见服务都启动成功了，我们往Server-provider1发送<a href="http://localhost:9000/hello" target="_blank" rel="noopener">http://localhost:9000/hello</a>请求，</p><p><img src="img/QQ截图20181206101223.png" alt="QQ截图20181206101223.png"></p><p>然后观察各自的日志：</p><p>Server-Provider1：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2018-06-25 10:13:40.921  INFO [server-provider1,939ca3c1d060ed40,939ca3c1d060ed40,false] 12516 --- [nio-9000-exec-6] c.e.demo.controller.HelloController      : 调用server-provider1的hello接口</span><br></pre></td></tr></table></figure><p></p><p>Server-Provider2：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2018-06-25 10:13:40.931  INFO [server-provider2,939ca3c1d060ed40,3f31114e88154074,false] 6500 --- [nio-9001-exec-3] c.e.demo.controller.HelloController      : 调用server-provider2的hello接口</span><br></pre></td></tr></table></figure><p></p><p>可以看到，日志里出现了<code>[server-provider2,939ca3c1d060ed40,3f31114e88154074,false]</code>信息，这些信息由Spring Cloud Sleuth生成，用于跟踪微服务请求链路。这些信息包含了4个部分的值，它们的含义如下：</p><ol><li><p><code>server-provider2</code>微服务的名称，与<code>spring.application.name</code>对应；</p></li><li><p><code>939ca3c1d060ed40</code>称为<strong>Trace ID</strong>，在一条完整的请求链路中，这个值是固定的。观察上面的日志即可证实这一点；</p></li><li><p><code>3f31114e88154074</code>称为<strong>Span ID</strong>，它表示一个基本的工作单元；</p></li><li><p><code>false</code>表示是否要将该信息输出到Zipkin等服务中来收集和展示，这里我们还没有集成Zipkin，所以为false。</p></li></ol><h2 id="集成Zipkin"><a href="#集成Zipkin" class="headerlink" title="集成Zipkin"></a>集成Zipkin</h2><p>虽然我们已经可以通过<strong>Trace ID</strong>来跟踪整体请求链路了，但是我们还是得去各个系统中捞取日志。在并发较高得时候，日志是海量的，这个时候我们可以借助Zipkin来代替我们完成日志获取与分析。<a href="https://github.com/openzipkin/zipkin" target="_blank" rel="noopener">Zipkin</a>是Twitter的一个开源项目，主要包含了以下四个组件：</p><ol><li><p><strong>Collector</strong>：收集器，负责收集日志信息，以供后续的存储，分析与展示；</p></li><li><p><strong>Storage</strong>：存储模块，我们可以通过它将日志存储到MySQL中；</p></li><li><p><strong>RESTful API</strong>：API组件，它主要用来提供外部访问接口。 比如给客户端展示跟踪信息，或是外接系统访问以实现监控等；</p></li><li><p><strong>WEB UI</strong>：通过web页面，我们可以轻松的分析与跟踪请求日志。</p></li></ol><h3 id="搭建Zipkin-Server"><a href="#搭建Zipkin-Server" class="headerlink" title="搭建Zipkin-Server"></a>搭建Zipkin-Server</h3><p>在完成Spring Cloud Cleuth与Zipkin的整合之前，我们需要搭建一个Zipkin服务。</p><p>新建一个Spring Boot应用，<code>artifactId</code>为Zipkin-Server，并引入如下依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>Edgware.SR3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.zipkin.java<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>zipkin-server<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.zipkin.java<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>zipkin-autoconfigure-ui<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><p></p><p>在入口类中添加<code>@EnableZipkinServer</code>注解，用于启动Zipkin服务。</p><p>接着在applicaiton.yml中添加如下配置：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  application:</span></span><br><span class="line"><span class="attr">    name:</span> <span class="string">zipkin-server</span></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line"><span class="attr">  port:</span> <span class="number">9100</span></span><br></pre></td></tr></table></figure><p></p><p>启动项目，访问<a href="http://localhost:9100" target="_blank" rel="noopener">http://localhost:9100</a>：</p><p><img src="img/QQ截图20181206105726.png" alt="QQ截图20181206105726.png"></p><h3 id="微服务引入Zipkin"><a href="#微服务引入Zipkin" class="headerlink" title="微服务引入Zipkin"></a>微服务引入Zipkin</h3><p>接着我们需要在Server-Provider1和Server-Provider2里引入Zipkin服务。</p><p>分别在Server-Provider1和Server-Provider2里添加Zipkin相关依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-sleuth-zipkin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p></p><p>然后分别在Server-Provider1和Server-Provider2的配置文件里添加Zipkin服务地址：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  zipkin:</span></span><br><span class="line"><span class="attr">    base-url:</span> <span class="attr">http://localhost:9100</span></span><br></pre></td></tr></table></figure><p></p><p>至此，微服务改造完毕。</p><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>启动Server-Provider1和Server-Provider2，再次往Server-Provider1发送多个<a href="http://localhost:9000/hello" target="_blank" rel="noopener">http://localhost:9000/hello</a>请求，当最后一个参数为true的时候，说明该跟踪信息会输出给Zipkin Server：</p><p><img src="img/QQ截图20181206111537.png" alt="QQ截图20181206111537.png"></p><p>这时候访问<a href="http://localhost:9100" target="_blank" rel="noopener">http://localhost:9100</a>，观察Zipkin web页面：</p><p><img src="img/QQ截图20181206111728.png" alt="QQ截图20181206111728.png"></p><p>点击下方的跟踪信息，我们可以看到整个链路经过了哪些服务，总耗时等信息：</p><p><img src="img/QQ截图20181206111952.png" alt="QQ截图20181206111952.png"></p><p>点击“依赖分析”也可以看到请求里微服务的关系：</p><p><img src="img/QQ截图20181206112153.png" alt="QQ截图20181206112153.png"></p><div class="note info"><p>这里之所以要往Server-Provider1发送多个<a href="http://localhost:9000/hello" target="_blank" rel="noopener">http://localhost:9000/hello</a>请求是因为<code>spring.sleuth.sampler.percentage</code>默认值为0.1，即采样率才1/10。如果想每次请求都被采样，即每次请求跟踪信息的第四个参数都为true的话，可以将这个值设置为1。</p></div><h3 id="数据存储"><a href="#数据存储" class="headerlink" title="数据存储"></a>数据存储</h3><p>这些跟踪信息在Zipkin-Server服务重启后便会丢失，我们可以将这些信息存储到MySQL数据库中。</p><p>我们在Zipkin-Server中添加MySQL数据库驱动和JDBC依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.zipkin.java<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>zipkin-autoconfigure-storage-mysql<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-jdbc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p></p><p>然后在application.yml中添加数据库连接信息：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  datasource:</span></span><br><span class="line"><span class="attr">    url:</span> <span class="attr">jdbc:mysql://127.0.0.1:3306/zipkin?useUnicode=true&amp;characterEncoding=utf-8</span></span><br><span class="line"><span class="attr">    driver-class-name:</span> <span class="string">com.mysql.jdbc.Driver</span></span><br><span class="line"><span class="attr">    username:</span> <span class="string">root</span></span><br><span class="line"><span class="attr">    password:</span> <span class="number">123456</span></span><br><span class="line"><span class="attr">zipkin:</span></span><br><span class="line"><span class="attr">  storage:</span></span><br><span class="line"><span class="attr">    type:</span> <span class="string">mysql</span></span><br></pre></td></tr></table></figure><p></p><p>配置文件中同时通过<code>zipkin.storage.type=mysql</code>指定了Zipkin的存储方式为MySQL。</p><p>接下来创建数据库和数据库表，新建一个名为zipkin的数据库：</p><p><img src="img/QQ截图20181206134409.png" alt="QQ截图20181206134409.png"></p><p>然后导入库表，库表SQL文件在<code>io.zipkin.java:zipkin-storage-mysql:2.6.1</code>依赖里可以找到：</p><p><img src="img/QQ截图20181206134607.png" alt="QQ截图20181206134607.png"></p><p>创建完后，我们重启Zipkin-Server，发送<a href="http://localhost:9000/hello" target="_blank" rel="noopener">http://localhost:9000/hello</a>请求，然后查看数据库会发现跟踪信息已经存储在库表里了：</p><p><img src="img/QQ截图20181206135021.png" alt="QQ截图20181206135021.png"></p><h3 id="Zipkin-API"><a href="#Zipkin-API" class="headerlink" title="Zipkin API"></a>Zipkin API</h3><p>正如上面所说的，Zipkin提供了RESTful API供我们调用，在启动Zipkin-Server的时候，控制台打印日志包含如下信息：</p><p><img src="img/QQ截图20181206140049.png" alt="QQ截图20181206140049.png"></p><p>这些接口的功能如下表所示：</p><table><tr><th>接口</th><th>请求方式</th><th>描述</th></tr><tr><td>/trace/{traceIdHex}</td><td>GET</td><td>根据Trace ID获取指定跟踪信息的Span列表</td></tr><tr><td>/traces</td><td>GET</td><td>根据指定条件查询并返回符合条件的trace清单</td></tr><tr><td>/dependencies</td><td>GET</td><td>用来获取通过收集到的Span分析出的依赖关系</td></tr><tr><td>/services</td><td>GET</td><td>用来获取服务列表</td></tr><tr><td>/spans</td><td>GET</td><td>根据服务名来获取所有的Span名</td></tr></table><p>也可以参考<a href="https://zipkin.io/zipkin-api/" target="_blank" rel="noopener">https://zipkin.io/zipkin-api/</a>。</p><p>源码链接：<a href="https://github.com/wuyouzhuguli/SpringAll/tree/master/43.Spring-Cloud-Sleuth" target="_blank" rel="noopener">https://github.com/wuyouzhuguli/SpringAll/tree/master/43.Spring-Cloud-Sleuth</a>。</p><blockquote><p>参考文章 <a href="https://book.douban.com/subject/27025912/" target="_blank" rel="noopener">Spring Cloud微服务实战</a></p></blockquote><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Thu Mar 21 2019 09:22:42 GMT+0800 (GMT+08:00) --&gt;&lt;p&gt;在微服务数量较多的系统架构中，一个完整的HTTP请求可能需要经过好几个微服务。如果想要跟踪一条完整的HTTP请求链路所产生的日志，我们需要到各个微服务上去查看日志并检索出我们需要的信息。随着业务发展，微服务的数量也会越来越多，这个过程也变得愈发困难。不过不用担心，&lt;a href=&quot;https://github.com/spring-cloud/spring-cloud-sleuth&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Spring Cloud Sleuth&lt;/a&gt;为我们提供了分布式服务跟踪的解决方案。为了演示如何使用Spring Cloud Sleuth，我们需要构建一个小型的微服务系统。
    
    </summary>
    
    
      <category term="Spring" scheme="http://mrbird.cc/tags/Spring/"/>
    
      <category term="Spring Cloud" scheme="http://mrbird.cc/tags/Spring-Cloud/"/>
    
  </entry>
  
  <entry>
    <title>使用Spring Cloud Bus刷新配置</title>
    <link href="http://mrbird.cc/Spring-Cloud-Bus.html"/>
    <id>http://mrbird.cc/Spring-Cloud-Bus.html</id>
    <published>2018-06-21T06:14:00.000Z</published>
    <updated>2018-11-22T07:51:31.308Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Mar 21 2019 09:22:41 GMT+0800 (GMT+08:00) --><p>在上一节<a href="http://mrbird.cc/Spring-Cloud-Config.html">Spring Cloud Config统一配置管理</a>中，我们实现了通过往Config-Client发送<code>/refresh</code><strong>POST</strong>请求来刷新配置。不过这种方式只对单个Config-Client有效（往哪个Config-Client发送刷新请求，哪个配置就得到刷新，剩下的Config-Client获取的仍是旧的配置信息）。当Config-Client实例集群数量较多时，如果都要手动一个一个去刷新配置，不仅麻烦还容易遗漏。值得庆幸的是，我们可以借助Spring Cloud Bus来自动刷新集群的配置信息。</p><p><a href="https://github.com/spring-cloud/spring-cloud-bus" target="_blank" rel="noopener">Spring Cloud Bus</a>使用轻量级的消息代理（如RabbitMQ，Kafka）连接分布式系统的节点，可以以广播的形式将一些变更信息（如配置的变更）扩散到分布式链路中去。所以我们可以在Config-Server和Config-Client集群中加入Spring Cloud Bus，然后往某个Config-Server实例发送<code>/refresh</code>请求来刷新集群中所有实例的配置信息。</p><a id="more"></a><p>在引入Spring Cloud Bus之前，我们先来简单验证下开头的结论。我们用上一节的源码为基础，来搭建Eureka-Server、Config-Server和Config-Client的集群。</p><p>将这三个项目打成jar包后，分别使用以下命令来启动一个双节点的Eureka-Server集群：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">java -jar Eureka-Service-0.0.1-SNAPSHOT.jar --spring.profiles.active=peer1</span><br><span class="line">java -jar Eureka-Service-0.0.1-SNAPSHOT.jar --spring.profiles.active=peer2</span><br></pre></td></tr></table></figure><p></p><p>然后分别使用以下命令来启动一个双节点的Config-Server集群：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">java -jar Config-Server-0.0.1-SNAPSHOT.jar --server.port=12579</span><br><span class="line">java -jar Config-Server-0.0.1-SNAPSHOT.jar --server.port=12580</span><br></pre></td></tr></table></figure><p></p><p>最后分别使用以下命令来启动一个双节点的Config-Client集群：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">java -jar Config-Client-0.0.1-SNAPSHOT.jar --server.port=12581</span><br><span class="line">java -jar Config-Client-0.0.1-SNAPSHOT.jar --server.port=12582</span><br></pre></td></tr></table></figure><p></p><p>访问<a href="http://localhost:8080/" target="_blank" rel="noopener">http://localhost:8080/</a>查看集群节点是否都启动成功：</p><p><img src="img/QQ截图20181122091610.png" alt="QQ截图20181122091610.png"></p><p>这时候我们访问<a href="http://localhost:12581/message" target="_blank" rel="noopener">http://localhost:12581/message</a>查看message的值：</p><p><img src="img/QQ截图20181122091719.png" alt="QQ截图20181122091719.png"></p><p>接着手动修改Git仓库里的message值为<code>&#39;呵呵呵呵&#39;</code>，并往12581端口的Config-Client发送刷新请求：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; curl -u mrbird:123456 -X POST http://localhost:12581/refresh</span><br><span class="line">[&quot;config.client.version&quot;,&quot;message&quot;]</span><br></pre></td></tr></table></figure><p></p><p>再次访问<a href="http://localhost:12581/message" target="_blank" rel="noopener">http://localhost:12581/message</a>：</p><p><img src="img/QQ截图20181122091928.png" alt="QQ截图20181122091928.png"></p><p>可以看到12581端口的Config-Client获取的配置信息已经得到了更新，那12582端口的Config-Client呢？访问<a href="http://localhost:12582/message" target="_blank" rel="noopener">http://localhost:12582/message</a>看看结果：</p><p><img src="img/QQ截图20181122091943.png" alt="QQ截图20181122091943.png"></p><p>可看到，其获取的配置仍然是旧的。这也证实了我们一开始的结论。</p><h2 id="引入Spring-Cloud-Bus"><a href="#引入Spring-Cloud-Bus" class="headerlink" title="引入Spring Cloud Bus"></a>引入Spring Cloud Bus</h2><p>Spring Cloud Bus支持RabbitMQ和Kafka等消息中间件，这里只介绍配合RabbitMQ的使用方式。RabbitMQ的安装与启动可以参考<a href="https://mrbird.cc/Spring-Cloud-Hystrix-Dashboard.html">https://mrbird.cc/Spring-Cloud-Hystrix-Dashboard.html</a>中的介绍。</p><p>在Config-Server和Config-Client的pom中引入spring-cloud-starter-bus-amqp和spring-boot-starter-actuator依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-bus-amqp<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p></p><p>其中<code>spring-cloud-starter-bus-amqp</code>是Spring Cloud Bus的RabbitMQ实现，刷新用的端点由<code>spring-boot-starter-actuator</code>提供。</p><p>然后在Config-Server和Config-Client的application.yml中引入RabbitMQ的连接信息：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  rabbitmq:</span></span><br><span class="line">    <span class="comment"># RabbitMQ IP</span></span><br><span class="line"><span class="attr">    host:</span> <span class="string">localhost</span></span><br><span class="line">    <span class="comment"># RabbitMQ Port</span></span><br><span class="line"><span class="attr">    port:</span> <span class="number">5672</span></span><br><span class="line">    <span class="comment"># default RabbitMQ username</span></span><br><span class="line"><span class="attr">    username:</span> <span class="string">guest</span></span><br><span class="line">    <span class="comment"># default RabbitMQ password</span></span><br><span class="line"><span class="attr">    password:</span> <span class="string">guest</span></span><br></pre></td></tr></table></figure><p></p><p>到这里，对Config-Server和Config-Client改造就完成了，没错就是这么简单🙂。</p><p>我们重新打包Config-Server和Config-Client，然后运行以下命令启动双节点Config-Server集群：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">java -jar Config-Server-0.0.1-SNAPSHOT.jar --server.port=12579</span><br><span class="line">java -jar Config-Server-0.0.1-SNAPSHOT.jar --server.port=12580</span><br></pre></td></tr></table></figure><p></p><p>接着分别使用以下命令来启动一个双节点的Config-Client集群：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">java -jar Config-Client-0.0.1-SNAPSHOT.jar --server.port=12581</span><br><span class="line">java -jar Config-Client-0.0.1-SNAPSHOT.jar --server.port=12582</span><br></pre></td></tr></table></figure><p></p><p>启动后我们访问RabbitMQ的控制页面：<a href="http://localhost:15672" target="_blank" rel="noopener">http://localhost:15672</a>，可看到在Queues中多了四个springCloudBus队列：</p><p><img src="img/QQ截图20181122150647.png" alt="QQ图片20181122150357.jpg"></p><p>手动修改Git仓库里message的配置值为<code>&#39;spring cloud bus&#39;</code>，然后往任意一个Config-Server节点发送<code>/bus/refresh</code><strong>POST</strong>请求：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -u mrbird:123456 -X POST http://localhost:12580/bus/refresh</span><br></pre></td></tr></table></figure><p>分别访问<a href="http://localhost:12581/message" target="_blank" rel="noopener">http://localhost:12581/message</a>和<a href="http://localhost:12582/message" target="_blank" rel="noopener">http://localhost:12582/message</a>：</p><p><img src="img/QQ截图20181122151326.png" alt="QQ截图20181122151326.png"></p><p><img src="img/QQ截图20181122151345.png" alt="QQ截图20181122151345.png"></p><p>配置都已刷新成功。</p><h2 id="WebHooks"><a href="#WebHooks" class="headerlink" title="WebHooks"></a>WebHooks</h2><p>配合WebHooks可以实现自动配置刷新，在配置得到修改的时候它可以代替我们向Config-Server发送刷新请求。以码云为例，添加一个WebHooks：</p><p><img src="img/QQ截图20181122153532.png" alt="QQ截图20181122153532.png"></p><p><img src="img/QQ截图20181122154445.png" alt="QQ截图20181122154445.png"></p><p>由于这里是在本地运行测试没有公网IP，所以没法测试，这里就不演示了。</p><p>源码链接：</p><p><a href="https://github.com/wuyouzhuguli/SpringAll/tree/master/42.Spring-Cloud-Bus" target="_blank" rel="noopener">https://github.com/wuyouzhuguli/SpringAll/tree/master/42.Spring-Cloud-Bus</a></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Thu Mar 21 2019 09:22:41 GMT+0800 (GMT+08:00) --&gt;&lt;p&gt;在上一节&lt;a href=&quot;http://mrbird.cc/Spring-Cloud-Config.html&quot;&gt;Spring Cloud Config统一配置管理&lt;/a&gt;中，我们实现了通过往Config-Client发送&lt;code&gt;/refresh&lt;/code&gt;&lt;strong&gt;POST&lt;/strong&gt;请求来刷新配置。不过这种方式只对单个Config-Client有效（往哪个Config-Client发送刷新请求，哪个配置就得到刷新，剩下的Config-Client获取的仍是旧的配置信息）。当Config-Client实例集群数量较多时，如果都要手动一个一个去刷新配置，不仅麻烦还容易遗漏。值得庆幸的是，我们可以借助Spring Cloud Bus来自动刷新集群的配置信息。&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/spring-cloud/spring-cloud-bus&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Spring Cloud Bus&lt;/a&gt;使用轻量级的消息代理（如RabbitMQ，Kafka）连接分布式系统的节点，可以以广播的形式将一些变更信息（如配置的变更）扩散到分布式链路中去。所以我们可以在Config-Server和Config-Client集群中加入Spring Cloud Bus，然后往某个Config-Server实例发送&lt;code&gt;/refresh&lt;/code&gt;请求来刷新集群中所有实例的配置信息。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Spring" scheme="http://mrbird.cc/tags/Spring/"/>
    
      <category term="Spring Cloud" scheme="http://mrbird.cc/tags/Spring-Cloud/"/>
    
  </entry>
  
  <entry>
    <title>Spring Cloud Config统一配置管理</title>
    <link href="http://mrbird.cc/Spring-Cloud-Config.html"/>
    <id>http://mrbird.cc/Spring-Cloud-Config.html</id>
    <published>2018-06-15T06:05:05.000Z</published>
    <updated>2018-11-16T06:19:33.724Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Mar 21 2019 09:22:43 GMT+0800 (GMT+08:00) --><p>Spring Cloud Config可以对微服务配置进行统一的外部管理，并且默认采用Git来管理配置信息。相对于传统的每个微服务对应一份自个儿的配置文件来说，通过Spring Cloud Config统一管理所有微服务配置具有如下优点：<strong>1.</strong>集中管理微服务配置，当微服务数量众多的时候，使用这种方式会更为方便；<strong>2.</strong>通过Git管理微服务配置，方便追踪配置修改记录；<strong>3.</strong>可以在应用运行期间修改配置，微服务能够自动更新配置。</p><a id="more"></a><p>Spring Cloud Config包含了服务端Server和客户端Client。服务端用于从Git仓库中加载配置，并且缓存到本地；客户端用于从服务端获取配置信息。所以为了演示Spring Cloud Config，我们先来搭建一个服务端。</p><h2 id="搭建Config-Server"><a href="#搭建Config-Server" class="headerlink" title="搭建Config-Server"></a>搭建Config-Server</h2><p>在搭建Config-Server之前，我们需要创建好一个存储配置文件的Git仓库。这里以码云为例子，创建一个名称为Spring-Cloud-Config的参考，然后往仓库的master分支push四个配置文件：</p><p><img src="img/QQ截图20181105110354.png" alt="QQ截图20181105110354.png"></p><p>四个配置文件中分别都包含了一个<code>message</code>属性：</p><p>febs.yml:</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">message:</span> <span class="string">'default properties (master v1.0)'</span></span><br></pre></td></tr></table></figure><p></p><p>febs-dev.yml:</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">message:</span> <span class="string">'dev properties (master v1.0)'</span></span><br></pre></td></tr></table></figure><p></p><p>febs-test.yml:</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">message:</span> <span class="string">'test properties (master v1.0)'</span></span><br></pre></td></tr></table></figure><p></p><p>febs-pro.yml:</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">message:</span> <span class="string">'pro properties (master v1.0)'</span></span><br></pre></td></tr></table></figure><p></p><p>接着创建一个test分支，同样push这四个配置文件，不过配置文件中<code>message</code>属性的内容末尾都改为了<code>(test v1.0)</code>。</p><p>创建好配置文件仓库后，我们新建一个Spring Boot项目，<code>artifactId</code>为Config-Server，然后引入如下依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>Edgware.SR3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-config-server<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><p></p><p>在入口类中加入<code>@EnableConfigServer</code>注解，开启Spring Cloud Config服务端功能。</p><p>接着配置application.yml：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: config-server</span><br><span class="line">  cloud:</span><br><span class="line">    config:</span><br><span class="line">      server:</span><br><span class="line">        git:</span><br><span class="line">          uri: https://gitee.com/mrbird/spring-cloud-config</span><br><span class="line">          username: xxx</span><br><span class="line">          password: xxx</span><br><span class="line">server:</span><br><span class="line">  port: 12580</span><br></pre></td></tr></table></figure><p></p><div class="note info"><p>uri的末尾加不加<code>.git</code>都可以。</p></div><p>配置具体含义如下：</p><ol><li><p><code>spring.cloud.config.server.git.uri</code>：配置了Git仓库的地址，这里用的是码云，当然你也可以使用别的Git代码托管平台；</p></li><li><p><code>spring.cloud.config.server.git.username</code>：仓库用户名，即Git托管平台的用户名；</p></li><li><p><code>spring.cloud.config.server.git.password</code>：仓库密码，即Git托管平台的密码。</p></li></ol><p>这里服务端的端口号为12580。</p><p>启动应用，我们便可以使用下面这些格式来访问配置信息了：</p><ul><li><p><code>/{application}/{profile}[/{label}]</code></p></li><li><p><code>/{application}-{profile}.yml</code></p></li><li><p><code>/{label}/{application}-{profile}.yml</code></p></li><li><p><code>/{application}-{profile}.properties</code></p></li><li><p><code>/{label}/{application}-{profile}.properties</code></p></li></ul><p>比如当我们访问<a href="http://localhost:12580/master/febs-test" target="_blank" rel="noopener">http://localhost:12580/master/febs-test</a>时，响应信息如下所示：</p><p><img src="img/QQ截图20181105113317.png" alt="QQ截图20181105113317.png"></p><p>访问<a href="http://localhost:12580/master/febs-test.yml" target="_blank" rel="noopener">http://localhost:12580/master/febs-test.yml</a>：</p><p><img src="img/QQ截图20181105113615.png" alt="QQ截图20181105113615.png"></p><p>访问<a href="http://localhost:12580/test/febs-test.yml" target="_blank" rel="noopener">http://localhost:12580/test/febs-test.yml</a>：</p><p><img src="img/QQ截图20181105113754.png" alt="QQ截图20181105113754.png"></p><p>至此服务端搭建成功。</p><h2 id="搭建Config-Client"><a href="#搭建Config-Client" class="headerlink" title="搭建Config-Client"></a>搭建Config-Client</h2><p>新建一个Spring Boot项目，<code>artifactId</code>为Config-Client，然后引入如下依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>Edgware.SR3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-config<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><p></p><p>编写一个Controller，用于测试获取Config-Server中配置文件的<code>message</code>属性值：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;message&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String message;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"message"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getMessage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.message;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>要想让上面的代码顺利的获取到<code>message</code>属性值，我们还需要在配置文件中进行一些额外配置：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  application:</span></span><br><span class="line"><span class="attr">    name:</span> <span class="string">febs</span></span><br><span class="line"><span class="attr">  cloud:</span></span><br><span class="line"><span class="attr">    config:</span></span><br><span class="line"><span class="attr">      profile:</span> <span class="string">dev</span></span><br><span class="line"><span class="attr">      label:</span> <span class="string">test</span></span><br><span class="line"><span class="attr">      uri:</span> <span class="attr">http://localhost:12580</span></span><br><span class="line"></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line"><span class="attr">  port:</span> <span class="number">12581</span></span><br></pre></td></tr></table></figure><p></p><div class="note danger"><p>值得注意的是，这里配置文件并不是叫application.yml，而是必须命名为bootstrap.yml。</p></div><p>上面配置含义如下：</p><ol><li><p><code>spring.application.name</code>: 对应配置文件规则中的<code>{application}</code>；</p></li><li><p><code>spring.cloud.config.profile</code>: 对应配置文件规则中的<code>{profile}</code>部分；</p></li><li><p><code>spring.cloud.config.label</code>: 对应配置文件规则中的<code>{label}</code>部分；</p></li><li><p><code>spring.cloud.config.uri</code>: 对应Config-Server的地址。</p></li></ol><p>通过上面的配置，<code>message</code>的内容应该是Git仓库中test分支，febs-dev.yml中的<code>message</code>属性值。下面我们来证实一下这个推测。</p><p>启动Config-Client（Config-Server没启动的话得先启动Config-Server），访问<a href="http://localhost:12581/message" target="_blank" rel="noopener">http://localhost:12581/message</a>：</p><p><img src="img/20181105140444.png" alt="QQ截图20181105140444.png"></p><p>结果证实了我们的推测。</p><h2 id="Config-Server额外配置"><a href="#Config-Server额外配置" class="headerlink" title="Config-Server额外配置"></a>Config-Server额外配置</h2><p>上面我们简单的地搭建了一个Config-Server，下面我们来进一步了解Config-Server的可用配置。</p><h3 id="占位符的使用"><a href="#占位符的使用" class="headerlink" title="占位符的使用"></a>占位符的使用</h3><p>在Config-Server中，除了固定配置一个Git仓库地址外，我们也可以使用占位符来灵活的指定Git仓库地址。</p><p>将上面Config-Server的Git仓库地址改为：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  cloud:</span></span><br><span class="line"><span class="attr">    config:</span></span><br><span class="line"><span class="attr">      server:</span></span><br><span class="line"><span class="attr">        git:</span></span><br><span class="line"><span class="attr">          uri:</span> <span class="attr">https://gitee.com/mrbird/&#123;application&#125;</span></span><br></pre></td></tr></table></figure><p></p><p>这里使用占位符<code>{application}</code>来代替上面的spring-cloud-config，通过这种配置，我们可以让不同的Config-Client去不同的Git仓库获取配置。比如，当Config-Client的项目名称为febs的时候，对应Git仓库地址为:<code>https://gitee.com/mrbird/febs</code>，当名称为test时，对应Git仓库地址为:<code>https://gitee.com/mrbird/test</code>。这样我们就可以为不同的项目配置不同的Git仓库。</p><h3 id="子目录支持"><a href="#子目录支持" class="headerlink" title="子目录支持"></a>子目录支持</h3><p>除了使用占位符为每个项目创建单独的Git仓库来存储配置信息外，我们也可以只创建一个Git仓库来存储配置，只不过是将不同的项目配置放置到不同的目录下，只需要像下面这样配置即可：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  cloud:</span></span><br><span class="line"><span class="attr">    config:</span></span><br><span class="line"><span class="attr">      server:</span></span><br><span class="line"><span class="attr">        git:</span></span><br><span class="line"><span class="attr">          uri:</span> <span class="attr">https://gitee.com/mrbird/spring-cloud-config/</span></span><br><span class="line"><span class="attr">          username:</span> <span class="string">xxxx</span></span><br><span class="line"><span class="attr">          password:</span> <span class="string">xxxx</span></span><br><span class="line"><span class="attr">          search-paths:</span> <span class="string">'&#123;application&#125;'</span></span><br></pre></td></tr></table></figure><p></p><p>通过上面的配置，我们可以实现在<code>https://gitee.com/mrbird/spring-cloud-config/</code>仓库中，一个Config-Client对应一个配置目录的效果，即当Config-Client的项目名称为febs的时候，其搜索配置的目录为<code>https://gitee.com/mrbird/spring-cloud-config/febs</code>。</p><div class="note danger"><p>这里search-paths的占位符必须加上单引号<code>&#39;&#39;</code>，否则没办法正确读取配置，具体可参考：<a href="https://blog.csdn.net/weixin_35022258/article/details/79019033" target="_blank" rel="noopener">https://blog.csdn.net/weixin_35022258/article/details/79019033</a></p></div><h3 id="clone-on-start"><a href="#clone-on-start" class="headerlink" title="clone-on-start"></a>clone-on-start</h3><p>默认情况下Config-Server在启动的时候并不会马上就去Git参考clone配置文件，只有当Config-Clinet从Config-Server获取相关配置信息的时候，其才会去进行clone操作。我们可以将<code>clone-on-start</code>属性设置为<code>true</code>，其Config-Server在启动的时候就进行clone操作：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">spring</span></span><br><span class="line"><span class="attr">  cloud:</span></span><br><span class="line"><span class="attr">    config:</span></span><br><span class="line"><span class="attr">      server:</span></span><br><span class="line"><span class="attr">        git:</span></span><br><span class="line"><span class="attr">          clone-on-start:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><p></p><p>这样做的好处在于，当Git连接信息有误时，可以马上发现。</p><h3 id="整合Spring-Security"><a href="#整合Spring-Security" class="headerlink" title="整合Spring Security"></a>整合Spring Security</h3><p>Config-Server中包含了Git连接信息，为了使其更加安全，我们可以通过Spring Security来做用户名密码认证。</p><p>在Config-Server中加入Spring Security依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-security<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p></p><p>然后在Config-Server的配置文件application.yml中加入用户名和密码：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">security:</span></span><br><span class="line"><span class="attr">  user:</span></span><br><span class="line"><span class="attr">    name:</span> <span class="string">mrbird</span></span><br><span class="line"><span class="attr">    password:</span> <span class="number">123456</span></span><br></pre></td></tr></table></figure><p></p><p>与此同时，我们也需要在Config-Client中配置Config-Server的用户名和密码，否则在获取配置的时候将报401错误：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  cloud:</span></span><br><span class="line"><span class="attr">    config:</span></span><br><span class="line"><span class="attr">      username:</span> <span class="string">mrbird</span></span><br><span class="line"><span class="attr">      password:</span> <span class="number">123456</span></span><br></pre></td></tr></table></figure><p></p><h3 id="加密解密"><a href="#加密解密" class="headerlink" title="加密解密"></a>加密解密</h3><p>截至目前为止，Config-Server中Git仓库的密码是直接明文配置的，我们可以对这些敏感信息进行加密处理。在此之前，需要先安装JCE（Java Cryptography Extension），本文使用的是JDK 8，与之对应的JCE下载地址为：<a href="https://www.oracle.com/technetwork/java/javase/downloads/jce-all-download-5170447.html" target="_blank" rel="noopener">https://www.oracle.com/technetwork/java/javase/downloads/jce-all-download-5170447.html</a>：</p><p><img src="img/QQ截图20181115151433.png" alt="QQ截图20181115151433.png"></p><p>解压后，包含三个文件：</p><p><img src="img/QQ截图20181115151650.png" alt="QQ截图20181115151650.png"></p><p>把它们复制到<code>$JAVA HOME/jre/lib/security</code>目录下即可。</p><p><strong>对称加密</strong></p><p>使用对称加密的方式需要在Config-Server中配置加密用的密钥：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">encrypt:</span></span><br><span class="line"><span class="attr">  key:</span> <span class="string">hello</span></span><br></pre></td></tr></table></figure><p></p><p>配置好后重启Config-Server，访问<a href="http://localhost:12580/encrypt/status" target="_blank" rel="noopener">http://localhost:12580/encrypt/status</a>查看密钥是否配置成功:</p><p><img src="img/QQ截图20181115162507.png" alt="QQ截图20181115162507.png"></p><p>可见配置并未生效，查看Spring-Cloud-Config的Github issue找到了解决办法：<a href="https://github.com/spring-cloud/spring-cloud-config/issues/767" target="_blank" rel="noopener">https://github.com/spring-cloud/spring-cloud-config/issues/767</a>。</p><p>解决办法就是需要将密钥配置在bootstrap.yml中，再次访问<a href="http://localhost:12580/encrypt/status" target="_blank" rel="noopener">http://localhost:12580/encrypt/status</a>：</p><p><img src="img/QQ截图20181115163145.png" alt="QQ截图20181115163145.png"></p><p>假如我们Git仓库的密码为mrbird123，要对其加密的话我们可以使用<code>curl</code>命令来获取加密后的密码：</p><p><img src="img/QQ截图20181116091035.png" alt="QQ截图20181116091035.png"></p><p>因为Config-Server设置了用户名和密码，所以在使用<code>curl</code>命令时，需要带上<code>-u mrbird:123456</code>。</p><p>可看到mrbird123被加密成了<code>f413c4d441a7a00ef82d9aedfab087dae51772276c0201a9d9b13df3e2a9b64c</code>，</p><p>因为是对称加密，所以我们也可以将<code>f413c4d441a7a00ef82d9aedfab087dae51772276c0201a9d9b13df3e2a9b64c</code>解密：</p><p><img src="img/QQ截图20181116091227.png" alt="QQ截图20181116091227.png"></p><p>我们用加密后的密码替换掉Git连接的明文密码：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  cloud:</span></span><br><span class="line"><span class="attr">    config:</span></span><br><span class="line"><span class="attr">      server:</span></span><br><span class="line"><span class="attr">        git:</span></span><br><span class="line"><span class="attr">          password:</span> <span class="string">'&#123;cipher&#125;155315857d26a3235027679a015aa7c71a15ca43ae77e2a11ce9d122d1f4bd043d18'</span></span><br></pre></td></tr></table></figure><p></p><p>使用<code>{cipher}</code>开头表明这是一个加密的内容，Config-Server会自动为其解密。当然，你还可以为任何你想加密的属性值进行加密，不限于密码。</p><p><strong>非对称加密</strong> 非对称加密相比对称加密来说显得更加安全，要生成非对称加密的密码，需要借助<code>keytool</code>命令来生成密钥。keytool是JDK中的一个密钥和证书 管理工具。 位于<code>%JAVA_HOME%\bin\</code>目录下：</p><p><img src="img/QQ截图20181116092757.png" alt="QQ截图20181116092757.png"></p><p>我们使用如下命令来生成一个密钥文件：</p><p><img src="img/QQ截图20181116100151.png" alt="QQ截图20181116100151.png"></p><p>命令执行结束后，会在<code>%JAVA_HOME%\bin\</code>目录下生成一个 config-server.keystore文件。密钥文件的有效期默认为90天，我们可以使用<code>-validity 365</code>来改变其有效天数为365天。</p><p>接着将密钥文件拷贝到Config-Server的resources目录下，然后在bootstrap.yml中添加如下配置：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#encrypt:</span></span><br><span class="line"><span class="comment">##  key: hello</span></span><br><span class="line"></span><br><span class="line"><span class="attr">encrypt:</span></span><br><span class="line"><span class="attr">  key-store:</span></span><br><span class="line"><span class="attr">    location:</span> <span class="attr">classpath:config-server.keystore</span></span><br><span class="line"><span class="attr">    alias:</span> <span class="string">Config-Server</span></span><br><span class="line"><span class="attr">    password:</span> <span class="number">123456</span></span><br><span class="line"><span class="attr">    secret:</span> <span class="number">654321</span></span><br></pre></td></tr></table></figure><p></p><p>其中<code>encrypt.key-store.password</code>为第一次输入的口令，<code>encrypt.key-store.secret</code>为<code>&lt;Config-Server&gt;</code>的密钥口令的密钥口令。</p><p>我们将Git连接的密码改回明文，然后重启Config-Server，运行如下命令重新对Git连接密码进行加密：</p><p><img src="img/QQ截图20181116100843.png" alt="QQ截图20181116100843.png"></p><p>然后将加密后的密码替换明文密码即可：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  cloud:</span></span><br><span class="line"><span class="attr">    config:</span></span><br><span class="line"><span class="attr">      server:</span></span><br><span class="line"><span class="attr">        git:</span></span><br><span class="line"><span class="attr">          password:</span> <span class="string">'&#123;cipher&#125;AQAjzCKbjLdmgBt+Zm0/jznvbwbCAZ7j1hZKl1NtcmdEj2GFGzF02Bi5jIk9ETz92XOV3z9U5UZTEBMLblKFlZqEzFNooJAZSEmCdwDY9iI5mbhe5oGApxlhbzF4pccF9wtkt4YIW3ElQWCfg01FhDuBiDIZ8NPlMJXRDjIV+/rhla/MkdHVWaphWW3PbHlF95D7bjssCLlyeDB5BjF4orOMpVdVAT/BZA5ANy+xDbEUiOd54E9E9pYAwxG+0qW6a3PvK6OCFozVfPgvT5xorAiJ50AzIH64ZjqILSPonpk3hcIm1PlTguOE5x2BYvgxYmq/CnlkhML07yJVElVAaWh4sTIs8I5hAwQ58SvAcgq/oDE5QluF+dHvoZFn748yCe0='</span></span><br></pre></td></tr></table></figure><p></p><h2 id="Config-Client额外配置"><a href="#Config-Client额外配置" class="headerlink" title="Config-Client额外配置"></a>Config-Client额外配置</h2><h3 id="刷新配置"><a href="#刷新配置" class="headerlink" title="刷新配置"></a>刷新配置</h3><p>在Config-Server和Config-Client都启动后，如果这时候Git仓库存储的配置信息改变了，在不重启Config-Client的情况下，配置信息是不会跟着更新的。那么如何在Git仓库存储的配置得到改变的时候也刷新Config-Client中获取到的配置值呢？很简单，我们只需要对Config-Client进行简单的改造：</p><p>在Config-Client中添加<code>spring-boot-starter-actuator</code>依赖：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&lt;dependency&gt;</span></span><br><span class="line">    <span class="string">&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span></span><br><span class="line">    <span class="string">&lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;</span></span><br><span class="line"><span class="string">&lt;/dependency&gt;</span></span><br></pre></td></tr></table></figure><p></p><p>该依赖包含了<code>/refresh</code>端点，可以用来刷新配置。</p><p>然后在获取配置的Controller上加入<code>@RefreshScope</code>注解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RefreshScope</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;message&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String message;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"message"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getMessage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.message;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>值得注意的是，我们需要在Config-Client的配置文件中加入如下配置来关闭认证，否则我们无权访问<code>/refresh</code>端点，具体可见<a href="https://github.com/spring-guides/gs-centralized-configuration/issues/5" target="_blank" rel="noopener">https://github.com/spring-guides/gs-centralized-configuration/issues/5</a>：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">management:</span></span><br><span class="line"><span class="attr">  security:</span></span><br><span class="line"><span class="attr">    enabled:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure><p></p><p>重启Config-Client，访问<a href="http://localhost:12581/message" target="_blank" rel="noopener">http://localhost:12581/message</a>:</p><p><img src="img/QQ截图20181116110316.png" alt="QQ截图20181116110316.png"></p><p>这时候我们将Git仓库中对应的配置信息改为<code>测试配置刷新</code>，再次访问<a href="http://localhost:12581/message" target="_blank" rel="noopener">http://localhost:12581/message</a>会发现值还是<code>dev properties (master v1.0)</code>。</p><p>接着我们使用以下命令来刷新配置：</p><p><img src="img/QQ截图20181116110615.png" alt="QQ截图20181116110615.png"></p><p>这时候再次访问<a href="http://localhost:12581/message" target="_blank" rel="noopener">http://localhost:12581/message</a>：</p><p><img src="img/QQ截图20181116110717.png" alt="QQ截图20181116110717.png"></p><p>可看到在不重启Config-Client的前提下配置值已经得到了更新。</p><h2 id="集群配置"><a href="#集群配置" class="headerlink" title="集群配置"></a>集群配置</h2><p>如果Config-Server只是单机部署的话，当其遇到问题宕机后，所有从Config-Server获取配置信息的微服务都无法正常工作了，这是灾难性的。所以我们很有必要对Config-Server进行集群处理。</p><p>集群的方式有很多，这里介绍通过将Config-Server注册到Eureka的方式来搭建集群。</p><p>我们使用在<a href="Spring-Cloud-Eureka.html">Spring Cloud Eureka服务治理</a>一节中的Eureka-Service来构建Eureka-Server服务注册中心，使用以下命令启动Eureka-Server集群：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">java -jar Eureka-Service-0.0.1-SNAPSHOT.jar --spring.profiles.active=peer1</span><br><span class="line">java -jar Eureka-Service-0.0.1-SNAPSHOT.jar --spring.profiles.active=peer2</span><br></pre></td></tr></table></figure><p></p><p>启动后，访问<a href="http://localhost:8080/" target="_blank" rel="noopener">http://localhost:8080/</a>:</p><p><img src="img/QQ截图20181116114406.png" alt="QQ截图20181116114406.png"></p><p>说明Eureka集群启动成功。 接下来开始对Config-Server进行改造，将其注册到Eureka服务注册中心。</p><p>在Config-Server中加入Eureka依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-eureka<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p></p><p>然后在Config-Server的启动类中加入<code>@EnableDiscoveryClient</code>注解，用于将服务注册到Eureka服务注册中心上：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableConfigServer</span></span><br><span class="line"><span class="meta">@EnableDiscoveryClient</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoApplication</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(DemoApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>最后在配置类application.yml中指定Eureka服务注册中心的地址：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">eureka:</span></span><br><span class="line"><span class="attr">  client:</span></span><br><span class="line"><span class="attr">    serviceUrl:</span></span><br><span class="line"><span class="attr">      defaultZone:</span> <span class="attr">http://mrbird:123456@peer1:8080/eureka/,http://mrbird:123456@peer2:8081/eureka/</span></span><br></pre></td></tr></table></figure><p></p><p>因为之前Eureka服务注册中心添加了认证，所以需要在url中指定用户名和密码。</p><p>改造好后，启动Config-Server，再次访问Eureka服务注册中心地址：<a href="http://localhost:8080/" target="_blank" rel="noopener">http://localhost:8080/</a>：</p><p><img src="img/QQ截图20181116135751.png" alt="QQ截图20181116135751.png"></p><p>可看到Config-Server已经成功注册了。</p><p>接着开始改造Config-Client，在其pom中同样引入Eureka依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-eureka<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p></p><p>然后在bootstrap.yml中指定获取Config-Server服务的地址：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  application:</span></span><br><span class="line"><span class="attr">    name:</span> <span class="string">febs</span></span><br><span class="line"><span class="attr">  cloud:</span></span><br><span class="line"><span class="attr">    config:</span></span><br><span class="line"><span class="attr">      profile:</span> <span class="string">dev</span></span><br><span class="line"><span class="attr">      label:</span> <span class="string">master</span></span><br><span class="line"><span class="attr">      username:</span> <span class="string">mrbird</span></span><br><span class="line"><span class="attr">      password:</span> <span class="number">123456</span></span><br><span class="line"><span class="attr">      discovery:</span></span><br><span class="line"><span class="attr">        enabled:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">        service-id:</span> <span class="string">config-server</span></span><br><span class="line"></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line"><span class="attr">  client:</span></span><br><span class="line"><span class="attr">    serviceUrl:</span></span><br><span class="line"><span class="attr">      defaultZone:</span> <span class="attr">http://mrbird:123456@peer1:8080/eureka/,http://mrbird:123456@peer2:8081/eureka/</span></span><br></pre></td></tr></table></figure><p></p><p>其中<code>eureka.client.serviceUrl.defaultZone</code>指定了Eureka服务注册中心的地址；<code>spring.cloud.config.discovery.enabled</code>指定为<code>true</code>开启获取服务的功能，<code>spring.cloud.config.discovery.service-id</code>表明需要获取服务的名称为<code>config-server</code>。</p><p>最后在Config-Client的启动类中引入<code>@EnableDiscoveryClient</code>注解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableDiscoveryClient</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoApplication</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(DemoApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>启动Config-Client，访问：<a href="http://localhost:12581/message" target="_blank" rel="noopener">http://localhost:12581/message</a></p><p><img src="img/QQ截图20181116141115.png" alt="QQ截图20181116141115.png"></p><p>可看到，配置信息同样获取成功。</p><p>参考文章：</p><ol><li><p><a href="https://book.douban.com/subject/27025912/" target="_blank" rel="noopener">Spring Cloud微服务实战</a></p></li><li><p><a href="http://cloud.spring.io/spring-cloud-static/spring-cloud-config/1.4.3.RELEASE/single/spring-cloud-config.html" target="_blank" rel="noopener">http://cloud.spring.io/spring-cloud-static/spring-cloud-config/1.4.3.RELEASE/single/spring-cloud-config.html</a></p></li></ol><p>源码地址：<a href="https://github.com/wuyouzhuguli/SpringAll/tree/master/41.Spring-Cloud-Config" target="_blank" rel="noopener">https://github.com/wuyouzhuguli/SpringAll/tree/master/41.Spring-Cloud-Config</a></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Thu Mar 21 2019 09:22:43 GMT+0800 (GMT+08:00) --&gt;&lt;p&gt;Spring Cloud Config可以对微服务配置进行统一的外部管理，并且默认采用Git来管理配置信息。相对于传统的每个微服务对应一份自个儿的配置文件来说，通过Spring Cloud Config统一管理所有微服务配置具有如下优点：&lt;strong&gt;1.&lt;/strong&gt;集中管理微服务配置，当微服务数量众多的时候，使用这种方式会更为方便；&lt;strong&gt;2.&lt;/strong&gt;通过Git管理微服务配置，方便追踪配置修改记录；&lt;strong&gt;3.&lt;/strong&gt;可以在应用运行期间修改配置，微服务能够自动更新配置。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Spring" scheme="http://mrbird.cc/tags/Spring/"/>
    
      <category term="Spring Cloud" scheme="http://mrbird.cc/tags/Spring-Cloud/"/>
    
  </entry>
  
  <entry>
    <title>Spring Cloud Zuul服务网关</title>
    <link href="http://mrbird.cc/Spring-Cloud-Zuul-Router.html"/>
    <id>http://mrbird.cc/Spring-Cloud-Zuul-Router.html</id>
    <published>2018-06-14T01:00:52.000Z</published>
    <updated>2018-09-25T03:48:39.484Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Mar 21 2019 09:22:42 GMT+0800 (GMT+08:00) --><p>在微服务的架构中，服务网关就是一个介于客户端与服务端之间的中间层。在这种情况下，客户端只需要跟服务网关交互，无需调用具体的微服务接口。这样的好处在于，客户端可以降低复杂性；对于需要认证的服务，只需要在服务网关配置即可；同样也方便后期微服务的变更和重构，即微服务接口变更只需在服务网关调整配置即可，无需更改客户端代码。</p><p><a href="https://github.com/Netflix/zuul" target="_blank" rel="noopener">Zuul</a>是一款由Netflix开发的微服务网关开源软件，可以和其自家开发的Eureka，Ribbon和Hystrix配合使用，Spring Cloud对其进行了封装。</p><a id="more"></a><h2 id="Spring-Cloud-Zuul入门"><a href="#Spring-Cloud-Zuul入门" class="headerlink" title="Spring Cloud Zuul入门"></a>Spring Cloud Zuul入门</h2><p>在构建微服务网关之前，我们先将相关微服务搭建好。这里我们直接使用前面的例子，分别启动如下服务：</p><ol><li><p>启动Eureka-Server集群，端口号为8080和8081；</p></li><li><p>启动一个Eureka-Client，端口号为8082；</p></li><li><p>启动一个Feign-Consumer，端口号为9000；</p></li></ol><p>查看<a href="http://localhost:8080/" target="_blank" rel="noopener">http://localhost:8080/</a>：</p><p><img src="img/QQ截图20180725103826.png" alt="QQ截图20180725103826.png"></p><p>其中Feign-Consumer虽然之前我们将它定义为服务消费者，但其也可以充当服务提供者的角色。</p><p>启动好这些微服务后，我们开始构建一个微服务网关Zuul-Gateway。新建一个Spring Boot项目，<code>artifactId</code>为Zuul-Gateway，然后引入如下依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>Edgware.SR3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-zuul<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><p></p><p>查看依赖关系可看到spring-cloud-starter-zuul包含以下依赖：</p><p><img src="img/QQ截图20180725095018.png" alt="QQ截图20180725095018.png"></p><div class="note info"><p>因为spring-cloud-starter-zuul依赖已经包含了Hystrix和Ribbon，所以zuul支持前面介绍的Hystrix和Ribbon相关配置。</p></div><p>接着在Spring Boot的入口类上标注<code>@EnableZuulProxy</code>注解，开启Zuul服务网关的功能：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableZuulProxy</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoApplication</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(DemoApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>最后简单配置下application.yml：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  application:</span></span><br><span class="line"><span class="attr">    name:</span> <span class="string">Zuul-Gateway</span></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line"><span class="attr">  port:</span> <span class="number">12580</span></span><br></pre></td></tr></table></figure><p></p><p>至此一个简单的Zuul微服务网关就搭建好了，下面开始对路由规则进行配置。</p><h2 id="路由配置"><a href="#路由配置" class="headerlink" title="路由配置"></a>路由配置</h2><h3 id="传统配置"><a href="#传统配置" class="headerlink" title="传统配置"></a>传统配置</h3><p>传统配置就是手动指定服务的转发地址，如在yml中配置：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">zuul:</span></span><br><span class="line"><span class="attr">  routes:</span></span><br><span class="line"><span class="attr">    api-a:</span></span><br><span class="line"><span class="attr">      path:</span> <span class="string">/api-a/**</span></span><br><span class="line"><span class="attr">      url:</span> <span class="attr">http://localhost:8082</span></span><br></pre></td></tr></table></figure><p></p><p>通过上面的配置，所有符合<code>/api-a/**</code>规则的访问都将被路由转发到<code>http://localhost:8082/</code>地址上，即当我们向服务网关访问<a href="http://localhost:12580/api-a/hello" target="_blank" rel="noopener">http://localhost:12580/api-a/hello</a>请求的时候，请求将被转发到<a href="http://localhost:8082/hello" target="_blank" rel="noopener">http://localhost:8082/hello</a>服务上：</p><p><img src="img/QQ截图20180725113200.png" alt="QQ截图20180725113200.png"></p><h3 id="基于服务名称配置"><a href="#基于服务名称配置" class="headerlink" title="基于服务名称配置"></a>基于服务名称配置</h3><p>传统的配置方式不便之处在于需要知道服务的具体地址和端口号等信息，我们可以借助Eureka来实现通过服务名称配置路由。在Zuul-Gateway项目中引入Eureka依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-eureka<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p></p><p>然后在入口类中加入<code>@EnableDiscoveryClient</code>注解，使其具有获取服务的能力。</p><p>接着在yml中配置基于服务名称的路由：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">eureka:</span></span><br><span class="line"><span class="attr">  client:</span></span><br><span class="line"><span class="attr">    serviceUrl:</span></span><br><span class="line"><span class="attr">      defaultZone:</span> <span class="attr">http://mrbird:123456@peer1:8080/eureka/,http://mrbird:123456@peer2:8081/eureka/</span></span><br><span class="line"><span class="attr">zuul:</span></span><br><span class="line"><span class="attr">  routes:</span></span><br><span class="line"><span class="attr">    api-b:</span></span><br><span class="line"><span class="attr">      path:</span> <span class="string">/api-b/**</span></span><br><span class="line"><span class="attr">      serviceId:</span> <span class="string">server-provider</span></span><br><span class="line"><span class="attr">    api-c:</span></span><br><span class="line"><span class="attr">      path:</span> <span class="string">/api-c/**</span></span><br><span class="line"><span class="attr">      serviceId:</span> <span class="string">server-consumer</span></span><br></pre></td></tr></table></figure><p></p><p>上面我们首先指明了Eureka服务注册中心的地址，然后配置了<code>api-b</code>和<code>api-c</code>的路由，它们都是通过serviceId来指定服务名称的。</p><p>启动Zuul-Gateway，访问：<a href="http://localhost:12580/api-b/hello" target="_blank" rel="noopener">http://localhost:12580/api-b/hello</a>：</p><p><img src="img/QQ截图20180725140112.png" alt="QQ截图20180725140112.png"></p><p>访问：<a href="http://localhost:12580/api-c/user/1" target="_blank" rel="noopener">http://localhost:12580/api-c/user/1</a>：</p><p><img src="img/QQ截图20180725140208.png" alt="QQ截图20180725140208.png"></p><p>基于服务名称的路由配置还可以进行简化，格式为<code>zuul.routes.&lt;serviceid&gt;=&lt;path&gt;</code>，所以我们可以将<code>api-b</code>和<code>api-c</code>的路由配置修改为：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">zuul:</span></span><br><span class="line"><span class="attr">  routes:</span></span><br><span class="line"><span class="attr">    server-provider:</span></span><br><span class="line"><span class="attr">      path:</span> <span class="string">/api-b/**</span></span><br><span class="line"><span class="attr">    server-consumer:</span></span><br><span class="line"><span class="attr">      path:</span> <span class="string">/api-c/**</span></span><br></pre></td></tr></table></figure><p></p><h3 id="默认路由配置规则"><a href="#默认路由配置规则" class="headerlink" title="默认路由配置规则"></a>默认路由配置规则</h3><p>我们尝试访问<a href="http://localhost:12580/server-consumer/user/1" target="_blank" rel="noopener">http://localhost:12580/server-consumer/user/1</a>:</p><p><img src="img/QQ截图20180725142514.png" alt="QQ截图20180725142514.png"></p><p>我们压根没配置这个路由啊，为什么可以正常响应？？其实Zuul配合Eureka后将会成一套默认的配置规则。当我们使用服务名称作为请求的前缀路径时，实际上就会匹配上类似下面的默认路由配置：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">zuul:</span></span><br><span class="line"><span class="attr">  routes:</span></span><br><span class="line"><span class="attr">    server-consumer:</span></span><br><span class="line"><span class="attr">      path:</span> <span class="string">/server-consumer/**</span></span><br><span class="line"><span class="attr">      serviceId:</span> <span class="string">server-consumer</span></span><br></pre></td></tr></table></figure><p></p><p>如果不想启动这个默认配置，我们可以使用<code>zuul.ignored-services</code>配置来关闭，如在yml中加入如下配置之后，再次访问<a href="http://localhost:12580/server-consumer/user/1" target="_blank" rel="noopener">http://localhost:12580/server-consumer/user/1</a>将返回404：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">zuul:</span></span><br><span class="line"><span class="attr">  ignored-services:</span> <span class="string">server-consumer</span></span><br></pre></td></tr></table></figure><p></p><p>设置为<code>zuul.ignored-services=*</code>的时候将关闭所有默认路由配置规则。</p><h3 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h3><p>假如某个请求路径可以和多个路由配置规则相匹配的话，Zuul根据匹配的先后顺序来决定最终使用哪个路由配置。比如：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">zuul:</span></span><br><span class="line"><span class="attr">  routes:</span></span><br><span class="line"><span class="attr">    api-c:</span></span><br><span class="line"><span class="attr">      path:</span> <span class="string">/api-c/**</span></span><br><span class="line"><span class="attr">      serviceId:</span> <span class="string">server-consumer</span></span><br><span class="line"><span class="attr">    api-d:</span></span><br><span class="line"><span class="attr">      path:</span> <span class="string">/api-c/user/1</span></span><br><span class="line"><span class="attr">      serviceId:</span> <span class="string">lol</span></span><br></pre></td></tr></table></figure><p></p><p>当我们访问<a href="http://localhost:12580/api-c/user/1" target="_blank" rel="noopener">http://localhost:12580/api-c/user/1</a>的时候，<code>api-c</code>和<code>api-d</code>的路由配置都可以匹配上，但由于<code>api-c</code>先于<code>api-d</code>配置，所以最终生效的是<code>api-c</code>的配置。</p><p>假如将<code>api-c</code>和<code>api-d</code>的配置顺序调换，再次访问<a href="http://localhost:12580/api-c/user/1" target="_blank" rel="noopener">http://localhost:12580/api-c/user/1</a>时将抛出异常，原因是不存在服务名为lol的服务：</p><div class="note danger"><p>Caused by: com.netflix.client.ClientException: Load balancer does not have available server for client: lol</p></div><h3 id="前缀配置"><a href="#前缀配置" class="headerlink" title="前缀配置"></a>前缀配置</h3><p><code>zuul.prefix</code>可以为网关的请求路径加个前缀，比如：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">zuul:</span></span><br><span class="line"><span class="attr">  prefix:</span> <span class="string">/gateway</span></span><br></pre></td></tr></table></figure><p></p><p>这样配置后，我们通过Zuul网关获取服务的时候，路径也得加上这个前缀，如<code>http://localhost:12580/gateway/api-c/user/1</code>。</p><h3 id="本地跳转"><a href="#本地跳转" class="headerlink" title="本地跳转"></a>本地跳转</h3><p>Zuul网关除了支持将服务转发到各个微服务上之外，还支持将服务跳转到网关本身的服务上，比如现在yml中有如下一段配置:</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">zuul:</span></span><br><span class="line"><span class="attr">  routes:</span></span><br><span class="line"><span class="attr">    api-e:</span></span><br><span class="line"><span class="attr">      path:</span> <span class="string">/api-e/**</span></span><br><span class="line"><span class="attr">      url:</span> <span class="attr">forward:/test</span></span><br></pre></td></tr></table></figure><p></p><p>当访问<a href="http://localhost:12580/gateway/api-e/hello" target="_blank" rel="noopener">http://localhost:12580/gateway/api-e/hello</a>时，Zuul会从本地<a href="test/hello">/test/hello</a>获取服务。</p><p>我们在Zuul-Gateway入口类中加上该REST服务：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableZuulProxy</span></span><br><span class="line"><span class="meta">@EnableDiscoveryClient</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoApplication</span> </span>&#123;</span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/test/hello"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"hello zuul"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(DemoApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>效果如下所示：</p><p><img src="img/QQ截图20180725161331.png" alt="QQ截图20180725161331.png"></p><h2 id="头部过滤-amp-重定向"><a href="#头部过滤-amp-重定向" class="headerlink" title="头部过滤 &amp; 重定向"></a>头部过滤 &amp; 重定向</h2><p>在使用Zuul网关的时候你可能会遇到Cookie丢失的情况，这是因为默认情况下Zuul会过滤掉HTTP请求头中的一些敏感信息，这些敏感信息通过下面的配置设定：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">zuul:</span></span><br><span class="line"><span class="attr">  sensitive-headers:</span> <span class="string">Cookie,Set-Cookie,Authorization</span></span><br></pre></td></tr></table></figure><p></p><p>如果想关闭这个默认配置，通过设置全局参数为空来覆盖默认值：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">zuul:</span></span><br><span class="line"><span class="attr">  sensitive-headers:</span></span><br></pre></td></tr></table></figure><p></p><p>如果只想关闭某个路由的HTTP请求头过滤，可以这样：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">zuul:</span></span><br><span class="line"><span class="attr"> routes:</span></span><br><span class="line"><span class="attr">   api-a:</span></span><br><span class="line"><span class="attr">     sensitive-headers:</span></span><br></pre></td></tr></table></figure><p></p><p>使用Zuul另一个常见问题是重定向的问题，可以通过下面的设置解决：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">zuul:</span></span><br><span class="line"><span class="attr">  add-host-header:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><p></p><h2 id="过滤器"><a href="#过滤器" class="headerlink" title="过滤器"></a>过滤器</h2><p>Zuul另一个核心的功能就是请求过滤。Zuul中默认定义了4种不同生命周期的过滤器类型，在如下图所示</p><p><img src="/img/zuul.png" style="max-width:44rem"></p><div class="note info"><p>图片来自于 Zuul GitHub</p></div><p>这4种过滤器处于不同的生命周期，所以其职责也各不相同：</p><ul><li><p><strong>PRE</strong>：PRE过滤器用于将请求路径与配置的路由规则进行匹配，以找到需要转发的目标地址，并做一些前置加工，比如请求的校验等；</p></li><li><p><strong>ROUTING</strong>：ROUTING过滤器用于将外部请求转发到具体服务实例上去；</p></li><li><p><strong>POST</strong>：POST过滤器用于将微服务的响应信息返回到客户端，这个过程种可以对返回数据进行加工处理；</p></li><li><p><strong>ERROR</strong>：上述的过程发生异常后将调用ERROR过滤器。ERROR过滤器捕获到异常后需要将异常信息返回给客户端，所以最终还是会调用POST过滤器。</p></li></ul><h3 id="核心过滤器"><a href="#核心过滤器" class="headerlink" title="核心过滤器"></a>核心过滤器</h3><p>Spring Cloud Zuul为各个生命周期阶段实现了一批过滤器，如下所示：</p><p><img src="img/QQ截图20180921151818.png" alt="QQ截图20180921151818.png"></p><p>这些过滤器的优先级和作用如下表所示：</p><table><thead><tr><th>生命周期</th><th>优先级</th><th>过滤器</th><th>功能描述</th></tr></thead><tbody><tr><td>pre</td><td>-3</td><td>ServletDetectionFilter</td><td>标记处理Servlet的类型</td></tr><tr><td>pre</td><td>-2</td><td>Servlet30WrapperFilter</td><td>包装HttpServletRequest请求</td></tr><tr><td>pre</td><td>-1</td><td>FormBodyWrapperFilter</td><td>包装请求体</td></tr><tr><td>route</td><td>1</td><td>DebugFilter</td><td>标记调试标志</td></tr><tr><td>route</td><td>5</td><td>PreDecorationFilter</td><td>处理请求上下文供后续使用</td></tr><tr><td>route</td><td>10</td><td>RibbonRoutingFilter</td><td>serviceId请求转发</td></tr><tr><td>route</td><td>100</td><td>SimpleHostRoutingFilter</td><td>url请求转发</td></tr><tr><td>route</td><td>500</td><td>SendForwardFilter</td><td>forward请求转发</td></tr><tr><td>post</td><td>0</td><td>SendErrorFilter</td><td>处理有错误的请求响应</td></tr><tr><td>post</td><td>1000</td><td>SendResponseFilter</td><td>处理正常的请求响应</td></tr></tbody></table><p>其中优先级数字越小，优先级越高。</p><p>要关闭这些过滤器可以在applicaiton.yml中按照格式<code>zuul.&lt;SimpleClassName&gt;.&lt;filterType&gt;.disable=true</code>配置即可。比如关闭<code>SendResponseFilter</code>过滤器：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">zuul:</span></span><br><span class="line"><span class="attr">  SendResponseFilter:</span></span><br><span class="line"><span class="attr">    post:</span></span><br><span class="line"><span class="attr">      disable:</span></span><br><span class="line">        <span class="literal">true</span></span><br></pre></td></tr></table></figure><p></p><h3 id="自定义Zuul过滤器"><a href="#自定义Zuul过滤器" class="headerlink" title="自定义Zuul过滤器"></a>自定义Zuul过滤器</h3><p>我们自定义一个<code>PreSendForwardFilter</code>用于获取请求转发前的一些信息：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.netflix.zuul.ZuulFilter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PreSendForwardFilter</span> <span class="keyword">extends</span> <span class="title">ZuulFilter</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">filterType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">filterOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">shouldFilter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>可以看到自定义Zuul过滤器只需要继承<code>ZuulFilter</code>，然后实现以下四个抽象方法即可：</p><ol><li><p><strong>filterType</strong>：对应Zuul生命周期的四个阶段：pre、post、route和error；</p></li><li><p><strong>filterOrder</strong>：过滤器的优先级，数字越小，优先级越高；</p></li><li><p><strong>shouldFilter</strong>：方法返回boolean类型，true时表示是否执行该过滤器的<code>run</code>方法，false则表示不执行；</p></li><li><p><strong>run</strong>：过滤器的过滤逻辑。</p></li></ol><p>继续完善<code>PreSendForwardFilter</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PreSendForwardFilter</span> <span class="keyword">extends</span> <span class="title">ZuulFilter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Logger log = LoggerFactory.getLogger(<span class="keyword">this</span>.getClass());</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">filterType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"pre"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">filterOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">shouldFilter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        RequestContext requestContext = RequestContext.getCurrentContext();</span><br><span class="line">        HttpServletRequest request = requestContext.getRequest();</span><br><span class="line">        String host = request.getRemoteHost();</span><br><span class="line">        String method = request.getMethod();</span><br><span class="line">        String uri = request.getRequestURI();</span><br><span class="line">        log.info(<span class="string">"请求URI：&#123;&#125;，HTTP Method：&#123;&#125;，请求IP：&#123;&#125;"</span>, uri, method, host);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>这时候访问<a href="http://localhost:12580/api-a/hello" target="_blank" rel="noopener">http://localhost:12580/api-a/hello</a>，控制台将打印出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c.e.demo.filter.PreSendForwardFilter     : 请求URI：/api-a/hello，HTTP Method：GET，请求IP：0:0:0:0:0:0:0:1</span><br></pre></td></tr></table></figure><p></p><blockquote><p>源码链接 <a href="https://github.com/wuyouzhuguli/SpringAll/tree/master/39.Spring-Cloud-Zuul-Router" target="_blank" rel="noopener">https://github.com/wuyouzhuguli/SpringAll/tree/master/39.Spring-Cloud-Zuul-Router</a></p></blockquote><blockquote><p>参考资料： <a href="https://book.douban.com/subject/27025912/" target="_blank" rel="noopener">Spring Cloud微服务实战</a></p></blockquote><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Thu Mar 21 2019 09:22:42 GMT+0800 (GMT+08:00) --&gt;&lt;p&gt;在微服务的架构中，服务网关就是一个介于客户端与服务端之间的中间层。在这种情况下，客户端只需要跟服务网关交互，无需调用具体的微服务接口。这样的好处在于，客户端可以降低复杂性；对于需要认证的服务，只需要在服务网关配置即可；同样也方便后期微服务的变更和重构，即微服务接口变更只需在服务网关调整配置即可，无需更改客户端代码。&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/Netflix/zuul&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Zuul&lt;/a&gt;是一款由Netflix开发的微服务网关开源软件，可以和其自家开发的Eureka，Ribbon和Hystrix配合使用，Spring Cloud对其进行了封装。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Spring" scheme="http://mrbird.cc/tags/Spring/"/>
    
      <category term="Spring Cloud" scheme="http://mrbird.cc/tags/Spring-Cloud/"/>
    
      <category term="Zuul" scheme="http://mrbird.cc/tags/Zuul/"/>
    
  </entry>
  
  <entry>
    <title>Spring Cloud Feign 声明式服务调用</title>
    <link href="http://mrbird.cc/Spring-Cloud-Feign.html"/>
    <id>http://mrbird.cc/Spring-Cloud-Feign.html</id>
    <published>2018-06-10T10:35:03.000Z</published>
    <updated>2018-08-21T08:06:46.687Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Mar 21 2019 09:22:42 GMT+0800 (GMT+08:00) --><p>前面我们分别通过Spring Cloud Ribbon和Spring Cloud Hystrix实现了客户端负载均衡和服务容错，而Spring Cloud Feign不但整合了这两者的功能，而且还提供了一种比Ribbon更简单的服务调用方式 ——— 声明式服务调用。在Spring Cloud Feign中编写服务调用代码非常简单，几乎可以直接将服务提供者的代码复制过来，改为接口即可，下面通过例子来演示这个特性。<a id="more"></a></p><h2 id="搭建Feign-Consumer"><a href="#搭建Feign-Consumer" class="headerlink" title="搭建Feign Consumer"></a>搭建Feign Consumer</h2><p>创建一个新的Spring Boot应用，版本为<code>1.5.13.RELEASE</code>，<code>artifactId</code>改为<code>Feign-Consumer</code>，并引入下面这些依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>Edgware.SR3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-eureka<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-feign<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><p></p><p>除了<code>spring-cloud-starter-feign</code>依赖外，我们还引入了<code>spring-cloud-starter-eureka</code>，目的是为了从Eureka服务注册中心获取服务。</p><p>在Spring Boot的入口类中加入<code>@EnableFeignClients</code>和<code>@EnableDiscoveryClient</code>注解，用于开启Spring Cloud Feign和服务注册与发现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableDiscoveryClient</span></span><br><span class="line"><span class="meta">@EnableFeignClients</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoApplication</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(DemoApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>在前面几节中，我们曾在服务提供者Eureka-Client中定义了一个UserController，代码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"user"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Logger log = LoggerFactory.getLogger(<span class="keyword">this</span>.getClass());</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/&#123;id:\\d+&#125;"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">get</span><span class="params">(@PathVariable Long id)</span> </span>&#123;</span><br><span class="line">        log.info(<span class="string">"获取用户id为 "</span> + id + <span class="string">"的信息"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> User(id, <span class="string">"mrbird"</span>, <span class="string">"123456"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;User&gt; <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        List&lt;User&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        list.add(<span class="keyword">new</span> User(<span class="number">1L</span>, <span class="string">"mrbird"</span>, <span class="string">"123456"</span>));</span><br><span class="line">        list.add(<span class="keyword">new</span> User(<span class="number">2L</span>, <span class="string">"scott"</span>, <span class="string">"123456"</span>));</span><br><span class="line">        log.info(<span class="string">"获取用户信息 "</span> + list);</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(@RequestBody User user)</span> </span>&#123;</span><br><span class="line">        log.info(<span class="string">"新增用户成功 "</span> + user);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PutMapping</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(@RequestBody User user)</span> </span>&#123;</span><br><span class="line">        log.info(<span class="string">"更新用户成功 "</span> + user);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@DeleteMapping</span>(<span class="string">"/&#123;id:\\d+&#125;"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">(@PathVariable Long id)</span> </span>&#123;</span><br><span class="line">        log.info(<span class="string">"删除用户成功 "</span> + id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>在Spring Cloud Ribbon中访问这些服务需要通过<code>RestTemplate</code>对象来实现，并且参数绑定的过程也比较繁琐。Spring Cloud Feign对这个步骤进行了进一步的封装，在Feign Consumer中调用这些服务只需要定义一个UserService接口，然后将UserController中的代码复制过并将方法体去掉即可，如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FeignClient</span>(<span class="string">"Server-Provider"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"user/&#123;id&#125;"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">get</span><span class="params">(@PathVariable(<span class="string">"id"</span>)</span> Long id)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"user"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;User&gt; <span class="title">get</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping</span>(<span class="string">"user"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(@RequestBody User user)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PutMapping</span>(<span class="string">"user"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(@RequestBody User user)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@DeleteMapping</span>(<span class="string">"user/&#123;id&#125;"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">(@PathVariable(<span class="string">"id"</span>)</span> Long id)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>对比Feign Consumer中的UserService和Eureka-Client中UserController代码，两者是不是很相似？</p><p>在UserService中，我们通过<code>@FeignClient(&quot;Server-Provider&quot;)</code>注解来获取我们需要的服务，其中<code>Server-Provider</code>不区分大小写。需要注意的是，在定义各参数绑定时，<code>@RequestParam</code>、<code>@RequestHeader</code>等可 以指定参数名称的注解，它们的value千万不能少。在SpringMVC 程序中，这些注解会根据参数名来作为默认值，但是在Feign中绑定参数必须通过value属性来指明具体的参数名，不然会抛出<code>illegalStateException</code>异常，value 属性不能为空。</p><p>接下来我们在Feign Consumer中定义一个TestController，来调用UserService中定义的服务：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserService userService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"user/&#123;id&#125;"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">getUser</span><span class="params">(@PathVariable Long id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> userService.get(id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"user"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;User&gt; <span class="title">getUsers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> userService.get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping</span>(<span class="string">"user"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addUser</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        User user = <span class="keyword">new</span> User(<span class="number">1L</span>, <span class="string">"mrbird"</span>, <span class="string">"123456"</span>);</span><br><span class="line">        userService.add(user);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PutMapping</span>(<span class="string">"user"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateUser</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        User user = <span class="keyword">new</span> User(<span class="number">1L</span>, <span class="string">"mrbird"</span>, <span class="string">"123456"</span>);</span><br><span class="line">        userService.update(user);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@DeleteMapping</span>(<span class="string">"user/&#123;id&#125;"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteUser</span><span class="params">(@PathVariable Long id)</span> </span>&#123;</span><br><span class="line">        userService.delete(id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>最后配置一下application.yml：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line"><span class="attr">  port:</span> <span class="number">9000</span></span><br><span class="line">  </span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  application:</span></span><br><span class="line"><span class="attr">    name:</span> <span class="string">Server-Consumer</span></span><br><span class="line">    </span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line"><span class="attr">  client:</span></span><br><span class="line"><span class="attr">    serviceUrl:</span></span><br><span class="line"><span class="attr">      defaultZone:</span> <span class="attr">http://mrbird:123456@peer1:8080/eureka/,http://mrbird:123456@peer2:8081/eureka/</span></span><br></pre></td></tr></table></figure><p></p><p>上面配置指定了Eureka服务注册中心的地址，用于获取服务。</p><p>最后我们分别启动以下服务：</p><ol><li><p>启动Eureka-Server集群，端口号为8080和8081；</p></li><li><p>启动两个Eureka-Client，端口号为8082和8083；</p></li><li><p>启动Feign-Consumer，端口号为9000。</p></li></ol><p>多次访问<a href="http://localhost:9000/user/1" target="_blank" rel="noopener">http://localhost:9000/user/1</a>服务，观察8082和8083服务的控制台：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">2018-06-10 14:27:38.105  INFO 10120 --- [nio-8082-exec-8] c.e.demo.controller.UserController       : 获取用户id为 1的信息</span><br><span class="line">2018-06-10 14:27:39.989  INFO 10120 --- [nio-8082-exec-7] c.e.demo.controller.UserController       : 获取用户id为 1的信息</span><br><span class="line">2018-06-10 14:27:41.197  INFO 10120 --- [nio-8082-exec-6] c.e.demo.controller.UserController       : 获取用户id为 1的信息</span><br><span class="line">2018-06-10 14:27:41.802  INFO 10120 --- [nio-8082-exec-5] c.e.demo.controller.UserController       : 获取用户id为 1的信息</span><br><span class="line">2018-06-10 14:27:42.224  INFO 10120 --- [nio-8082-exec-4] c.e.demo.controller.UserController       : 获取用户id为 1的信息</span><br><span class="line">2018-06-10 14:27:42.865  INFO 10120 --- [nio-8082-exec-3] c.e.demo.controller.UserController       : 获取用户id为 1的信息</span><br><span class="line">2018-06-10 14:27:43.296  INFO 10120 --- [nio-8082-exec-2] c.e.demo.controller.UserController       : 获取用户id为 1的信息</span><br><span class="line"></span><br><span class="line">2018-06-10 14:27:38.358  INFO 9104 --- [nio-8083-exec-8] c.e.demo.controller.UserController       : 获取用户id为 1的信息</span><br><span class="line">2018-06-10 14:27:40.754  INFO 9104 --- [nio-8083-exec-7] c.e.demo.controller.UserController       : 获取用户id为 1的信息</span><br><span class="line">2018-06-10 14:27:41.397  INFO 9104 --- [nio-8083-exec-6] c.e.demo.controller.UserController       : 获取用户id为 1的信息</span><br><span class="line">2018-06-10 14:27:42.006  INFO 9104 --- [nio-8083-exec-5] c.e.demo.controller.UserController       : 获取用户id为 1的信息</span><br><span class="line">2018-06-10 14:27:42.445  INFO 9104 --- [nio-8083-exec-4] c.e.demo.controller.UserController       : 获取用户id为 1的信息</span><br><span class="line">2018-06-10 14:27:43.073  INFO 9104 --- [nio-8083-exec-3] c.e.demo.controller.UserController       : 获取用户id为 1的信息</span><br></pre></td></tr></table></figure><p></p><p>使用Feign实现的消费者，依然是利用Ribbon维护了针对Seriver-Provider的服务列表信息，并且通过轮询实现了客户端负载均衡。而与Ribbon不同的是，通过Feign我们只需定义服务绑定接口，以声明式的方法，优雅而简单地实现了服务调用。</p><h2 id="Ribbon相关配置"><a href="#Ribbon相关配置" class="headerlink" title="Ribbon相关配置"></a>Ribbon相关配置</h2><p>Spring Cloud Feign内部的客户端负载均衡是通过Ribbon来实现的，所以在Spring Cloud Feign中配置Ribbon，和之前在<a href="/Spring-Cloud-Ribbon-LoadBalance.html">Spring Cloud Ribbon客户端负载均衡</a>中介绍的Spring Cloud Ribbon配置一样，这里不再赘述。</p><h2 id="Hystrix相关配置"><a href="#Hystrix相关配置" class="headerlink" title="Hystrix相关配置"></a>Hystrix相关配置</h2><p>要在Spring Cloud Feign中开启Hystrix，可以在yml中添加如下配置：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">feign:</span></span><br><span class="line"><span class="attr">  hystrix:</span></span><br><span class="line"><span class="attr">    enabled:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><p></p><p>剩下的Hystrix配置和之前在<a href="/Spring-Cloud-Hystrix-Circuit-Breaker.html">Spring Cloud Hystrix服务容错</a>中介绍的Hystrix属性配置一样。</p><p>在Spring Cloud Feign中配置服务降级和在Spring Cloud Hystrix中配置服务降级区别很大，下面具体来看下怎么在Feign-Consumer中配置服务降级。</p><p>定义一个用于处理服务降级方法的类UserServiceFallback，并且实现上面定义的UserService接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceFallback</span> <span class="keyword">implements</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Logger log = LoggerFactory.getLogger(<span class="keyword">this</span>.getClass());</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">get</span><span class="params">(Long id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> User(-<span class="number">1L</span>, <span class="string">"default"</span>, <span class="string">"123456"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;User&gt; <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">        log.info(<span class="string">"test fallback"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">        log.info(<span class="string">"test fallback"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">(Long id)</span> </span>&#123;</span><br><span class="line">        log.info(<span class="string">"test fallback"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>在UserService的中通过<code>@FeignClient</code>注解的<code>fallback</code>属性来指定对应的服务降级实现类:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FeignClient</span>(value = <span class="string">"Server-Provider"</span>, fallback = UserServiceFallback.class)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>重启Feign-Consumer，并关闭Eureka Client服务，访问<a href="http://localhost:9000/user/1" target="_blank" rel="noopener">http://localhost:9000/user/1</a>，由于Eureka-Client服务提供者都关闭了，所以这里会直接触发服务降级，响应结果如下：</p><p><img src="img/QQ截图20180720164914.png" alt="QQ截图20180720164914.png"></p><p>可看到响应信息为服务降级方法中的返回结果。</p><h2 id="其余Feign配置"><a href="#其余Feign配置" class="headerlink" title="其余Feign配置"></a>其余Feign配置</h2><p>除了Ribbon和Hystrix配置之外，Feign也有一些自个儿的配置。</p><h3 id="请求压缩"><a href="#请求压缩" class="headerlink" title="请求压缩"></a>请求压缩</h3><p>Spring Cloud Feign支持对请求与响应进行GZIP压缩，以减少通信过程中的性能损耗：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">feign:</span></span><br><span class="line"><span class="attr">  compression:</span></span><br><span class="line"><span class="attr">    request:</span></span><br><span class="line"><span class="attr">      enabled:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">    response:</span></span><br><span class="line"><span class="attr">      enabled:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><p></p><p>同时，我们还能对请求压缩做一些更细致的设置，比如下面的配置内容指定了压缩的请求数据类型，并设置了请求压缩的大小下限，只有超过这个大小的请求才会对其进行压缩:</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">feign:</span></span><br><span class="line"><span class="attr">  compression:</span></span><br><span class="line"><span class="attr">    request:</span></span><br><span class="line"><span class="attr">      enabled:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">      mime-types:</span> <span class="string">text/xml,application/xml,application/json</span></span><br><span class="line"><span class="attr">      min-request-size:</span> <span class="number">2048</span></span><br></pre></td></tr></table></figure><p></p><h3 id="日志配置"><a href="#日志配置" class="headerlink" title="日志配置"></a>日志配置</h3><p>Feign提供了日志打印的功能，Feign的日志级别分为四种：</p><ul><li><p><code>NONE</code>: 不记录任何信息。</p></li><li><p><code>BASIC</code>: 仅记录请求方法、<code>URL</code>以及响应状态码和执行时间。</p></li><li><p><code>HEADERS</code>: 除了记录<code>BASIC</code>级别的信息之外，还会记录请求和响应的头信息。</p></li><li><p><code>FULL</code>: 记录所有请求与响应的明细，包括头信息、请求体、元数据等。</p></li></ul><p>日志级别默认为<code>NONE</code>，要改变级别可以在入口类中定义一个日志配置Bean：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableDiscoveryClient</span></span><br><span class="line"><span class="meta">@EnableFeignClients</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoApplication</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    Logger.<span class="function">Level <span class="title">feignLoggerLevel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Logger.Level.FULL;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(DemoApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>然后在yml中配置Feign客户端的日志级别为debug，Feign日志记录仅响应debug级别：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">logging:</span></span><br><span class="line"><span class="attr">  level:</span></span><br><span class="line"><span class="attr">    com:</span></span><br><span class="line"><span class="attr">      example:</span></span><br><span class="line"><span class="attr">        demo:</span></span><br><span class="line"><span class="attr">          service:</span></span><br><span class="line"><span class="attr">            UserService:</span> <span class="string">debug</span></span><br></pre></td></tr></table></figure><p></p><p>重启项目访问<a href=""></a>，可以看到控制台打印日志如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[UserService#get] &lt;--- HTTP/1.1 200 (506ms)</span><br><span class="line">[UserService#get] content-type: application/json;charset=UTF-8</span><br><span class="line">[UserService#get] date: Stu, 10 Jun 2018 01:44:45 GMT</span><br><span class="line">[UserService#get] transfer-encoding: chunked</span><br><span class="line">[UserService#get] </span><br><span class="line">[UserService#get] &#123;&quot;id&quot;:1,&quot;username&quot;:&quot;mrbird&quot;,&quot;password&quot;:&quot;123456&quot;&#125;</span><br><span class="line">[UserService#get] &lt;--- END HTTP (48-byte body)</span><br><span class="line">Flipping property: Server-Provider.ribbon.ActiveConnectionsLimit to use NEXT property: niws.loadbalancer.availabilityFilteringRule.activeConnectionsLimit = 2147483647</span><br></pre></td></tr></table></figure><p></p><blockquote><p>源码链接 <a href="https://github.com/wuyouzhuguli/Spring-Boot-Demos/tree/master/33.Spring-Cloud-Feign-Declarative-REST-Client" target="_blank" rel="noopener">https://github.com/wuyouzhuguli/Spring-Boot-Demos/tree/master/33.Spring-Cloud-Feign-Declarative-REST-Client</a></p></blockquote><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Thu Mar 21 2019 09:22:42 GMT+0800 (GMT+08:00) --&gt;&lt;p&gt;前面我们分别通过Spring Cloud Ribbon和Spring Cloud Hystrix实现了客户端负载均衡和服务容错，而Spring Cloud Feign不但整合了这两者的功能，而且还提供了一种比Ribbon更简单的服务调用方式 ——— 声明式服务调用。在Spring Cloud Feign中编写服务调用代码非常简单，几乎可以直接将服务提供者的代码复制过来，改为接口即可，下面通过例子来演示这个特性。
    
    </summary>
    
    
      <category term="Spring" scheme="http://mrbird.cc/tags/Spring/"/>
    
      <category term="Spring Cloud" scheme="http://mrbird.cc/tags/Spring-Cloud/"/>
    
      <category term="Feign" scheme="http://mrbird.cc/tags/Feign/"/>
    
  </entry>
  
  <entry>
    <title>Spring Cloud Hystrix Dashboard仪表盘</title>
    <link href="http://mrbird.cc/Spring-Cloud-Hystrix-Dashboard.html"/>
    <id>http://mrbird.cc/Spring-Cloud-Hystrix-Dashboard.html</id>
    <published>2018-06-07T01:07:46.000Z</published>
    <updated>2018-08-21T08:05:03.288Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Mar 21 2019 09:22:42 GMT+0800 (GMT+08:00) --><p>Hystrix提供了Hystrix Dashboard来实时监控Hystrix的运行情况，通过Hystrix Dashboard反馈的实时信息，可以帮助我们快速发现系统中存在的问题，从而及时地采取应对措施。Spring Cloud对Hystrix Dashboard进行了整合，这里将介绍如何使用Hystrix Dashboard监控单个和多个Hystrix实例。<a id="more"></a></p><h2 id="监控单个Hystrix实例"><a href="#监控单个Hystrix实例" class="headerlink" title="监控单个Hystrix实例"></a>监控单个Hystrix实例</h2><p>创建一个Spring Boot项目，Spring Boot版本为<code>1.5.13.RELEASE</code>，<code>artifactId</code>填Hystrix-Dashboard，然后引入如下依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>Edgware.SR3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-hystrix<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-hystrix-dashboard<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><p></p><p>稍微配置下yml：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  application:</span></span><br><span class="line"><span class="attr">    name:</span> <span class="string">Hystrix-Dashboard</span></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line"><span class="attr">  port:</span> <span class="number">9002</span></span><br></pre></td></tr></table></figure><p></p><p>然后在入口类上加入注解<code>@EnableHystrixDashboard</code>来启用Hystrix Dashboard的功能。启动项目访问<a href="http://localhost:9002/hystrix" target="_blank" rel="noopener">http://localhost:9002/hystrix</a>就可以看到如下页面了：</p><p><img src="img/QQ截图20180713143306.png" alt="QQ截图20180713143306.png"></p><p>可以看到页面上提供了三种监控的模式：Cluster via Turbine(default cluster)、Cluster via Turbine(custom cluster)和Single Hystrix App：</p><p>前两种都是集群监控的，下面再介绍，这里先介绍第三种单机监控。</p><p>在上一节<a href="/Spring-Cloud-Hystrix-Circuit-Breaker.html">Spring Cloud Hystrix服务容错</a>的基础上，要对Ribbon-Consumer进行监控还必须加入<code>spring-boot-starter-actuator</code>依赖，然后分别启动Eureka-Serve集群，Eureka-Client，Ribbon-Consumer，启动后在刚刚的监控页面上输入：<a href="http://localhost:9000/hystrix.stream" target="_blank" rel="noopener">http://localhost:9000/hystrix.stream </a>，然后往Ribbon-Consumer发几条请求，便可以看到如下监控页面：</p><p><img src="img/QQ截图20180713145843.png" alt="QQ截图20180713145843.png"></p><p>至于这张图上面的指标代表什么含义，我们可以参考官方给的图例：</p><p><img src="img/dashboard-annoted-circuit-640.png" alt="dashboard-annoted-circuit-640.png"></p><p>到这里我们已经实现了使用Hystrix Dashboard对单个Hystrix实例进行监控了，然而实际中一般会有多个Hystrix实例需要同时进行监控，下面我们使用Turbine来实现集群监控。</p><h2 id="Turbine集群监控"><a href="#Turbine集群监控" class="headerlink" title="Turbine集群监控"></a>Turbine集群监控</h2><p>使用Turbine实现对Hystrix的集群监控的思路是：Turbine从Eureka服务注册中心通过服务名Ribbon-Consumer获取服务实例，然后Hystrix Dashboard对Turbine进行监控，这样就实现了Hystrix Dashboard同时对多个Hystrix（Ribbon-consumer）实例同时进行监控的功能。</p><p>创建一个Spring Boot项目，Spring Boot版本为<code>1.5.13.RELEASE</code>，<code>artifactId</code>填Turbine，然后引入如下依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>Edgware.SR3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-turbine<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-eureka<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><p></p><p>然后在入口类中加入<code>@EnableTurbine</code>来开启Turbine的功能，并且加入<code>@EnableDiscoveryClient</code>注解，开启服务获取功能。</p><p>最后在yml中加入一些配置：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  application:</span></span><br><span class="line"><span class="attr">    name:</span> <span class="string">Turbine</span></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line"><span class="attr">  port:</span> <span class="number">9003</span></span><br><span class="line"></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line"><span class="attr">  client:</span></span><br><span class="line"><span class="attr">    serviceUrl:</span></span><br><span class="line"><span class="attr">      defaultZone:</span> <span class="attr">http://mrbird:123456@peer1:8080/eureka/,http://mrbird:123456@peer2:8081/eureka/</span></span><br><span class="line"><span class="attr">turbine:</span></span><br><span class="line"><span class="attr">  app-config:</span> <span class="string">Ribbon-Consumer</span></span><br><span class="line"><span class="attr">  cluster-name-expression:</span> <span class="string">new</span> <span class="string">String('default')</span></span><br><span class="line"><span class="attr">  combine-host-port:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><p></p><p>上面配置了Eureka-Server的集群地址，并且指定了端口号为9003，应用名称为Turbine。剩下的配置为Turbine的配置，含义如下：</p><ul><li><p><code>turbine.app-config</code>指定了需要收集监控信息的服务名，这里为Ribbon-Consumer；</p></li><li><p><code>turbine.cluster-name-expression</code>参数指定了集群名称为default, 当服务数量非常多的时候，可以启动多个Turbine 服务来构建不同的聚合集群， 而该参数可以用来区分这些不同的聚合集群，同时该参数值可以在Hystrix仪表盘中用来定位不同的聚合集群，只需在Hystrix Stream的URL中通过cluster参数来指定(即Cluster via Turbine(custom cluster))；</p></li><li><p><code>turbine.combine-host-port</code>参数设置为七rue, 可以让同一主机上的服务通过主机名与端口号的组合来进行区分， 默认情况下会以host来区分不同的服务，这会使得在本地调试的时候，本机上的不同服务聚合成一个服务来统计。</p></li></ul><p>配置完毕后，我们分别启动下面这些服务：</p><ol><li><p>启动Eureka-Server集群，端口号为8080和8081；</p></li><li><p>启动一个Eureka-Client，端口号为8082；</p></li><li><p>启动两个Ribbon-Consumer，端口号为9000和9001；</p></li><li><p>启动Turbine服务，端口号为9003；</p></li><li><p>最后启动Hystrix-Dashboard服务，端口号为9002。</p></li></ol><p>启动好这些服务后，访问Eureka-server的<a href="http://localhost:8080" target="_blank" rel="noopener">http://localhost:8080</a>可看到这些实例：</p><p><img src="img/QQ截图20180713155602.png" alt="QQ截图20180713155602.png"></p><p>说明服务都已启动成功，我们观察Turbine的控制台，可以看到如下日志信息：</p><p><img src="img/QQ截图20180713160919.png" alt="QQ截图20180713160919.png"></p><p>即Turbine已经从服务注册中心找到了9000和9001端口的Ribbon-Consumer实例。</p><p>这时候我们访问Hystrix-dashboard的地址<a href="http://localhost:9002/hystrix" target="_blank" rel="noopener">http://localhost:9002/hystrix</a>，在页面的地址栏输入<a href="http://localhost:9003/turbine.stream" target="_blank" rel="noopener">http://localhost:9003/turbine.stream</a>，然后分别往9000和9001端口的Ribbon-Consumer实例发送一些请求，这时候可以看到Dashboard的画面如下：</p><p><img src="img/QQ截图20180713155511.png" alt="QQ截图20180713155511.png"></p><p>可以看到Hosts的值已经是2了，并且由于两个Hystrix实例的名称都是Ribbon-Consumer，所以Turbine 会将相同名称的服务作为整体来看待，汇总成一个监控图。</p><p>源码链接：<a href="https://github.com/wuyouzhuguli/Spring-Boot-Demos/tree/master/31.Spring-Cloud-Hystrix-Dashboard-Turbine" target="_blank" rel="noopener">https://github.com/wuyouzhuguli/Spring-Boot-Demos/tree/master/31.Spring-Cloud-Hystrix-Dashboard-Turbine</a></p><h3 id="使用消息中间件"><a href="#使用消息中间件" class="headerlink" title="使用消息中间件"></a>使用消息中间件</h3><p>除了直接用Turbine从服务注册中心获取Ribbon-Consumer实例监控数据外，还可以将Ribbon-Consumer的监控数据发送到消息中间件，然后Turbine从消息中间件中获取。这里我们选择RabbitMQ作为消息中间件。</p><p>在安装RabbitMQ之前，需要先安装Erlang/OTP，下载地址为：<a href="http://www.erlang.org/downloads/" target="_blank" rel="noopener">http://www.erlang.org/downloads/</a>，下载exe文件安装即可。</p><p>安装完毕后，下载RabbitMQ，下载地址为<a href="http://www.rabbitmq.com/install-windows.html" target="_blank" rel="noopener">http://www.rabbitmq.com/install-windows.html</a>，下载exe文件安装即可。</p><p>安装完RabbitMQ之后，我们到RabbitMQ安装目录的sbin下执行如下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rabbitmq-plugins <span class="built_in">enable</span> rabbitmq_management</span><br></pre></td></tr></table></figure><p></p><p>然后在浏览器中输入<a href="http://localhost:15672" target="_blank" rel="noopener">http://localhost:15672</a>，用户名和密码都是guest，登录后可看到：</p><p><img src="img/QQ截图20180713164756.png" alt="QQ截图20180713164756.png"></p><p>说明启动成功。</p><p>接下来我们对Ribbon-Consumer进行改造，实现其将监控信息输出到RabbitMQ，在pom中添加如下依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-netflix-hystrix-stream<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-stream-rabbit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p></p><p>修改Ribbon-Consumer的yml配置文件，加入RabbitMQ的连接配置：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  rabbitmq:</span></span><br><span class="line"><span class="attr">    host:</span> <span class="string">localhost</span></span><br><span class="line"><span class="attr">    port:</span> <span class="number">5672</span></span><br><span class="line"><span class="attr">    username:</span> <span class="string">guest</span></span><br><span class="line"><span class="attr">    password:</span> <span class="string">guest</span></span><br></pre></td></tr></table></figure><p></p><p>最后我们来修改Turbine，让其从RabbitMQ中读取监控信息。在Turbine项目中引入如下依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-turbine-stream<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-stream-rabbit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p></p><p>同时删除<code>spring-cloud-starter-eureka</code>和<code>spring-cloud-starter-turbine</code>依赖，因为我们不再从服务注册中心去获取监控的服务信息了，并且<code>spring-cloud-starter-turbine-stream</code>已经包含了<code>spring-cloud-starter-turbine</code>依赖。</p><p>修改Turbine的入口类，删除<code>@EnableTurbine</code>和<code>@EnableDiscoveryClient</code>注解，添加<code>@EnableTurbineStream</code>注解。</p><p>将Turbine的yml配置修改为：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  application:</span></span><br><span class="line"><span class="attr">    name:</span> <span class="string">Turbine</span></span><br><span class="line"><span class="attr">  rabbitmq:</span></span><br><span class="line"><span class="attr">      host:</span> <span class="string">localhost</span></span><br><span class="line"><span class="attr">      port:</span> <span class="number">5672</span></span><br><span class="line"><span class="attr">      username:</span> <span class="string">guest</span></span><br><span class="line"><span class="attr">      password:</span> <span class="string">guest</span></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line"><span class="attr">  port:</span> <span class="number">9003</span></span><br></pre></td></tr></table></figure><p></p><p>修改完毕后，我们分别启动下面这些服务：</p><ol><li><p>启动Eureka-Server集群，端口号为8080和8081；</p></li><li><p>启动一个Eureka-Client，端口号为8082；</p></li><li><p>启动两个Ribbon-Consumer，端口号为9000和9001；</p></li><li><p>启动Turbine服务，端口号为9003；</p></li><li><p>最后启动Hystrix-Dashboard服务，端口号为9002。</p></li></ol><p>同样的我们访问Hystrix-dashboard的地址<a href="http://localhost:9002/hystrix" target="_blank" rel="noopener">http://localhost:9002/hystrix</a>，在页面的地址栏输入<a href="http://localhost:9003/turbine.stream" target="_blank" rel="noopener">http://localhost:9003/turbine.stream</a>，然后分别往9000和9001端口的Ribbon-Consumer实例发送一些请求，这时候可以看到Dashboard的画面如下：</p><p><img src="img/QQ截图20180713171537.png" alt="QQ截图20180713171537.png"></p><p>效果和从服务注册中心获取服务的监控信息一致。并且这时候观察RabbitMQ的页面：</p><p><img src="img/QQ截图20180713171622.png" alt="QQ截图20180713171622.png"></p><p>可看到Queued messages已经有数据了。</p><p>至此我们完成了Turbine从消息中间件RabbitMQ来收集监控信息的过程。</p><p>源码链接：<a href="https://github.com/wuyouzhuguli/Spring-Boot-Demos/tree/master/32.Spring-Cloud-Hystrix-Dashboard-Turbine-RabbitMQ" target="_blank" rel="noopener">https://github.com/wuyouzhuguli/Spring-Boot-Demos/tree/master/32.Spring-Cloud-Hystrix-Dashboard-Turbine-RabbitMQ</a></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Thu Mar 21 2019 09:22:42 GMT+0800 (GMT+08:00) --&gt;&lt;p&gt;Hystrix提供了Hystrix Dashboard来实时监控Hystrix的运行情况，通过Hystrix Dashboard反馈的实时信息，可以帮助我们快速发现系统中存在的问题，从而及时地采取应对措施。Spring Cloud对Hystrix Dashboard进行了整合，这里将介绍如何使用Hystrix Dashboard监控单个和多个Hystrix实例。
    
    </summary>
    
    
      <category term="Spring" scheme="http://mrbird.cc/tags/Spring/"/>
    
      <category term="Spring Cloud" scheme="http://mrbird.cc/tags/Spring-Cloud/"/>
    
      <category term="Hystrix" scheme="http://mrbird.cc/tags/Hystrix/"/>
    
  </entry>
  
  <entry>
    <title>Spring Cloud Hystrix服务容错</title>
    <link href="http://mrbird.cc/Spring-Cloud-Hystrix-Circuit-Breaker.html"/>
    <id>http://mrbird.cc/Spring-Cloud-Hystrix-Circuit-Breaker.html</id>
    <published>2018-06-06T00:57:40.000Z</published>
    <updated>2018-08-21T08:00:58.840Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Mar 21 2019 09:22:44 GMT+0800 (GMT+08:00) --><p>在微服务的架构中，服务间通常会形成相互依赖的关系，比如现在有三个微服务节点：A，B和C，B为A的消费者，C为B的消费者。假如由于网络波动或者A服务自身故障，导致B调用A服务的线程被挂起进入长时间的等待。在高并发的情况下可能导致B的资源被耗竭随之崩溃，从而导致C服务也不可用。这种连环式的雪崩效应在微服务中较为常见，为了解决这个问题，服务熔断技术应运而出。熔断一词来自电路学，指的是电路在出现短路状况时，“断路器”能够及时地切断故障电路，避免电路过载发热引发火灾。</p><p>类似的，微服务架构中的断路器能够及时地发现故障服务，并向服务调用方返回错误响应，而不是长时间的等待。Spring Cloud Hystrix在Hystrix（又是一款由Netflix开发的开源软件，Github地址<a href="https://github.com/Netflix/Hystrix" target="_blank" rel="noopener">https://github.com/Netflix/Hystrix</a>）的基础上进行了封装，提供了服务熔断，服务降级，线程隔离等功能，通过这些功能可以提供服务的容错率。<a id="more"></a></p><h2 id="使用Hystrix"><a href="#使用Hystrix" class="headerlink" title="使用Hystrix"></a>使用Hystrix</h2><p>这里将在上一节<a href="/Spring-Cloud-Ribbon-LoadBalance.html">Spring Cloud Ribbon客户端负载均衡</a>源码的基础上配置Hystrix。</p><p>我们先看下在没有配置Hystrix之前，关闭Eureka-Client是什么效果。</p><p>分别使用peer1和peer2配置启动Eureka-Server集群，然后启动两个Eureka-Client实例，端口分别为8082和8083，最后启动Ribbon-Consumer。准备完毕后，我们关闭端口为8082的Eureka-Client，然后发送GET请求<a href="http://localhost:9000/user/1" target="_blank" rel="noopener">http://localhost:9000/user/1</a>，返回结果如下：</p><p><img src="img/QQ截图20180710151846.png" alt="QQ截图20180710151846.png"></p><p>下面开始使用使用Spring Cloud Hystrix，在项目Ribbon-Consumer中引入Spring Cloud Hystrix依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-hystrix<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p></p><p>在入口类上加入<code>@EnableHystrix</code>或者<code>@EnableCircuitBreaker</code>注解。这两个注解是等价的，查看<code>@EnableHystrix</code>注解源码就可以证实这一点：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(&#123;ElementType.TYPE&#125;)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@EnableCircuitBreaker</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnableHystrix &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>在引入<code>@EnableHystrix</code>或者<code>@EnableCircuitBreaker</code>注解后，我们的入口类代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableCircuitBreaker</span></span><br><span class="line"><span class="meta">@EnableDiscoveryClient</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoApplication</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@LoadBalanced</span></span><br><span class="line">    <span class="function">RestTemplate <span class="title">restTemplate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> RestTemplate();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(DemoApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>入口类上总共包含了三个注解<code>@EnableCircuitBreaker</code>、<code>@EnableDiscoveryClient</code>和<code>@SpringBootApplication</code>，这三个注解的组合可以使用<code>@SpringCloudApplication</code>来代替，<code>@SpringCloudApplication</code>源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(&#123;ElementType.TYPE&#125;)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableDiscoveryClient</span></span><br><span class="line"><span class="meta">@EnableCircuitBreaker</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> SpringCloudApplication &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>接着将UserController中的方法提取出来，创建一个UserService（为了简单起见，不再创建Service接口）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span>(<span class="string">"userService"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Logger log = LoggerFactory.getLogger(<span class="keyword">this</span>.getClass());</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RestTemplate restTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">getUser</span><span class="params">(@PathVariable Long id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> restTemplate.getForObject(<span class="string">"http://Server-Provider/user/&#123;id&#125;"</span>, User.class, id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;User&gt; <span class="title">getUsers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.restTemplate.getForObject(<span class="string">"http://Server-Provider/user"</span>, List.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">addUser</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        User user = <span class="keyword">new</span> User(<span class="number">1L</span>, <span class="string">"mrbird"</span>, <span class="string">"123456"</span>);</span><br><span class="line">        HttpStatus status = <span class="keyword">this</span>.restTemplate.postForEntity(<span class="string">"http://Server-Provider/user"</span>, user, <span class="keyword">null</span>).getStatusCode();</span><br><span class="line">        <span class="keyword">if</span> (status.is2xxSuccessful()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"新增用户成功"</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"新增用户失败"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateUser</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        User user = <span class="keyword">new</span> User(<span class="number">1L</span>, <span class="string">"mrbird"</span>, <span class="string">"123456"</span>);</span><br><span class="line">        <span class="keyword">this</span>.restTemplate.put(<span class="string">"http://Server-Provider/user"</span>, user);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteUser</span><span class="params">(@PathVariable Long id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.restTemplate.delete(<span class="string">"http://Server-Provider/user/&#123;1&#125;"</span>, id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>接着改造UserService的<code>getUser</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@HystrixCommand</span>(fallbackMethod = <span class="string">"getUserDefault"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> User <span class="title">getUser</span><span class="params">(@PathVariable Long id)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> restTemplate.getForObject(<span class="string">"http://Server-Provider/user/&#123;id&#125;"</span>, User.class, id);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> User <span class="title">getUserDefault</span><span class="params">(Long id)</span> </span>&#123;</span><br><span class="line">    User user = <span class="keyword">new</span> User();</span><br><span class="line">    user.setId(-<span class="number">1L</span>);</span><br><span class="line">    user.setUsername(<span class="string">"defaultUser"</span>);</span><br><span class="line">    user.setPassword(<span class="string">"123456"</span>);</span><br><span class="line">    <span class="keyword">return</span> user;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>我们在<code>getUser</code>方法上加入了<code>@HystrixCommand</code>注解，注解的<code>fallbackMethod</code>属性指定了被调用的方法不可用时的回调方法（服务熔断时的回调处理逻辑，即服务降级），这里为<code>getUserDefault</code>方法（必须与<code>getUser</code>方法的参数及返回值类型一致）。</p><p>在UserController中调用UserService的<code>getUser</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestController</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Logger log = LoggerFactory.getLogger(<span class="keyword">this</span>.getClass());</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserService userService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"user/&#123;id&#125;"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">getUser</span><span class="params">(@PathVariable Long id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> userService.getUser(id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>修改完后启动Ribbon-Consumer并重重新启动8082端口的Eureka-Client，发送数次GET请求<a href="http://localhost:9000/user/1" target="_blank" rel="noopener">http://localhost:9000/user/1</a>后，再次关闭8082端口的Eureka-Client。</p><p>断开后，继续发送GET请求<a href="http://localhost:9000/user/1" target="_blank" rel="noopener">http://localhost:9000/user/1</a>，当轮询到8082端口时返回数据如下图所示：</p><p><img src="img/QQ截图20180710154714.png" alt="QQ截图20180710154714.png"></p><p>可以看到，当轮询到服务不可用时，触发了熔断机制，接口回调了<code>fallbackMethod</code>指定的方法。</p><p>我们也可以模拟服务超时的情况，可以在Eureka-Client提供的接口方法中设置线程等待，等待时间大于2000（Hystrix默认超时时间为2000 毫秒）即可触发调用方Ribbon-Consumer的服务熔断。</p><h2 id="HystrixCommand详解"><a href="#HystrixCommand详解" class="headerlink" title="@HystrixCommand详解"></a>@HystrixCommand详解</h2><p><code>@HystrixCommand</code>注解还包含许多别的属性功能，下面介绍一些常用的属性配置。</p><h3 id="服务降级"><a href="#服务降级" class="headerlink" title="服务降级"></a>服务降级</h3><p>上面TestController中的<code>getUser</code>中我们用<code>@HystrixCommand</code>注解指定了服务降级方法<code>getUserDefault</code>。如果<code>getUserDefault</code>方法也抛出异常，那么我们可以再次使用<code>@HystrixCommand</code>注解指定<code>getUserDefault</code>方法降级的方法，比如定义一个<code>getUserDefault2</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@HystrixCommand</span>(fallbackMethod = <span class="string">"getUserDefault2"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> User <span class="title">getUserDefault</span><span class="params">(Long id)</span> </span>&#123;</span><br><span class="line">    String a = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 测试服务降级</span></span><br><span class="line">    a.toString();</span><br><span class="line">    User user = <span class="keyword">new</span> User();</span><br><span class="line">    user.setId(-<span class="number">1L</span>);</span><br><span class="line">    user.setUsername(<span class="string">"defaultUser"</span>);</span><br><span class="line">    user.setPassword(<span class="string">"123456"</span>);</span><br><span class="line">    <span class="keyword">return</span> user;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> User <span class="title">getUserDefault2</span><span class="params">(Long id)</span> </span>&#123;</span><br><span class="line">    User user = <span class="keyword">new</span> User();</span><br><span class="line">    user.setId(-<span class="number">2L</span>);</span><br><span class="line">    user.setUsername(<span class="string">"defaultUser2"</span>);</span><br><span class="line">    user.setPassword(<span class="string">"123456"</span>);</span><br><span class="line">    <span class="keyword">return</span> user;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>重启Ribbon-Consumer，并关闭8082端口的Eureka Client服务，访问<a href="http://localhost:9000/user/1" target="_blank" rel="noopener">http://localhost:9000/user/1</a>：</p><p><img src="img/QQ截图20180712112335.png" alt="QQ截图20180712112335.png"></p><h3 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h3><p>在使用<code>@HystrixCommand</code>注解标注的方法中，除了<code>HystrixBadRequestException</code>异常外，别的异常都会触发服务降级。假如我们想指定某个异常不触发服务降级，可以使用<code>@HystrixCommand</code>注解的<code>ignoreExceptions</code>属性进行忽略。如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@HystrixCommand</span>(fallbackMethod = <span class="string">"getUserDefault2"</span>, ignoreExceptions = &#123;NullPointerException.class&#125;)</span><br><span class="line"><span class="function"><span class="keyword">public</span> User <span class="title">getUserDefault</span><span class="params">(Long id)</span> </span>&#123;</span><br><span class="line">    String a = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 测试服务降级</span></span><br><span class="line">    a.toString();</span><br><span class="line">    User user = <span class="keyword">new</span> User();</span><br><span class="line">    user.setId(-<span class="number">1L</span>);</span><br><span class="line">    user.setUsername(<span class="string">"defaultUser"</span>);</span><br><span class="line">    user.setPassword(<span class="string">"123456"</span>);</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> HystrixBadRequestException()</span><br><span class="line">    <span class="keyword">return</span> user;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>此外，对于方法抛出的异常信息，我们可以在服务降级的方法中使用<code>Throwable</code>对象获取，如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@HystrixCommand</span>(fallbackMethod = <span class="string">"getUserDefault2"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> User <span class="title">getUserDefault</span><span class="params">(Long id, Throwable e)</span> </span>&#123;</span><br><span class="line">    System.out.println(e.getMessage());</span><br><span class="line">    User user = <span class="keyword">new</span> User();</span><br><span class="line">    user.setId(-<span class="number">2L</span>);</span><br><span class="line">    user.setUsername(<span class="string">"defaultUser2"</span>);</span><br><span class="line">    user.setPassword(<span class="string">"123456"</span>);</span><br><span class="line">    <span class="keyword">return</span> user;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h3 id="命名与分组"><a href="#命名与分组" class="headerlink" title="命名与分组"></a>命名与分组</h3><p>通过指定<code>@HystrixCommand</code>注解的<code>commandKey</code>、<code>groupKey</code>以及<code>threadPoolKey</code>属性可以设置命令名称、分组以及线程池划分，如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@HystrixCommand</span>(fallbackMethod = <span class="string">"getUserDefault"</span>, commandKey = <span class="string">"getUserById"</span>, groupKey = <span class="string">"userGroup"</span>,</span><br><span class="line">        threadPoolKey = <span class="string">"getUserThread"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> User <span class="title">getUser</span><span class="params">(@PathVariable Long id)</span> </span>&#123;</span><br><span class="line">	log.info(<span class="string">"获取用户信息"</span>);</span><br><span class="line">    <span class="keyword">return</span> restTemplate.getForObject(<span class="string">"http://Server-Provider/user/&#123;id&#125;"</span>, User.class, id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>上面的配置指定了命令的名称为<code>getUserById</code>，组名为<code>userGroup</code>，线程池名称为<code>getUserThread</code>。</p><p>通过设置命令组，Hystrix会根据组来组织和统计命令的告警、仪表盘等信息。默认情况下，Hystrix命令通过组名来划分线程池，即组名相同的命令放到同一个线程池里，如果通过<code>threadPoolKey</code>设置了线程池名称，则按照线程池名称划分。</p><p>当<code>getUser</code>方法被调用时，日志打印如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2018-06-06 15:32:55.945  INFO 16192 --- [getUserThread-1] com.example.demo.Service.UserService  : 获取用户信息</span><br></pre></td></tr></table></figure><p></p><p>可看到线程名称为getUserThread-1。</p><h3 id="Hystrix缓存"><a href="#Hystrix缓存" class="headerlink" title="Hystrix缓存"></a>Hystrix缓存</h3><p>我们在Controller中调用三次<code>getUser</code>方法，参数都为1L：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserService userService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"testCache"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testCache</span><span class="params">()</span></span>&#123;</span><br><span class="line">        userService.getUser(<span class="number">1L</span>);</span><br><span class="line">        userService.getUser(<span class="number">1L</span>);</span><br><span class="line">        userService.getUser(<span class="number">1L</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>当访问<a href="http://localhost:9000/testCache" target="_blank" rel="noopener">http://localhost:9000/testCache</a>时，控制台输出如下： <img src="img/QQ截图20180712173742.png" alt="QQ截图20180712173742.png"></p><p>开启缓存可以让<code>getUser</code>方法只被调用一次，剩下两次直接从缓存里获取。</p><p><strong>开启缓存</strong></p><p>要在Hystrix中开启缓存很简单，只需使用<code>@CacheResult</code>注解即可，修改UserService的<code>getUser</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@CacheResult</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> User <span class="title">getUser</span><span class="params">(@PathVariable Long id)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> restTemplate.getForObject(<span class="string">"http://Server-Provider/user/&#123;id&#125;"</span>, User.class, id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>通过上面的设定，Hystrix会将返回的User对象进行缓存，缓存的key默认为方法的所有参数，这里只有一个id参数，所以缓存的key为用户id。</p><p>这里在测试的时候遇到一个异常：</p><div class="note danger"><p>java.lang.IllegalStateException: Request caching is not available. Maybe you need to initialize the HystrixRequestContext? at com.netflix.hystrix.HystrixRequestCache.get(HystrixRequestCache.java:104) ~[hystrix-core-1.5.12.jar:1.5.12] at com.netflix.hystrix.AbstractCommand$7.call(AbstractCommand.java:478) ~[hystrix-core-1.5.12.jar:1.5.12] at com.netflix.hystrix.AbstractCommand$7.call(AbstractCommand.java:454) ~[hystrix-core-1.5.12.jar:1.5.12] …</p></div><p></p><p>在Hystrix的issue中找到了类似的提问：<a href="https://github.com/Netflix/Hystrix/issues/1314" target="_blank" rel="noopener">https://github.com/Netflix/Hystrix/issues/1314</a>。</p><p>大致意思是在使用Hytrix缓存之前，需要通过<code>HystrixRequestContext.initializeContext</code>初始化Hystrix请求上下文，请求结束之后需要调用<code>shutdown</code>方法关闭请求。</p><p>所以我们可以定义一个过滤器来实现这个过程：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@WebFilter</span>(filterName = <span class="string">"hystrixRequestContextServletFilter"</span>, urlPatterns = <span class="string">"/*"</span>, asyncSupported = <span class="keyword">true</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HystrixRequestContextServletFilter</span> <span class="keyword">implements</span> <span class="title">Filter</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(FilterConfig filterConfig)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFilter</span><span class="params">(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain)</span> <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">        HystrixRequestContext context = HystrixRequestContext.initializeContext();</span><br><span class="line">        filterChain.doFilter(servletRequest, servletResponse);</span><br><span class="line">        context.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><div class="note info"><p>到这里，我才意识到，其实Hystrix的缓存还是蛮鸡肋的，请求缓存不是只写入一次结果就不再变化的，而是每次请求到达Controller的时候，我们都需要为HystrixRequestContext进行初始化，之前的缓存也就是不存在了，我们是在同一个请求中保证结果相同，同一次请求中的第一次访问后对结果进行缓存，缓存的生命周期只有一次请求！</p></div><p>改造完毕后，重启项目再次访问<a href="http://localhost:9000/testCache" target="_blank" rel="noopener">http://localhost:9000/testCache</a>，控制台输出如下：</p><p><img src="img/QQ截图20180712181439.png" alt="QQ截图20180712181439.png"></p><p><strong>设定key值</strong></p><p>我们也可以明确的指定缓存的key值是什么。指定key的值有两种方式：</p><ol><li><p>通过<code>@CacheKey</code>注解指定，如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@CacheResult</span></span><br><span class="line"><span class="meta">@HystrixCommand</span>(fallbackMethod = <span class="string">"getUserDefault"</span>, commandKey = <span class="string">"getUserById"</span>, groupKey = <span class="string">"userGroup"</span>,</span><br><span class="line">        threadPoolKey = <span class="string">"getUserThread"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> User <span class="title">getUser</span><span class="params">(@CacheKey(<span class="string">"id"</span>)</span> @PathVariable Long id) </span>&#123;</span><br><span class="line">    log.info(<span class="string">"获取用户信息"</span>);</span><br><span class="line">    <span class="keyword">return</span> restTemplate.getForObject(<span class="string">"http://Server-Provider/user/&#123;id&#125;"</span>, User.class, id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也可以指定参数对象内部属性为key值：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@CacheResult</span></span><br><span class="line"><span class="meta">@HystrixCommand</span>(fallbackMethod = <span class="string">"getUserDefault"</span>, commandKey = <span class="string">"getUserById"</span>, groupKey = <span class="string">"userGroup"</span>,</span><br><span class="line">        threadPoolKey = <span class="string">"getUserThread"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> User <span class="title">getUser</span><span class="params">(@CacheKey(<span class="string">"id"</span>)</span> User user) </span>&#123;</span><br><span class="line">    log.info(<span class="string">"获取用户信息"</span>);</span><br><span class="line">    <span class="keyword">return</span> restTemplate.getForObject(<span class="string">"http://Server-Provider/user/&#123;id&#125;"</span>, User.class, user.getId());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>通过方法来指定，方法的返回值必须是String类型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getCacheKey</span><span class="params">(Long id)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> String.valueOf(id);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@CacheResult</span>(cacheKeyMethod = <span class="string">"getCacheKey"</span>)</span><br><span class="line"><span class="meta">@HystrixCommand</span>(fallbackMethod = <span class="string">"getUserDefault"</span>, commandKey = <span class="string">"getUserById"</span>, groupKey = <span class="string">"userGroup"</span>,</span><br><span class="line">        threadPoolKey = <span class="string">"getUserThread"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> User <span class="title">getUser</span><span class="params">(Long id)</span> </span>&#123;</span><br><span class="line">    log.info(<span class="string">"获取用户信息"</span>);</span><br><span class="line">    <span class="keyword">return</span> restTemplate.getForObject(<span class="string">"http://Server-Provider/user/&#123;id&#125;"</span>, User.class, id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>值得注意的是，方法2的优先级比方法1高。</p><p><strong>缓存清除</strong></p><p>在涉及到更新User信息的方法上，我们要及时的清除相应的缓存，否则将会导致缓存数据和实际数据不一致的问题。我们在UserService的<code>updateUser</code>方法上做缓存清除操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@CacheRemove</span>(commandKey = <span class="string">"getUserById"</span>)</span><br><span class="line"><span class="meta">@HystrixCommand</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateUser</span><span class="params">(@CacheKey(<span class="string">"id"</span>)</span> User user) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.restTemplate.put(<span class="string">"http://Server-Provider/user"</span>, user);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p><code>@CacheRemove</code>的<code>commandKey</code>属性和<code>getUser</code>里定义的一致。</p><h3 id="请求合并"><a href="#请求合并" class="headerlink" title="请求合并"></a>请求合并</h3><p>请求合并就是将多个单个请求合并成一个请求，去调用服务提供者，从而降低服务提供者负载的，一种应对高并发的解决办法。</p><p>Hystrix中提供了一个<code>@HystrixCollapser</code>注解，该注解可以将处于一个很短的时间段（默认10 毫秒）内对同一依赖服务的多个请求进行整合并以批量方式发起请求。为了演示<code>@HystrixCollapser</code>注解的使用方法，我们改造下Eureka-Client（服务提供者）的UserController接口，提供一个批量处理的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"user"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Logger log = LoggerFactory.getLogger(<span class="keyword">this</span>.getClass());</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"users"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;User&gt; <span class="title">get</span><span class="params">(String ids)</span> </span>&#123;</span><br><span class="line">        log.info(<span class="string">"批量获取用户信息"</span>);</span><br><span class="line">        List&lt;User&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (String id : ids.split(<span class="string">","</span>)) &#123;</span><br><span class="line">            list.add(<span class="keyword">new</span> User(Long.valueOf(id), <span class="string">"user"</span> + id, <span class="string">"123456"</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>然后在Ribbon-Consumer的UserService里添加两个方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@HystrixCollapser</span>(batchMethod = <span class="string">"findUserBatch"</span>, collapserProperties = &#123;</span><br><span class="line">        <span class="meta">@HystrixProperty</span>(name = <span class="string">"timerDelayInMilliseconds"</span>, value = <span class="string">"100"</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="function"><span class="keyword">public</span> Future&lt;User&gt; <span class="title">findUser</span><span class="params">(Long id)</span> </span>&#123;</span><br><span class="line">    log.info(<span class="string">"获取单个用户信息"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> AsyncResult&lt;User&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> User <span class="title">invoke</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> restTemplate.getForObject(<span class="string">"http://Server-Provider/user/&#123;id&#125;"</span>, User.class, id);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@HystrixCommand</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;User&gt; <span class="title">findUserBatch</span><span class="params">(List&lt;Long&gt; ids)</span> </span>&#123;</span><br><span class="line">    log.info(<span class="string">"批量获取用户信息,ids: "</span> + ids);</span><br><span class="line">    User[] users = restTemplate.getForObject(<span class="string">"http://Server-Provider/user/users?ids=&#123;1&#125;"</span>, User[].class, StringUtils.join(ids, <span class="string">","</span>));</span><br><span class="line">    <span class="keyword">return</span> Arrays.asList(users);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p><code>@HystrixCollapser</code>注解的<code>batchMethod</code>属性指定了批量处理的方法为下面定义的<code>findUserBatch</code>方法，<code>timerDelayInMilliseconds</code>的值为100（毫秒），意思是在100毫秒这个时间范围内的所有对<code>findUser</code>的调用，都将被合并为一个批量处理操作，进行批量处理操作的方法就是<code>findUserBatch</code>。</p><p>我们在TestController中添加一个测试方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"testRequestMerge"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testRequerstMerge</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, ExecutionException </span>&#123;</span><br><span class="line">    Future&lt;User&gt; f1 = userService.findUser(<span class="number">1L</span>);</span><br><span class="line">    Future&lt;User&gt; f2 = userService.findUser(<span class="number">2L</span>);</span><br><span class="line">    Future&lt;User&gt; f3 = userService.findUser(<span class="number">3L</span>);</span><br><span class="line">    f1.get();</span><br><span class="line">    f2.get();</span><br><span class="line">    f3.get();</span><br><span class="line">    Thread.sleep(<span class="number">200</span>);</span><br><span class="line">    Future&lt;User&gt; f4 = userService.findUser(<span class="number">4L</span>);</span><br><span class="line">    f4.get();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>上面的测试方法中对<code>findUser</code>方法进行了4次的调用，最后一次调用（f4）之前先让线程等待200毫秒（大于<code>timerDelayInMilliseconds</code>中定义的100毫秒），所以我们的预期是前三次调用会被合并，而最后一次调用不会被合并进去。</p><p>启动Ribbon-Consumer，访问<a href="http://localhost:9000/testRequestMerge" target="_blank" rel="noopener">http://localhost:9000/testRequestMerge</a>,控制台输出如下：</p><p><img src="img/QQ截图20180712185806.png" alt="QQ截图20180712185806.png"></p><p>可以看到，控制台的输出符合我们的预期，f1、f2和f3被合并成了一个请求。</p><p>而且可以看到，控制台并没有打印出<code>findUser</code>方法中的<code>获取单个用户信息</code>的日志，实际上<code>findUser</code>方法并不会被调用，所以上面的代码可以简化为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta">@HystrixCollapser</span>(batchMethod = <span class="string">"findUserBatch"</span>, collapserProperties = &#123;</span><br><span class="line">        <span class="meta">@HystrixProperty</span>(name = <span class="string">"timerDelayInMilliseconds"</span>, value = <span class="string">"100"</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="function"><span class="keyword">public</span> Future&lt;User&gt; <span class="title">findUser</span><span class="params">(Long id)</span> </span>&#123;</span><br><span class="line">    log.info(<span class="string">"获取单个用户信息"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@HystrixCommand</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;User&gt; <span class="title">findUserBatch</span><span class="params">(List&lt;Long&gt; ids)</span> </span>&#123;</span><br><span class="line">    log.info(<span class="string">"批量获取用户信息,ids: "</span> + ids);</span><br><span class="line">    User[] users = restTemplate.getForObject(<span class="string">"http://Server-Provider/user/users?ids=&#123;1&#125;"</span>, User[].class, StringUtils.join(ids, <span class="string">","</span>));</span><br><span class="line">    <span class="keyword">return</span> Arrays.asList(users);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>虽然通过请求的合并可以减轻带宽和服务的压力，但合并请求的过程也会带来额外的开销。就拿上面的<code>testCache</code>来说，比如我们对单个<code>findUser</code>的方法调用耗时5ms，那么调用4次耗时可以粗略的估算为20ms。当我们使用Hystrix的请求合并功能后，前3次请求（f1、f2和f3）进行了合并，第4次请求（f4）没有进行合并，那么耗时可以粗略的估算为<code>3*5+100+5=120ms</code>（100为上面<code>timerDelayInMilliseconds</code>中指定的时间范围，在该时间段过后，才会调用第4次请求），结果明显比单独调用4次来得高。所以实际中是否该使用Hystrix的请求合并功能，需结合实际需求进行抉择。</p><h2 id="Hystrix属性"><a href="#Hystrix属性" class="headerlink" title="Hystrix属性"></a>Hystrix属性</h2><p>除了上面涉及到的Hystrix属性配置外，其还包含了大量的别的可用配置。配置可以分为四个级别，优先级从低到高分别为：全局默认配置、全局配置、实例默认值、实例配置。</p><h3 id="Commond"><a href="#Commond" class="headerlink" title="Commond"></a>Commond</h3><h4 id="execution"><a href="#execution" class="headerlink" title="execution"></a>execution</h4><p><code>execution.isolation.strategy</code>： 该属性用来设置执行的隔离策略，它有如下两个选项。</p><ol><li><p><code>THREAD</code>: 通过线程池隔离的策略。它在独立的线程上执行， 并且它的并发限制受线程池中线程数量的限制。</p></li><li><p><code>SEMAPHORE</code>: 通过信号量隔离的策略。它在调用线程上执行， 并且它的并发限制受信号量计数的限制。</p></li></ol><table><tr><th>属性级别</th><th>默认值、配置方式、配置属性</th></tr><tr><td>全局默认配置</td><td>THREAD</td></tr><tr><td>全局配置</td><td>hystrix.command.default.execution.isolation.strategy</td></tr><tr><td>实例默认值</td><td>@HystrixProperty(name=”execution.isolation.strategy”, value=”THREAD”)</td></tr><tr><td>实例配置</td><td>hystrix.command.HystrixCommandKey.execution.isolation.strategy</td></tr></table><div class="note info"><p>实例配置中的HystrixCommandKey对应@HystrixCommand注解中commandKey 属性指定的值。</p></div><p><code>execution.isolation.thread.timeoutinMilliseconds</code>： 该属性用来配置HystrixCommand执行的超时时间，单位为毫秒。当HystrixCommand执行时间超过该配置值之后， Hystrix会将该执行命令标记为TIMEOUT并进入服务降级处理逻辑。</p><table><tr><th>属性级别</th><th>默认值、配置方式、配置属性</th></tr><tr><td>全局默认配置</td><td>1000亳秒</td></tr><tr><td>全局配置</td><td>hystrix.command.default.execution.isolation.thread. timeoutinMilliseconds</td></tr><tr><td>实例默认值</td><td>@HystrixProperty(name=”execution.isolation.thread.timeoutinMilliseconds”,value=”2000”)</td></tr><tr><td>实例配置</td><td>hystrix.command.HystrixCommandKey.execution.isolation.thread.timeoutinMilliseconds</td></tr></table><p><code>execution.timeout.enabled</code>: 该属性用来配置HystrixCommand的执行是否启用超时时间。默认为true, 如果设置为false, 那么<code>execution.isolation.thread.timeoutinMilliseconds</code>属性的配置将不再起作用。</p><table><tr><th>属性级别</th><th>默认值、配置方式、配置属性</th></tr><tr><td>全局默认配置</td><td>true</td></tr><tr><td>全局配置</td><td>hystrix.command.default.execution.timeout.enabled</td></tr><tr><td>实例默认值</td><td>@HystrixProperty(name=”execution.timeout.enabled”, value=”false”)</td></tr><tr><td>实例配置</td><td>hystrix.command.HystrixCommandKey.execution.timeout.enabled</td></tr></table><p><code>execution.isolation.thread.interruptOnTimeout</code>: 该属性用来配置当HystrixCommand执行超时的时候是否要将它中断。</p><table><tr><th>属性级别</th><th>默认值、配置方式、配置属性</th></tr><tr><td>全局默认配置</td><td>true</td></tr><tr><td>全局配置</td><td>hystrix.command.default.execution.isolation.thread.interruptOnTimeout</td></tr><tr><td>实例默认值</td><td>@HystrixProperty(name=”execution.isolation.thread.interruptOnTimeout”,value=”false”)</td></tr><tr><td>实例配置</td><td>hystrix.command.HystrixCommandKey.execution.isolation.thread.interruptOnTimeout</td></tr></table><p><code>execution.isolation.thread.interruptOnCancel</code>: 该属性用来配置当HystrixCommand执行被取消的时候是否要将它中断。</p><table><tr><th>属性级别</th><th>默认值、配置方式、配置属性</th></tr><tr><td>全局默认配置</td><td>true</td></tr><tr><td>全局配置</td><td>hystrix.command.default.execution.isolation.thread.interruptOnCancel</td></tr><tr><td>实例默认值</td><td>@HystrixProperty(name=”execution.isolation.thread.interruptOnCancel”,value= “false”)</td></tr><tr><td>实例配置</td><td>hystrix.command.HystrixCommandKey.execution.isolation.thread.interruptOnCancel</td></tr></table><p><code>execution.isolation.semaphore.maxConcurrentRequests</code>: 当HystrixCommand的隔离策略使用信号量的时候，该属性用来配置信号量的大小（并发请求数）。当最大并发请求数达到该设置值时，后续的请求将会被拒绝。</p><table><tr><th>属性级别</th><th>默认值、配置方式、配置属性</th></tr><tr><td>全局默认配置</td><td>10</td></tr><tr><td>全局配置</td><td>hystrix.command.default.execution.isolation.semaphore.maxConcurrentRequests</td></tr><tr><td>实例默认值</td><td>@HystrixProperty(name=”execution.isolation.semaphore.maxConcurrentRequests”, value=”2”)</td></tr><tr><td>实例配置</td><td>hystrix.command.HystrixCommandKey.execution.isolation.semaphore.maxConcurrentRequests</td></tr></table><h4 id="fallback"><a href="#fallback" class="headerlink" title="fallback"></a>fallback</h4><p><code>fallback.enabled</code>: 该属性用来设置服务降级策略是否启用，如果设置为false,那么当请求失败或者拒绝发生时，将不会调用降级服务。</p><table><tr><th>属性级别</th><th>默认值、配置方式、配置属性</th></tr><tr><td>全局默认配置</td><td>true</td></tr><tr><td>全局配置</td><td>hystrix.command.default.fallback.enabled</td></tr><tr><td>实例默认值</td><td>@HystrixProperty(name= “fallback.enabled”, value=”false”)</td></tr><tr><td>实例配置</td><td>hystrix.command.HystrixCommandKey.fallback.enabled</td></tr></table><h4 id="circuitBreaker断路器"><a href="#circuitBreaker断路器" class="headerlink" title="circuitBreaker断路器"></a>circuitBreaker断路器</h4><p><code>circuitBreaker.enabled</code>: 该属性用来确定当服务请求命令失败时， 是否使用断路器来跟踪其健康指标和熔断请求。</p><table><tr><th>属性级别</th><th>默认值、配置方式、配置属性</th></tr><tr><td>全局默认配置</td><td>true</td></tr><tr><td>全局配置</td><td>hystrix.command.default.circuitBreaker.enabled</td></tr><tr><td>实例默认值</td><td>@HystrixProperty(name=”circutBreaker.enabled”,value=”false”)</td></tr><tr><td>实例配置</td><td>hystrix.command.HystrixCommandKey.circuitBreaker.enabled</td></tr></table><p><code>circuitBreaker.requestVolumeThreshold</code>: 该属性用来设置在滚动时间窗中，断路器熔断的最小请求数。例如，默认该值为20 的时候，如果滚动时间窗（默认10秒）内仅收到了19个请求， 即使这19个请求都失败了，断路器也不会打开。</p><table><tr><th>属性级别</th><th>默认值、配置方式、配置属性</th></tr><tr><td>全局默认配置</td><td>20</td></tr><tr><td>全局配置</td><td>hystrix.command.default.circuitBreaker.requestVolumeThreshold</td></tr><tr><td>实例默认值</td><td>@HystrixProperty(name=”circuitBreaker.requestVolumeThreshold”, value=”30”)</td></tr><tr><td>实例配置</td><td>hystrix.comrnand.HystrixComrnandKey.circuitBreaker.requestVolumeThreshold</td></tr></table><p><code>circuitBreaker.sleepWindowinMilliseconds</code>: 该属性用来设置当断路器打开之后的休眠时间窗。休眠时间窗结束之后，会将断路器置为“半开” 状态， 尝试熔断的请求命令，如果依然失败就将断路器继续设置为“打开” 状态，如果成功就设置为“关闭” 状态。</p><table><tr><th>属性级别</th><th>默认值、配置方式、配置属性</th></tr><tr><td>全局默认配置</td><td>5000</td></tr><tr><td>全局配置</td><td>hystrix.command.default.circuitBreaker.sleepWindowinMilliseconds</td></tr><tr><td>实例默认值</td><td>@HystrixProperty(name=”circuitBreaker.sleepWindowinMilliseconds”,value=”3000”)</td></tr><tr><td>实例配置</td><td>hystrix.command.HystrixCommandKey.circuitBreaker.sleepWindowinMilliseconds</td></tr></table><p><code>circuitBreaker.errorThresholdPercentage</code>: 该属性用来设置断路器打开的错误百分比条件。例如，默认值为5000 的情况下，表示在滚动时间窗中，在请求数量超过<code>circuitBreaker.requestVolumeThreshold</code>阅值的前提下，如果错误请求数的百分比超过50, 就把断路器设置为“打开” 状态， 否则就设置为“关闭” 状态。</p><table><tr><th>属性级别</th><th>默认值、配置方式、配置属性</th></tr><tr><td>全局默认配置</td><td>50</td></tr><tr><td>全局配置</td><td>hystrix.command.default.circuitBreaker.errorThresholdPercentage</td></tr><tr><td>实例默认值</td><td>@HystrixProperty(name=”circuitBreaker.errorThresholdPercentage”, value=”40”)</td></tr><tr><td>实例配置</td><td>hystrix.command.HystrixCommandKey.circuitBreaker.errorThresholdPercentage</td></tr></table><p><code>circuitBreaker.forceOpen</code>: 如果将该属性设置为true, 断路器将强制进入“打开” 状态，它会拒绝所有请求。该属性优先于<code>circuitBreaker.forceClosed</code>属性。</p><table><tr><th>属性级别</th><th>默认值、配置方式、配置属性</th></tr><tr><td>全局默认配置</td><td>false</td></tr><tr><td>全局配置</td><td>hystrix.command.default.circuitBreaker.forceOpen</td></tr><tr><td>实例默认值</td><td>@HystrixProperty (name=”circuitBreaker.forceOpen”, value=”true”)</td></tr><tr><td>实例配置</td><td>hystrix.command.HystrixCommandKey.circuitBreaker.forceOpen</td></tr></table><p><code>circuitBreaker.forceClosed</code>: 如果将该属性设置为true, 断路器将强制进入“关闭” 状态， 它会接收所有请求。如果<code>circuitBreaker.forceOpen</code>属性为true, 该属性不会生效。</p><table><tr><th>属性级别</th><th>默认值、配置方式、配置属性</th></tr><tr><td>全局默认配置</td><td>false</td></tr><tr><td>全局配置</td><td>hystrix.command.default.circuitBreaker.forceClosed</td></tr><tr><td>实例默认值</td><td>@HystrixProperty(name=”circui七Breaker.forceClosed”, value=”true”)</td></tr><tr><td>实例配置</td><td>hystrix.comrnand.HystrixComrnandKey.circuitBreaker.forceClosed</td></tr></table><h4 id="metrics配置"><a href="#metrics配置" class="headerlink" title="metrics配置"></a>metrics配置</h4><p>该配置与HystrixCommand执行中捕获的指标信息有关。</p><p><code>metrics.rollingStats.timeinMilliseconds</code>: 该属性用来设置滚动时间窗的长度， 单位为毫秒。该时间用于断路器判断健康度时需要收集信息的持续时间。断路器在收集指标信息的时候会根据设置的时间窗长度拆分成多个“桶” 来累计各度量值，每个“桶” 记录了一段时间内的采集指标。例如，当采用默认值10000毫秒时， 断路器默认将其拆分成10个桶（桶的数量也可通过<code>metrics.rollingStats.numBuckets</code>参数设置），每个桶记录1000毫秒内的指标信息。</p><table><tr><th>属性级别</th><th>默认值、配置方式、配置属性</th></tr><tr><td>全局默认配置</td><td>10000</td></tr><tr><td>全局配置</td><td>hystrix.command.default.metrics.rollingStats.timeinMilliseconds</td></tr><tr><td>实例默认值</td><td>@HystrixProperty(name=”metrics.rollingStats.timeinMilliseconds”,value=”20000”)</td></tr><tr><td>实例配置</td><td>hystrix.command.HystrixCommandKey.metrics.rollingStats.timeinMilliseconds</td></tr></table><p><code>metrics.rollingstats.numBuckets</code>: 该属性用来设置滚动时间窗统计指标信息时划分“桶” 的数量。</p><table><tr><th>属性级别</th><th>默认值、配置方式、配置属性</th></tr><tr><td>全局默认配置</td><td>10</td></tr><tr><td>全局配置</td><td>hystrix.command.default.metrics.rollingStats.numBuckets</td></tr><tr><td>实例默认值</td><td>@HystrixProperty(name=”metrics.rollingStats.numBuckets”,value=”20”)</td></tr><tr><td>实例配置</td><td>hystrix.comrnand.HystrixComrnandKey.metrics.rollingStats.numBuckets</td></tr></table><p><code>metrics.rollingPercentile.enabled</code>: 该属性用来设置对命令执行的延迟是否使用百分位数来跟踪和计算。如果设置为false，那么所有的概要统计都将返回-1。</p><table><tr><th>属性级别</th><th>默认值、配置方式、配置属性</th></tr><tr><td>全局默认配置</td><td>true</td></tr><tr><td>全局配置</td><td>hystrix.command.default.metrics.rollingPercentile.enabled</td></tr><tr><td>实例默认值</td><td>@HystrixProperty(name=”metrics.rollingPercentile.enabled”, value=”false”)</td></tr><tr><td>实例配置</td><td>hystrix.command.HystrixCommandKey.metrics.rollingPercentile.enabled</td></tr></table><p><code>metrics.rollingPercentile.timeinMilliseconds</code>: 该属性用来设置百分位统计的滚动窗口的持续时间，单位为毫秒。</p><table><tr><th>属性级别</th><th>默认值、配置方式、配置属性</th></tr><tr><td>全局默认配置</td><td>60000</td></tr><tr><td>全局配置</td><td>hystrix.command.default.metrics.rollingPercentile.timeinMilliseconds</td></tr><tr><td>实例默认值</td><td>@HystrixProperty(name=”metrics.rollingPercentile.timeinMilliseconds”, value=”50000”)</td></tr><tr><td>实例配置</td><td>hystrix.command.HystrixCommandKey.metrics.rollingPercentile.timeinMilliseconds</td></tr></table><p><code>metrics.rollingPercentile.numBuckets</code>: 该属性用来设置百分位统计滚动窗口中使用“桶”的数量。</p><table><tr><th>属性级别</th><th>默认值、配置方式、配置属性</th></tr><tr><td>全局默认配置</td><td>6</td></tr><tr><td>全局配置</td><td>hystrix.command.default.metrics.rollingPercentile.numBuckets</td></tr><tr><td>实例默认值</td><td>@HystrixProperty(name=”metrics.rollingPercentilee.numBuckets”,value=”5”)</td></tr><tr><td>实例配置</td><td>hystrix.command.HystrixCommandKey.metrics.rollingPercentile.numBuckets</td></tr></table><p><code>metrics.rollingPercentile.bucketSize</code>: 该属性用来设置在执行过程中每个“桶” 中保留的最大执行次数。如果在滚动时间窗内发生超过该设定值的执行次数，就从最初的位置开始重写。例如，将该值设置为100, 滚动窗口为10秒，若在10秒内一个“桶”中发生了500次执行，那么该“桶”中只保留最后的100次执行的统计。另外，增加该值的大小将会增加内存量的消耗，并增加排序百分位数所需的计算时间。</p><table><tr><th>属性级别</th><th>默认值、配置方式、配置属性</th></tr><tr><td>全局默认配置</td><td>100</td></tr><tr><td>全局配置</td><td>hystrix.command.default.metrics.rollingPercentile.bucketSize</td></tr><tr><td>实例默认值</td><td>@HystrixProperty(name=”metrics.rollingPercentile.bucketSize”,value= “120”)</td></tr><tr><td>实例配置</td><td>hystrix.command.HystrixCommandKey.metrics.rollingPercentile.bucketSize</td></tr></table><p><code>metrics.healthSnapshot.intervalinMilliseconds</code>: 该属性用来设置采集影响断路器状态的健康快照（请求的成功、错误百分比）的间隔等待时间。</p><table><tr><th>属性级别</th><th>默认值、配置方式、配置属性</th></tr><tr><td>全局默认配置</td><td>500</td></tr><tr><td>全局配置</td><td>hystrix.comrnand.default.metrics.healthSnapshot.intervalinMilliseconds</td></tr><tr><td>实例默认值</td><td>@HystrixProperty(name=”metrics.healthSnapshot.intervalinMilliseconds”,value=”600”)</td></tr><tr><td>实例配置</td><td>hystrix.command.HystrixCommandKey.metrics.healthSnapshot.intervalinMilliseconds</td></tr></table><h4 id="requestContext"><a href="#requestContext" class="headerlink" title="requestContext"></a>requestContext</h4><p><code>requestCache.enabled</code>: 此属性用来配置是否开启请求缓存。</p><table><tr><th>属性级别</th><th>默认值、配置方式、配置属性</th></tr><tr><td>全局默认配置</td><td>true</td></tr><tr><td>全局配置</td><td>hystrix.command.default.requestCache.enabled</td></tr><tr><td>实例默认值</td><td>@HystrixProperty(name=”requestCache.enabled”, value=”false”)</td></tr><tr><td>实例配置</td><td>hystrix.command.HystrixCommandKey.requestCache.enabled</td></tr></table><h3 id="collapser"><a href="#collapser" class="headerlink" title="collapser"></a>collapser</h3><p><code>maxRequestsinBatch</code>: 该参数用来设置一次请求合并批处理中允许的最大请求数。</p><table><tr><th>属性级别</th><th>默认值、配置方式、配置属性</th></tr><tr><td>全局默认配置</td><td>Integer.MAX_VALUE</td></tr><tr><td>全局配置</td><td>hystrix.collapser.default.maxRequestsinBatch</td></tr><tr><td>实例默认值</td><td>@HystrixProperty(name=”maxRequestsinBatch”,value=”false”)</td></tr><tr><td>实例配置</td><td>hystrix.collapser.HystrixCollapserKey.maxRequestsinBatch</td></tr></table><p><code>timerDelayinMilliseconds</code>: 该参数用来设置批处理过程中每个命令延迟的时间，单位为毫秒。</p><table><tr><th>属性级别</th><th>默认值、配置方式、配置属性</th></tr><tr><td>全局默认配置</td><td>10</td></tr><tr><td>全局配置</td><td>hystrix.collapser.default.timerDelayinMilliseconds</td></tr><tr><td>实例默认值</td><td>@HystrixProperty(name=”timerDelayinMilliseconds”,value=”20”)</td></tr><tr><td>实例配置</td><td>hystrix.collapser.HystrixCollapserKey.timerDelayinMilliseconds</td></tr></table><p><code>request Cache.enabled</code>: 该参数用来设置批处理过程中是否开启请求缓存。</p><table><tr><th>属性级别</th><th>默认值、配置方式、配置属性</th></tr><tr><td>全局默认配置</td><td>true</td></tr><tr><td>全局配置</td><td>hystrix.collapser.default.requestCache.enabled</td></tr><tr><td>实例默认值</td><td>@HystrixProperty(name=”requestCache.enabled”, value=”false”)</td></tr><tr><td>实例配置</td><td>hystrix.collapser.HystrixCollapserKey.requestCache.enabled</td></tr></table><h3 id="threadPool"><a href="#threadPool" class="headerlink" title="threadPool"></a>threadPool</h3><p><code>coreSize</code>: 该参数用来设置执行命令线程池的核心线程数，该值也就是命令执行的最大并发量。</p><table><tr><th>属性级别</th><th>默认值、配置方式、配置属性</th></tr><tr><td>全局默认配置</td><td>10</td></tr><tr><td>全局配置</td><td>hystrix.threadpool.default.coreSize</td></tr><tr><td>实例默认值</td><td>@HystrixProperty(name=”coreSize”, value=”false”)</td></tr><tr><td>实例配置</td><td>hystrix.threadpool.HystrixThreadPoolKey.coreSize</td></tr></table><p><code>maxQueueSize</code>: 该参数用来设置线程池的最大队列大小。当设置为-1时，线程池将使用<code>SynchronousQueue</code>实现的队列，否则将使用<code>LinkedBlockingQueue</code>实现的队列。</p><table><tr><th>属性级别</th><th>默认值、配置方式、配置属性</th></tr><tr><td>全局默认配置</td><td>-1</td></tr><tr><td>全局配置</td><td>hystrix.threadpool.default.maxQueueSize</td></tr><tr><td>实例默认值</td><td>@HystrixProperty(name=”maxQueueSize”,value=”lO”)</td></tr><tr><td>实例配置</td><td>hystrix.threadpool.HystrixThreadPoolKey.maxQueueSize</td></tr></table><p><code>queueSizeRejectionThreshold</code>: 该参数用来为队列设置拒绝阈值。通过该参数，即使队列没有达到最大值也能拒绝请求。该参数主要是对<code>LinkedBlockingQueue</code>队列的补充， 因为<code>LinkedBlockingQueue</code>队列不能动态修改它的对象大小，而通过该属性就可以调整拒绝请求的队列大小了。</p><table><tr><th>属性级别</th><th>默认值、配置方式、配置属性</th></tr><tr><td>全局默认配置</td><td>5</td></tr><tr><td>全局配置</td><td>hystrix.threadpool.default.queueSizeRejectionThreshold</td></tr><tr><td>实例默认值</td><td>@HystrixProperty(name=”queueSizeRejectionThreshold”, value=”lO”</td></tr><tr><td>实例配置</td><td>hystrix.threadpool.HystrixThreadPoolKey.queueSizeRejectionThreshold</td></tr></table><p>不得不说，配置是真的多……</p><p><img src="img/QQ图片20180713111516.gif" alt="QQ图片20180713111516.gif"></p><p>源码链接：<a href="https://github.com/wuyouzhuguli/Spring-Boot-Demos/tree/master/30.Spring-Cloud-Hystrix-Circuit-Breaker" target="_blank" rel="noopener">https://github.com/wuyouzhuguli/Spring-Boot-Demos/tree/master/30.Spring-Cloud-Hystrix-Circuit-Breaker</a></p><blockquote><p>参考文章 <a href="https://book.douban.com/subject/27025912/" target="_blank" rel="noopener">《Spring Cloud微服务实战》</a></p></blockquote><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Thu Mar 21 2019 09:22:44 GMT+0800 (GMT+08:00) --&gt;&lt;p&gt;在微服务的架构中，服务间通常会形成相互依赖的关系，比如现在有三个微服务节点：A，B和C，B为A的消费者，C为B的消费者。假如由于网络波动或者A服务自身故障，导致B调用A服务的线程被挂起进入长时间的等待。在高并发的情况下可能导致B的资源被耗竭随之崩溃，从而导致C服务也不可用。这种连环式的雪崩效应在微服务中较为常见，为了解决这个问题，服务熔断技术应运而出。熔断一词来自电路学，指的是电路在出现短路状况时，“断路器”能够及时地切断故障电路，避免电路过载发热引发火灾。&lt;/p&gt;&lt;p&gt;类似的，微服务架构中的断路器能够及时地发现故障服务，并向服务调用方返回错误响应，而不是长时间的等待。Spring Cloud Hystrix在Hystrix（又是一款由Netflix开发的开源软件，Github地址&lt;a href=&quot;https://github.com/Netflix/Hystrix&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/Netflix/Hystrix&lt;/a&gt;）的基础上进行了封装，提供了服务熔断，服务降级，线程隔离等功能，通过这些功能可以提供服务的容错率。
    
    </summary>
    
    
      <category term="Spring" scheme="http://mrbird.cc/tags/Spring/"/>
    
      <category term="Spring Cloud" scheme="http://mrbird.cc/tags/Spring-Cloud/"/>
    
      <category term="Hystrix" scheme="http://mrbird.cc/tags/Hystrix/"/>
    
  </entry>
  
</feed>
