<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>MrBird</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://mrbird.cc/"/>
  <updated>2018-07-05T01:08:10.721Z</updated>
  <id>http://mrbird.cc/</id>
  
  <author>
    <name>MrBird</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>使用WireMock快速伪造RESTful服务</title>
    <link href="http://mrbird.cc/WireMock-mock-RESTful.html"/>
    <id>http://mrbird.cc/WireMock-mock-RESTful.html</id>
    <published>2018-07-03T13:31:40.000Z</published>
    <updated>2018-07-05T01:08:10.721Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Tue Aug 21 2018 16:24:26 GMT+0800 (中国标准时间) --><p>前后端分离的开发模式已经越来越流行，但是前后端的开发进度并不能完全保持一致，当前端需要调用后端尚未开发的RESTful接口时不得不等待后端开发完毕，这将影响并行开发的效率。<a href="http://wiremock.org" target="_blank" rel="external">http://wiremock.org</a>就是一款用于解决这个问题的开源框架。WireMock可以快速的伪造RESTful接口并返回伪造的JSON数据。这里简单记录下WireMock的使用方法。<a id="more"></a></p><h2 id="搭建WireMock服务器"><a href="#搭建WireMock服务器" class="headerlink" title="搭建WireMock服务器"></a>搭建WireMock服务器</h2><p>我们在本地搭建一个WireMock服务器。通过<a href="http://repo1.maven.org/maven2/com/github/tomakehurst/wiremock-standalone/2.18.0/wiremock-standalone-2.18.0.jar" target="_blank" rel="external">http://repo1.maven.org/maven2/com/github/tomakehurst/wiremock-standalone/2.18.0/wiremock-standalone-2.18.0.jar</a>下载<code>wiremock-standalone-x.xx.xx.jar</code>，然后使用<code>java -jar</code>命令运行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">java -jar wiremock-standalone-2.18.0.jar --port=8080</div></pre></td></tr></table></figure><p></p><p>启动界面： <img src="img/QQ截图20180704165259.png" alt="QQ截图20180704165259.png"></p><h2 id="WireMock的简单使用"><a href="#WireMock的简单使用" class="headerlink" title="WireMock的简单使用"></a>WireMock的简单使用</h2><p>为了方便，我们在Spring Boot环境里进行编写。</p><p>在项目中引入WireMock依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.github.tomakehurst<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>wiremock<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.18.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div></pre></td></tr></table></figure><p></p><p>新建一个MockServer类，包含main方法，并引入<code>com.github.tomakehurst.wiremock.client.WireMock</code>的所有静态方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> <span class="keyword">static</span> com.github.tomakehurst.wiremock.client.WireMock.*;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MockService</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        <span class="comment">// 配置WireMock服务器的地址 http://localhost:8080</span></div><div class="line">        configureFor(<span class="string">"127.0.0.1"</span>, <span class="number">8080</span>);</div><div class="line">        <span class="comment">// 清除WireMock服务器里之前的配置</span></div><div class="line">        removeAllMappings();</div><div class="line"></div><div class="line">        <span class="comment">//伪造一个get请求，请求地址为 /user/1，然后返回体包含JSON数据，状态为200</span></div><div class="line">        stubFor(get(urlEqualTo(<span class="string">"/user/1"</span>))</div><div class="line">                .willReturn(aResponse()</div><div class="line">                        .withBody(<span class="string">"&#123;\"name\":\"mrbird\",\"url\":\"https://mrbird.cc\",\"age\":18&#125;"</span>)</div><div class="line">                        .withStatus(<span class="number">200</span>)));</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p></p><p>上面代码主要分为三个步骤：</p><ol><li><p>使用<code>configureFor</code>方法配置WireMock服务器的地址为<code>http://localhost:8080</code>；</p></li><li><p>调用<code>removeAllMappings</code>清除WireMock服务器里所有配置；</p></li><li><p>调用<code>stubFor</code>打桩，并模拟了一个HTTP GET请求，然后返回200状态码，返回报文头部包含JSON信息。这里URL使用方法<code>urlEqualTo</code>全匹配，WireMock也提供了正则表达式匹配URL的方法。</p></li></ol><p>在配置完了后运行main方法，就可以将我们的配置写到WireMock服务器里，这时候在浏览器中调用<a href="http://localhost:8080/user/1" target="_blank" rel="external">http://localhost:8080/user/1</a>便能看到我们模拟的输出结果：</p><p><img src="img/QQ截图20180705085004.png" alt="QQ截图20180705085004.png"></p><p>这里推荐个在线JSON编辑器：<a href="https://www.bejson.com/jsoneditoronline/" target="_blank" rel="external">https://www.bejson.com/jsoneditoronline/</a>。</p><h2 id="简单封装"><a href="#简单封装" class="headerlink" title="简单封装"></a>简单封装</h2><p>我们可以对上面的代码进行简单的封装，方便重用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> org.apache.commons.io.FileUtils;</div><div class="line"><span class="keyword">import</span> org.apache.commons.lang3.StringUtils;</div><div class="line"><span class="keyword">import</span> org.springframework.core.io.ClassPathResource;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">getMock</span><span class="params">(String url, String file)</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">    ClassPathResource resource = <span class="keyword">new</span> ClassPathResource(<span class="string">"mock/response/"</span> + file);</div><div class="line">    String content = StringUtils.join(FileUtils.readLines(resource.getFile(), <span class="string">"UTF-8"</span>).toArray(), <span class="string">"\n"</span>);</div><div class="line">    stubFor(get(urlPathEqualTo(url)).willReturn(aResponse().withBody(content).withStatus(<span class="number">200</span>)));</div><div class="line">&#125;</div></pre></td></tr></table></figure><p></p><p>上面代码封装了一个<code>getMock</code>方法，用于处理<code>get</code>类型的Mock，参数为模拟URL和模拟JSON文件。</p><p>我们在<code>src/main/resource/mock/response</code>目录下创建一个user.json文件：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  <span class="attr">"name"</span>: <span class="string">"mrbird"</span>,</div><div class="line">  <span class="attr">"url"</span>: <span class="string">"https://mrbird.cc"</span>,</div><div class="line">  <span class="attr">"age"</span>: <span class="number">18</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><p></p><p>后面我们只需要像下面这样调用就行了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">getMock(<span class="string">"/user/1"</span>, <span class="string">"user.json"</span>);</div></pre></td></tr></table></figure><p></p><p>WireMock还提供了许多别的功能，具体可以参考官方文档 <a href="http://wiremock.org/docs/" target="_blank" rel="external">http://wiremock.org/docs/</a>。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Tue Aug 21 2018 16:24:26 GMT+0800 (中国标准时间) --&gt;&lt;p&gt;前后端分离的开发模式已经越来越流行，但是前后端的开发进度并不能完全保持一致，当前端需要调用后端尚未开发的RESTful接口时不得不等待后端开发完毕，这将影响并行开发的效率。&lt;a href=&quot;http://wiremock.org&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://wiremock.org&lt;/a&gt;就是一款用于解决这个问题的开源框架。WireMock可以快速的伪造RESTful接口并返回伪造的JSON数据。这里简单记录下WireMock的使用方法。
    
    </summary>
    
    
      <category term="WireMock" scheme="http://mrbird.cc/tags/WireMock/"/>
    
  </entry>
  
  <entry>
    <title>Spring Cloud Feign 声明式服务调用</title>
    <link href="http://mrbird.cc/Spring-Cloud-Feign-%20Declarative-REST-Client.html"/>
    <id>http://mrbird.cc/Spring-Cloud-Feign- Declarative-REST-Client.html</id>
    <published>2018-06-10T10:35:03.000Z</published>
    <updated>2018-08-21T08:06:46.687Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Tue Aug 21 2018 16:24:25 GMT+0800 (中国标准时间) --><p>前面我们分别通过Spring Cloud Ribbon和Spring Cloud Hystrix实现了客户端负载均衡和服务容错，而Spring Cloud Feign不但整合了这两者的功能，而且还提供了一种比Ribbon更简单的服务调用方式 ——— 声明式服务调用。在Spring Cloud Feign中编写服务调用代码非常简单，几乎可以直接将服务提供者的代码复制过来，改为接口即可，下面通过例子来演示这个特性。<a id="more"></a></p><h2 id="搭建Feign-Consumer"><a href="#搭建Feign-Consumer" class="headerlink" title="搭建Feign Consumer"></a>搭建Feign Consumer</h2><p>创建一个新的Spring Boot应用，版本为<code>1.5.13.RELEASE</code>，<code>artifactId</code>改为<code>Feign-Consumer</code>，并引入下面这些依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>Edgware.SR3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-eureka<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-feign<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></div></pre></td></tr></table></figure><p></p><p>除了<code>spring-cloud-starter-feign</code>依赖外，我们还引入了<code>spring-cloud-starter-eureka</code>，目的是为了从Eureka服务注册中心获取服务。</p><p>在Spring Boot的入口类中加入<code>@EnableFeignClients</code>和<code>@EnableDiscoveryClient</code>注解，用于开启Spring Cloud Feign和服务注册与发现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@EnableDiscoveryClient</span></div><div class="line"><span class="meta">@EnableFeignClients</span></div><div class="line"><span class="meta">@SpringBootApplication</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoApplication</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        SpringApplication.run(DemoApplication.class, args);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p></p><p>在前面几节中，我们曾在服务提供者Eureka-Client中定义了一个UserController，代码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@RestController</span></div><div class="line"><span class="meta">@RequestMapping</span>(<span class="string">"user"</span>)</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> Logger log = LoggerFactory.getLogger(<span class="keyword">this</span>.getClass());</div><div class="line"></div><div class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/&#123;id:\\d+&#125;"</span>)</div><div class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">get</span><span class="params">(@PathVariable Long id)</span> </span>&#123;</div><div class="line">        log.info(<span class="string">"获取用户id为 "</span> + id + <span class="string">"的信息"</span>);</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> User(id, <span class="string">"mrbird"</span>, <span class="string">"123456"</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@GetMapping</span></div><div class="line">    <span class="function"><span class="keyword">public</span> List&lt;User&gt; <span class="title">get</span><span class="params">()</span> </span>&#123;</div><div class="line">        List&lt;User&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">        list.add(<span class="keyword">new</span> User(<span class="number">1L</span>, <span class="string">"mrbird"</span>, <span class="string">"123456"</span>));</div><div class="line">        list.add(<span class="keyword">new</span> User(<span class="number">2L</span>, <span class="string">"scott"</span>, <span class="string">"123456"</span>));</div><div class="line">        log.info(<span class="string">"获取用户信息 "</span> + list);</div><div class="line">        <span class="keyword">return</span> list;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@PostMapping</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(@RequestBody User user)</span> </span>&#123;</div><div class="line">        log.info(<span class="string">"新增用户成功 "</span> + user);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@PutMapping</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(@RequestBody User user)</span> </span>&#123;</div><div class="line">        log.info(<span class="string">"更新用户成功 "</span> + user);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@DeleteMapping</span>(<span class="string">"/&#123;id:\\d+&#125;"</span>)</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">(@PathVariable Long id)</span> </span>&#123;</div><div class="line">        log.info(<span class="string">"删除用户成功 "</span> + id);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p></p><p>在Spring Cloud Ribbon中访问这些服务需要通过<code>RestTemplate</code>对象来实现，并且参数绑定的过程也比较繁琐。Spring Cloud Feign对这个步骤进行了进一步的封装，在Feign Consumer中调用这些服务只需要定义一个UserService接口，然后将UserController中的代码复制过并将方法体去掉即可，如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@FeignClient</span>(<span class="string">"Server-Provider"</span>)</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserService</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@GetMapping</span>(<span class="string">"user/&#123;id&#125;"</span>)</div><div class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">get</span><span class="params">(@PathVariable(<span class="string">"id"</span>)</span> Long id)</span>;</div><div class="line"></div><div class="line">    <span class="meta">@GetMapping</span>(<span class="string">"user"</span>)</div><div class="line">    <span class="function"><span class="keyword">public</span> List&lt;User&gt; <span class="title">get</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">    <span class="meta">@PostMapping</span>(<span class="string">"user"</span>)</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(@RequestBody User user)</span></span>;</div><div class="line"></div><div class="line">    <span class="meta">@PutMapping</span>(<span class="string">"user"</span>)</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(@RequestBody User user)</span></span>;</div><div class="line"></div><div class="line">    <span class="meta">@DeleteMapping</span>(<span class="string">"user/&#123;id&#125;"</span>)</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">(@PathVariable(<span class="string">"id"</span>)</span> Long id)</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p></p><p>对比Feign Consumer中的UserService和Eureka-Client中UserController代码，两者是不是很相似？</p><p>在UserService中，我们通过<code>@FeignClient(&quot;Server-Provider&quot;)</code>注解来获取我们需要的服务，其中<code>Server-Provider</code>不区分大小写。需要注意的是，在定义各参数绑定时，<code>@RequestParam</code>、<code>@RequestHeader</code>等可 以指定参数名称的注解，它们的value千万不能少。在SpringMVC 程序中，这些注解会根据参数名来作为默认值，但是在Feign中绑定参数必须通过value属性来指明具体的参数名，不然会抛出<code>illegalStateException</code>异常，value 属性不能为空。</p><p>接下来我们在Feign Consumer中定义一个TestController，来调用UserService中定义的服务：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@RestController</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestController</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@Autowired</span></div><div class="line">    <span class="keyword">private</span> UserService userService;</div><div class="line"></div><div class="line">    <span class="meta">@GetMapping</span>(<span class="string">"user/&#123;id&#125;"</span>)</div><div class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">getUser</span><span class="params">(@PathVariable Long id)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> userService.get(id);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@GetMapping</span>(<span class="string">"user"</span>)</div><div class="line">    <span class="function"><span class="keyword">public</span> List&lt;User&gt; <span class="title">getUsers</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> userService.get();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@PostMapping</span>(<span class="string">"user"</span>)</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addUser</span><span class="params">()</span> </span>&#123;</div><div class="line">        User user = <span class="keyword">new</span> User(<span class="number">1L</span>, <span class="string">"mrbird"</span>, <span class="string">"123456"</span>);</div><div class="line">        userService.add(user);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@PutMapping</span>(<span class="string">"user"</span>)</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateUser</span><span class="params">()</span> </span>&#123;</div><div class="line">        User user = <span class="keyword">new</span> User(<span class="number">1L</span>, <span class="string">"mrbird"</span>, <span class="string">"123456"</span>);</div><div class="line">        userService.update(user);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@DeleteMapping</span>(<span class="string">"user/&#123;id&#125;"</span>)</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteUser</span><span class="params">(@PathVariable Long id)</span> </span>&#123;</div><div class="line">        userService.delete(id);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p></p><p>最后配置一下application.yml：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="attr">server:</span></div><div class="line"><span class="attr">  port:</span> <span class="number">9000</span></div><div class="line">  </div><div class="line"><span class="attr">spring:</span></div><div class="line"><span class="attr">  application:</span></div><div class="line"><span class="attr">    name:</span> <span class="string">Server-Consumer</span></div><div class="line">    </div><div class="line"><span class="attr">eureka:</span></div><div class="line"><span class="attr">  client:</span></div><div class="line"><span class="attr">    serviceUrl:</span></div><div class="line"><span class="attr">      defaultZone:</span> <span class="attr">http://mrbird:123456@peer1:8080/eureka/,http://mrbird:123456@peer2:8081/eureka/</span></div></pre></td></tr></table></figure><p></p><p>上面配置指定了Eureka服务注册中心的地址，用于获取服务。</p><p>最后我们分别启动以下服务：</p><ol><li><p>启动Eureka-Server集群，端口号为8080和8081；</p></li><li><p>启动两个Eureka-Client，端口号为8082和8083；</p></li><li><p>启动Feign-Consumer，端口号为9000。</p></li></ol><p>多次访问<a href="http://localhost:9000/user/1" target="_blank" rel="external">http://localhost:9000/user/1</a>服务，观察8082和8083服务的控制台：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">2018-06-10 14:27:38.105  INFO 10120 --- [nio-8082-exec-8] c.e.demo.controller.UserController       : 获取用户id为 1的信息</div><div class="line">2018-06-10 14:27:39.989  INFO 10120 --- [nio-8082-exec-7] c.e.demo.controller.UserController       : 获取用户id为 1的信息</div><div class="line">2018-06-10 14:27:41.197  INFO 10120 --- [nio-8082-exec-6] c.e.demo.controller.UserController       : 获取用户id为 1的信息</div><div class="line">2018-06-10 14:27:41.802  INFO 10120 --- [nio-8082-exec-5] c.e.demo.controller.UserController       : 获取用户id为 1的信息</div><div class="line">2018-06-10 14:27:42.224  INFO 10120 --- [nio-8082-exec-4] c.e.demo.controller.UserController       : 获取用户id为 1的信息</div><div class="line">2018-06-10 14:27:42.865  INFO 10120 --- [nio-8082-exec-3] c.e.demo.controller.UserController       : 获取用户id为 1的信息</div><div class="line">2018-06-10 14:27:43.296  INFO 10120 --- [nio-8082-exec-2] c.e.demo.controller.UserController       : 获取用户id为 1的信息</div><div class="line"></div><div class="line">2018-06-10 14:27:38.358  INFO 9104 --- [nio-8083-exec-8] c.e.demo.controller.UserController       : 获取用户id为 1的信息</div><div class="line">2018-06-10 14:27:40.754  INFO 9104 --- [nio-8083-exec-7] c.e.demo.controller.UserController       : 获取用户id为 1的信息</div><div class="line">2018-06-10 14:27:41.397  INFO 9104 --- [nio-8083-exec-6] c.e.demo.controller.UserController       : 获取用户id为 1的信息</div><div class="line">2018-06-10 14:27:42.006  INFO 9104 --- [nio-8083-exec-5] c.e.demo.controller.UserController       : 获取用户id为 1的信息</div><div class="line">2018-06-10 14:27:42.445  INFO 9104 --- [nio-8083-exec-4] c.e.demo.controller.UserController       : 获取用户id为 1的信息</div><div class="line">2018-06-10 14:27:43.073  INFO 9104 --- [nio-8083-exec-3] c.e.demo.controller.UserController       : 获取用户id为 1的信息</div></pre></td></tr></table></figure><p></p><p>使用Feign实现的消费者，依然是利用Ribbon维护了针对Seriver-Provider的服务列表信息，并且通过轮询实现了客户端负载均衡。而与Ribbon不同的是，通过Feign我们只需定义服务绑定接口，以声明式的方法，优雅而简单地实现了服务调用。</p><h2 id="Ribbon相关配置"><a href="#Ribbon相关配置" class="headerlink" title="Ribbon相关配置"></a>Ribbon相关配置</h2><p>Spring Cloud Feign内部的客户端负载均衡是通过Ribbon来实现的，所以在Spring Cloud Feign中配置Ribbon，和之前在<a href="/Spring-Cloud-Ribbon-LoadBalance.html">Spring Cloud Ribbon客户端负载均衡</a>中介绍的Spring Cloud Ribbon配置一样，这里不再赘述。</p><h2 id="Hystrix相关配置"><a href="#Hystrix相关配置" class="headerlink" title="Hystrix相关配置"></a>Hystrix相关配置</h2><p>要在Spring Cloud Feign中开启Hystrix，可以在yml中添加如下配置：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="attr">feign:</span></div><div class="line"><span class="attr">  hystrix:</span></div><div class="line"><span class="attr">    enabled:</span> <span class="literal">true</span></div></pre></td></tr></table></figure><p></p><p>剩下的Hystrix配置和之前在<a href="/Spring-Cloud-Hystrix-Circuit-Breaker.html">Spring Cloud Hystrix服务容错</a>中介绍的Hystrix属性配置一样。</p><p>在Spring Cloud Feign中配置服务降级和在Spring Cloud Hystrix中配置服务降级区别很大，下面具体来看下怎么在Feign-Consumer中配置服务降级。</p><p>定义一个用于处理服务降级方法的类UserServiceFallback，并且实现上面定义的UserService接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Component</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceFallback</span> <span class="keyword">implements</span> <span class="title">UserService</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> Logger log = LoggerFactory.getLogger(<span class="keyword">this</span>.getClass());</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">get</span><span class="params">(Long id)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> User(-<span class="number">1L</span>, <span class="string">"default"</span>, <span class="string">"123456"</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> List&lt;User&gt; <span class="title">get</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(User user)</span> </span>&#123;</div><div class="line">        log.info(<span class="string">"test fallback"</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(User user)</span> </span>&#123;</div><div class="line">        log.info(<span class="string">"test fallback"</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">(Long id)</span> </span>&#123;</div><div class="line">        log.info(<span class="string">"test fallback"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p></p><p>在UserService的中通过<code>@FeignClient</code>注解的<code>fallback</code>属性来指定对应的服务降级实现类:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@FeignClient</span>(value = <span class="string">"Server-Provider"</span>, fallback = UserServiceFallback.class)</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserService</span> </span>&#123;</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure><p></p><p>重启Feign-Consumer，并关闭Eureka Client服务，访问<a href="http://localhost:9000/user/1" target="_blank" rel="external">http://localhost:9000/user/1</a>，由于Eureka-Client服务提供者都关闭了，所以这里会直接触发服务降级，响应结果如下：</p><p><img src="img/QQ截图20180720164914.png" alt="QQ截图20180720164914.png"></p><p>可看到响应信息为服务降级方法中的返回结果。</p><h2 id="其余Feign配置"><a href="#其余Feign配置" class="headerlink" title="其余Feign配置"></a>其余Feign配置</h2><p>除了Ribbon和Hystrix配置之外，Feign也有一些自个儿的配置。</p><h3 id="请求压缩"><a href="#请求压缩" class="headerlink" title="请求压缩"></a>请求压缩</h3><p>Spring Cloud Feign支持对请求与响应进行GZIP压缩，以减少通信过程中的性能损耗：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="attr">feign:</span></div><div class="line"><span class="attr">  compression:</span></div><div class="line"><span class="attr">    request:</span></div><div class="line"><span class="attr">      enabled:</span> <span class="literal">true</span></div><div class="line"><span class="attr">    response:</span></div><div class="line"><span class="attr">      enabled:</span> <span class="literal">true</span></div></pre></td></tr></table></figure><p></p><p>同时，我们还能对请求压缩做一些更细致的设置，比如下面的配置内容指定了压缩的请求数据类型，并设置了请求压缩的大小下限，只有超过这个大小的请求才会对其进行压缩:</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="attr">feign:</span></div><div class="line"><span class="attr">  compression:</span></div><div class="line"><span class="attr">    request:</span></div><div class="line"><span class="attr">      enabled:</span> <span class="literal">true</span></div><div class="line"><span class="attr">      mime-types:</span> <span class="string">text/xml,application/xml,application/json</span></div><div class="line"><span class="attr">      min-request-size:</span> <span class="number">2048</span></div></pre></td></tr></table></figure><p></p><h3 id="日志配置"><a href="#日志配置" class="headerlink" title="日志配置"></a>日志配置</h3><p>Feign提供了日志打印的功能，Feign的日志级别分为四种：</p><ul><li><p><code>NONE</code>: 不记录任何信息。</p></li><li><p><code>BASIC</code>: 仅记录请求方法、<code>URL</code>以及响应状态码和执行时间。</p></li><li><p><code>HEADERS</code>: 除了记录<code>BASIC</code>级别的信息之外，还会记录请求和响应的头信息。</p></li><li><p><code>FULL</code>: 记录所有请求与响应的明细，包括头信息、请求体、元数据等。</p></li></ul><p>日志级别默认为<code>NONE</code>，要改变级别可以在入口类中定义一个日志配置Bean：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@EnableDiscoveryClient</span></div><div class="line"><span class="meta">@EnableFeignClients</span></div><div class="line"><span class="meta">@SpringBootApplication</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoApplication</span> </span>&#123;</div><div class="line">    <span class="meta">@Bean</span></div><div class="line">    Logger.<span class="function">Level <span class="title">feignLoggerLevel</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> Logger.Level.FULL;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        SpringApplication.run(DemoApplication.class, args);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p></p><p>然后在yml中配置Feign客户端的日志级别为debug，Feign日志记录仅响应debug级别：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="attr">logging:</span></div><div class="line"><span class="attr">  level:</span></div><div class="line"><span class="attr">    com:</span></div><div class="line"><span class="attr">      example:</span></div><div class="line"><span class="attr">        demo:</span></div><div class="line"><span class="attr">          service:</span></div><div class="line"><span class="attr">            UserService:</span> <span class="string">debug</span></div></pre></td></tr></table></figure><p></p><p>重启项目访问<a href=""></a>，可以看到控制台打印日志如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">[UserService#get] &lt;--- HTTP/1.1 200 (506ms)</div><div class="line">[UserService#get] content-type: application/json;charset=UTF-8</div><div class="line">[UserService#get] date: Stu, 10 Jun 2018 01:44:45 GMT</div><div class="line">[UserService#get] transfer-encoding: chunked</div><div class="line">[UserService#get] </div><div class="line">[UserService#get] &#123;&quot;id&quot;:1,&quot;username&quot;:&quot;mrbird&quot;,&quot;password&quot;:&quot;123456&quot;&#125;</div><div class="line">[UserService#get] &lt;--- END HTTP (48-byte body)</div><div class="line">Flipping property: Server-Provider.ribbon.ActiveConnectionsLimit to use NEXT property: niws.loadbalancer.availabilityFilteringRule.activeConnectionsLimit = 2147483647</div></pre></td></tr></table></figure><p></p><blockquote><p>源码链接 <a href="https://github.com/wuyouzhuguli/Spring-Boot-Demos/tree/master/33.Spring-Cloud-Feign-Declarative-REST-Client" target="_blank" rel="external">https://github.com/wuyouzhuguli/Spring-Boot-Demos/tree/master/33.Spring-Cloud-Feign-Declarative-REST-Client</a></p></blockquote><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Tue Aug 21 2018 16:24:25 GMT+0800 (中国标准时间) --&gt;&lt;p&gt;前面我们分别通过Spring Cloud Ribbon和Spring Cloud Hystrix实现了客户端负载均衡和服务容错，而Spring Cloud Feign不但整合了这两者的功能，而且还提供了一种比Ribbon更简单的服务调用方式 ——— 声明式服务调用。在Spring Cloud Feign中编写服务调用代码非常简单，几乎可以直接将服务提供者的代码复制过来，改为接口即可，下面通过例子来演示这个特性。
    
    </summary>
    
    
      <category term="Spring" scheme="http://mrbird.cc/tags/Spring/"/>
    
      <category term="Spring Cloud" scheme="http://mrbird.cc/tags/Spring-Cloud/"/>
    
      <category term="Feign" scheme="http://mrbird.cc/tags/Feign/"/>
    
  </entry>
  
  <entry>
    <title>Spring Cloud Hystrix Dashboard仪表盘</title>
    <link href="http://mrbird.cc/Spring-Cloud-Hystrix-Dashboard.html"/>
    <id>http://mrbird.cc/Spring-Cloud-Hystrix-Dashboard.html</id>
    <published>2018-06-07T01:07:46.000Z</published>
    <updated>2018-08-21T08:05:03.288Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Tue Aug 21 2018 16:24:25 GMT+0800 (中国标准时间) --><p>Hystrix提供了Hystrix Dashboard来实时监控Hystrix的运行情况，通过Hystrix Dashboard反馈的实时信息，可以帮助我们快速发现系统中存在的问题，从而及时地采取应对措施。Spring Cloud对Hystrix Dashboard进行了整合，这里将介绍如何使用Hystrix Dashboard监控单个和多个Hystrix实例。<a id="more"></a></p><h2 id="监控单个Hystrix实例"><a href="#监控单个Hystrix实例" class="headerlink" title="监控单个Hystrix实例"></a>监控单个Hystrix实例</h2><p>创建一个Spring Boot项目，Spring Boot版本为<code>1.5.13.RELEASE</code>，<code>artifactId</code>填Hystrix-Dashboard，然后引入如下依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>Edgware.SR3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-hystrix<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-hystrix-dashboard<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></div></pre></td></tr></table></figure><p></p><p>稍微配置下yml：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="attr">spring:</span></div><div class="line"><span class="attr">  application:</span></div><div class="line"><span class="attr">    name:</span> <span class="string">Hystrix-Dashboard</span></div><div class="line"><span class="attr">server:</span></div><div class="line"><span class="attr">  port:</span> <span class="number">9002</span></div></pre></td></tr></table></figure><p></p><p>然后在入口类上加入注解<code>@EnableHystrixDashboard</code>来启用Hystrix Dashboard的功能。启动项目访问<a href="http://localhost:9002/hystrix" target="_blank" rel="external">http://localhost:9002/hystrix</a>就可以看到如下页面了：</p><p><img src="img/QQ截图20180713143306.png" alt="QQ截图20180713143306.png"></p><p>可以看到页面上提供了三种监控的模式：Cluster via Turbine(default cluster)、Cluster via Turbine(custom cluster)和Single Hystrix App：</p><p>前两种都是集群监控的，下面再介绍，这里先介绍第三种单机监控。</p><p>在上一节<a href="/Spring-Cloud-Hystrix-Circuit-Breaker.html">Spring Cloud Hystrix服务容错</a>的基础上，要对Ribbon-Consumer进行监控还必须加入<code>spring-boot-starter-actuator</code>依赖，然后分别启动Eureka-Serve集群，Eureka-Client，Ribbon-Consumer，启动后在刚刚的监控页面上输入：<a href="http://localhost:9000/hystrix.stream" target="_blank" rel="external">http://localhost:9000/hystrix.stream </a>，然后往Ribbon-Consumer发几条请求，便可以看到如下监控页面：</p><p><img src="img/QQ截图20180713145843.png" alt="QQ截图20180713145843.png"></p><p>至于这张图上面的指标代表什么含义，我们可以参考官方给的图例：</p><p><img src="img/dashboard-annoted-circuit-640.png" alt="dashboard-annoted-circuit-640.png"></p><p>到这里我们已经实现了使用Hystrix Dashboard对单个Hystrix实例进行监控了，然而实际中一般会有多个Hystrix实例需要同时进行监控，下面我们使用Turbine来实现集群监控。</p><h2 id="Turbine集群监控"><a href="#Turbine集群监控" class="headerlink" title="Turbine集群监控"></a>Turbine集群监控</h2><p>使用Turbine实现对Hystrix的集群监控的思路是：Turbine从Eureka服务注册中心通过服务名Ribbon-Consumer获取服务实例，然后Hystrix Dashboard对Turbine进行监控，这样就实现了Hystrix Dashboard同时对多个Hystrix（Ribbon-consumer）实例同时进行监控的功能。</p><p>创建一个Spring Boot项目，Spring Boot版本为<code>1.5.13.RELEASE</code>，<code>artifactId</code>填Turbine，然后引入如下依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>Edgware.SR3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-turbine<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-eureka<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></div></pre></td></tr></table></figure><p></p><p>然后在入口类中加入<code>@EnableTurbine</code>来开启Turbine的功能，并且加入<code>@EnableDiscoveryClient</code>注解，开启服务获取功能。</p><p>最后在yml中加入一些配置：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="attr">spring:</span></div><div class="line"><span class="attr">  application:</span></div><div class="line"><span class="attr">    name:</span> <span class="string">Turbine</span></div><div class="line"><span class="attr">server:</span></div><div class="line"><span class="attr">  port:</span> <span class="number">9003</span></div><div class="line"></div><div class="line"><span class="attr">eureka:</span></div><div class="line"><span class="attr">  client:</span></div><div class="line"><span class="attr">    serviceUrl:</span></div><div class="line"><span class="attr">      defaultZone:</span> <span class="attr">http://mrbird:123456@peer1:8080/eureka/,http://mrbird:123456@peer2:8081/eureka/</span></div><div class="line"><span class="attr">turbine:</span></div><div class="line"><span class="attr">  app-config:</span> <span class="string">Ribbon-Consumer</span></div><div class="line"><span class="attr">  cluster-name-expression:</span> <span class="string">new</span> <span class="string">String('default')</span></div><div class="line"><span class="attr">  combine-host-port:</span> <span class="literal">true</span></div></pre></td></tr></table></figure><p></p><p>上面配置了Eureka-Server的集群地址，并且指定了端口号为9003，应用名称为Turbine。剩下的配置为Turbine的配置，含义如下：</p><ul><li><p><code>turbine.app-config</code>指定了需要收集监控信息的服务名，这里为Ribbon-Consumer；</p></li><li><p><code>turbine.cluster-name-expression</code>参数指定了集群名称为default, 当服务数量非常多的时候，可以启动多个Turbine 服务来构建不同的聚合集群， 而该参数可以用来区分这些不同的聚合集群，同时该参数值可以在Hystrix仪表盘中用来定位不同的聚合集群，只需在Hystrix Stream的URL中通过cluster参数来指定(即Cluster via Turbine(custom cluster))；</p></li><li><p><code>turbine.combine-host-port</code>参数设置为七rue, 可以让同一主机上的服务通过主机名与端口号的组合来进行区分， 默认情况下会以host来区分不同的服务，这会使得在本地调试的时候，本机上的不同服务聚合成一个服务来统计。</p></li></ul><p>配置完毕后，我们分别启动下面这些服务：</p><ol><li><p>启动Eureka-Server集群，端口号为8080和8081；</p></li><li><p>启动一个Eureka-Client，端口号为8082；</p></li><li><p>启动两个Ribbon-Consumer，端口号为9000和9001；</p></li><li><p>启动Turbine服务，端口号为9003；</p></li><li><p>最后启动Hystrix-Dashboard服务，端口号为9002。</p></li></ol><p>启动好这些服务后，访问Eureka-server的<a href="http://localhost:8080" target="_blank" rel="external">http://localhost:8080</a>可看到这些实例：</p><p><img src="img/QQ截图20180713155602.png" alt="QQ截图20180713155602.png"></p><p>说明服务都已启动成功，我们观察Turbine的控制台，可以看到如下日志信息：</p><p><img src="img/QQ截图20180713160919.png" alt="QQ截图20180713160919.png"></p><p>即Turbine已经从服务注册中心找到了9000和9001端口的Ribbon-Consumer实例。</p><p>这时候我们访问Hystrix-dashboard的地址<a href="http://localhost:9002/hystrix" target="_blank" rel="external">http://localhost:9002/hystrix</a>，在页面的地址栏输入<a href="http://localhost:9003/turbine.stream" target="_blank" rel="external">http://localhost:9003/turbine.stream</a>，然后分别往9000和9001端口的Ribbon-Consumer实例发送一些请求，这时候可以看到Dashboard的画面如下：</p><p><img src="img/QQ截图20180713155511.png" alt="QQ截图20180713155511.png"></p><p>可以看到Hosts的值已经是2了，并且由于两个Hystrix实例的名称都是Ribbon-Consumer，所以Turbine 会将相同名称的服务作为整体来看待，汇总成一个监控图。</p><p>源码链接：<a href="https://github.com/wuyouzhuguli/Spring-Boot-Demos/tree/master/31.Spring-Cloud-Hystrix-Dashboard-Turbine" target="_blank" rel="external">https://github.com/wuyouzhuguli/Spring-Boot-Demos/tree/master/31.Spring-Cloud-Hystrix-Dashboard-Turbine</a></p><h3 id="使用消息中间件"><a href="#使用消息中间件" class="headerlink" title="使用消息中间件"></a>使用消息中间件</h3><p>除了直接用Turbine从服务注册中心获取Ribbon-Consumer实例监控数据外，还可以将Ribbon-Consumer的监控数据发送到消息中间件，然后Turbine从消息中间件中获取。这里我们选择RabbitMQ作为消息中间件。</p><p>在安装RabbitMQ之前，需要先安装Erlang/OTP，下载地址为：<a href="http://www.erlang.org/downloads/" target="_blank" rel="external">http://www.erlang.org/downloads/</a>，下载exe文件安装即可。</p><p>安装完毕后，下载RabbitMQ，下载地址为<a href="http://www.rabbitmq.com/install-windows.html" target="_blank" rel="external">http://www.rabbitmq.com/install-windows.html</a>，下载exe文件安装即可。</p><p>安装完RabbitMQ之后，我们到RabbitMQ安装目录的sbin下执行如下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">rabbitmq-plugins <span class="built_in">enable</span> rabbitmq_management</div></pre></td></tr></table></figure><p></p><p>然后在浏览器中输入<a href="http://localhost:15672" target="_blank" rel="external">http://localhost:15672</a>，用户名和密码都是guest，登录后可看到：</p><p><img src="img/QQ截图20180713164756.png" alt="QQ截图20180713164756.png"></p><p>说明启动成功。</p><p>接下来我们对Ribbon-Consumer进行改造，实现其将监控信息输出到RabbitMQ，在pom中添加如下依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-netflix-hystrix-stream<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-stream-rabbit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div></pre></td></tr></table></figure><p></p><p>修改Ribbon-Consumer的yml配置文件，加入RabbitMQ的连接配置：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="attr">spring:</span></div><div class="line"><span class="attr">  rabbitmq:</span></div><div class="line"><span class="attr">    host:</span> <span class="string">localhost</span></div><div class="line"><span class="attr">    port:</span> <span class="number">5672</span></div><div class="line"><span class="attr">    username:</span> <span class="string">guest</span></div><div class="line"><span class="attr">    password:</span> <span class="string">guest</span></div></pre></td></tr></table></figure><p></p><p>最后我们来修改Turbine，让其从RabbitMQ中读取监控信息。在Turbine项目中引入如下依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-turbine-stream<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-stream-rabbit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div></pre></td></tr></table></figure><p></p><p>同时删除<code>spring-cloud-starter-eureka</code>和<code>spring-cloud-starter-turbine</code>依赖，因为我们不再从服务注册中心去获取监控的服务信息了，并且<code>spring-cloud-starter-turbine-stream</code>已经包含了<code>spring-cloud-starter-turbine</code>依赖。</p><p>修改Turbine的入口类，删除<code>@EnableTurbine</code>和<code>@EnableDiscoveryClient</code>注解，添加<code>@EnableTurbineStream</code>注解。</p><p>将Turbine的yml配置修改为：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="attr">spring:</span></div><div class="line"><span class="attr">  application:</span></div><div class="line"><span class="attr">    name:</span> <span class="string">Turbine</span></div><div class="line"><span class="attr">  rabbitmq:</span></div><div class="line"><span class="attr">      host:</span> <span class="string">localhost</span></div><div class="line"><span class="attr">      port:</span> <span class="number">5672</span></div><div class="line"><span class="attr">      username:</span> <span class="string">guest</span></div><div class="line"><span class="attr">      password:</span> <span class="string">guest</span></div><div class="line"><span class="attr">server:</span></div><div class="line"><span class="attr">  port:</span> <span class="number">9003</span></div></pre></td></tr></table></figure><p></p><p>修改完毕后，我们分别启动下面这些服务：</p><ol><li><p>启动Eureka-Server集群，端口号为8080和8081；</p></li><li><p>启动一个Eureka-Client，端口号为8082；</p></li><li><p>启动两个Ribbon-Consumer，端口号为9000和9001；</p></li><li><p>启动Turbine服务，端口号为9003；</p></li><li><p>最后启动Hystrix-Dashboard服务，端口号为9002。</p></li></ol><p>同样的我们访问Hystrix-dashboard的地址<a href="http://localhost:9002/hystrix" target="_blank" rel="external">http://localhost:9002/hystrix</a>，在页面的地址栏输入<a href="http://localhost:9003/turbine.stream" target="_blank" rel="external">http://localhost:9003/turbine.stream</a>，然后分别往9000和9001端口的Ribbon-Consumer实例发送一些请求，这时候可以看到Dashboard的画面如下：</p><p><img src="img/QQ截图20180713171537.png" alt="QQ截图20180713171537.png"></p><p>效果和从服务注册中心获取服务的监控信息一致。并且这时候观察RabbitMQ的页面：</p><p><img src="img/QQ截图20180713171622.png" alt="QQ截图20180713171622.png"></p><p>可看到Queued messages已经有数据了。</p><p>至此我们完成了Turbine从消息中间件RabbitMQ来收集监控信息的过程。</p><p>源码链接：<a href="https://github.com/wuyouzhuguli/Spring-Boot-Demos/tree/master/32.Spring-Cloud-Hystrix-Dashboard-Turbine-RabbitMQ" target="_blank" rel="external">https://github.com/wuyouzhuguli/Spring-Boot-Demos/tree/master/32.Spring-Cloud-Hystrix-Dashboard-Turbine-RabbitMQ</a></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Tue Aug 21 2018 16:24:25 GMT+0800 (中国标准时间) --&gt;&lt;p&gt;Hystrix提供了Hystrix Dashboard来实时监控Hystrix的运行情况，通过Hystrix Dashboard反馈的实时信息，可以帮助我们快速发现系统中存在的问题，从而及时地采取应对措施。Spring Cloud对Hystrix Dashboard进行了整合，这里将介绍如何使用Hystrix Dashboard监控单个和多个Hystrix实例。
    
    </summary>
    
    
      <category term="Spring" scheme="http://mrbird.cc/tags/Spring/"/>
    
      <category term="Spring Cloud" scheme="http://mrbird.cc/tags/Spring-Cloud/"/>
    
      <category term="Hystrix" scheme="http://mrbird.cc/tags/Hystrix/"/>
    
  </entry>
  
  <entry>
    <title>Spring Cloud Hystrix服务容错</title>
    <link href="http://mrbird.cc/Spring-Cloud-Hystrix-Circuit-Breaker.html"/>
    <id>http://mrbird.cc/Spring-Cloud-Hystrix-Circuit-Breaker.html</id>
    <published>2018-06-06T00:57:40.000Z</published>
    <updated>2018-08-21T08:00:58.840Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Tue Aug 21 2018 16:24:25 GMT+0800 (中国标准时间) --><p>在微服务的架构中，服务间通常会形成相互依赖的关系，比如现在有三个微服务节点：A，B和C，B为A的消费者，C为B的消费者。假如由于网络波动或者A服务自身故障，导致B调用A服务的线程被挂起进入长时间的等待。在高并发的情况下可能导致B的资源被耗竭随之崩溃，从而导致C服务也不可用。这种连环式的雪崩效应在微服务中较为常见，为了解决这个问题，服务熔断技术应运而出。熔断一词来自电路学，指的是电路在出现短路状况时，“断路器”能够及时地切断故障电路，避免电路过载发热引发火灾。</p><p>类似的，微服务架构中的断路器能够及时地发现故障服务，并向服务调用方返回错误响应，而不是长时间的等待。Spring Cloud Hystrix在Hystrix（又是一款由Netflix开发的开源软件，Github地址<a href="https://github.com/Netflix/Hystrix" target="_blank" rel="external">https://github.com/Netflix/Hystrix</a>）的基础上进行了封装，提供了服务熔断，服务降级，线程隔离等功能，通过这些功能可以提供服务的容错率。<a id="more"></a></p><h2 id="使用Hystrix"><a href="#使用Hystrix" class="headerlink" title="使用Hystrix"></a>使用Hystrix</h2><p>这里将在上一节<a href="/Spring-Cloud-Ribbon-LoadBalance.html">Spring Cloud Ribbon客户端负载均衡</a>源码的基础上配置Hystrix。</p><p>我们先看下在没有配置Hystrix之前，关闭Eureka-Client是什么效果。</p><p>分别使用peer1和peer2配置启动Eureka-Server集群，然后启动两个Eureka-Client实例，端口分别为8082和8083，最后启动Ribbon-Consumer。准备完毕后，我们关闭端口为8082的Eureka-Client，然后发送GET请求<a href="http://localhost:9000/user/1" target="_blank" rel="external">http://localhost:9000/user/1</a>，返回结果如下：</p><p><img src="img/QQ截图20180710151846.png" alt="QQ截图20180710151846.png"></p><p>下面开始使用使用Spring Cloud Hystrix，在项目Ribbon-Consumer中引入Spring Cloud Hystrix依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-hystrix<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div></pre></td></tr></table></figure><p></p><p>在入口类上加入<code>@EnableHystrix</code>或者<code>@EnableCircuitBreaker</code>注解。这两个注解是等价的，查看<code>@EnableHystrix</code>注解源码就可以证实这一点：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Target</span>(&#123;ElementType.TYPE&#125;)</div><div class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</div><div class="line"><span class="meta">@Documented</span></div><div class="line"><span class="meta">@Inherited</span></div><div class="line"><span class="meta">@EnableCircuitBreaker</span></div><div class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnableHystrix &#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p></p><p>在引入<code>@EnableHystrix</code>或者<code>@EnableCircuitBreaker</code>注解后，我们的入口类代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@EnableCircuitBreaker</span></div><div class="line"><span class="meta">@EnableDiscoveryClient</span></div><div class="line"><span class="meta">@SpringBootApplication</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoApplication</span> </span>&#123;</div><div class="line">    <span class="meta">@Bean</span></div><div class="line">    <span class="meta">@LoadBalanced</span></div><div class="line">    <span class="function">RestTemplate <span class="title">restTemplate</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> RestTemplate();</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        SpringApplication.run(DemoApplication.class, args);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p></p><p>入口类上总共包含了三个注解<code>@EnableCircuitBreaker</code>、<code>@EnableDiscoveryClient</code>和<code>@SpringBootApplication</code>，这三个注解的组合可以使用<code>@SpringCloudApplication</code>来代替，<code>@SpringCloudApplication</code>源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Target</span>(&#123;ElementType.TYPE&#125;)</div><div class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</div><div class="line"><span class="meta">@Documented</span></div><div class="line"><span class="meta">@Inherited</span></div><div class="line"><span class="meta">@SpringBootApplication</span></div><div class="line"><span class="meta">@EnableDiscoveryClient</span></div><div class="line"><span class="meta">@EnableCircuitBreaker</span></div><div class="line"><span class="keyword">public</span> <span class="meta">@interface</span> SpringCloudApplication &#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p></p><p>接着将UserController中的方法提取出来，创建一个UserService（为了简单起见，不再创建Service接口）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Service</span>(<span class="string">"userService"</span>)</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserService</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> Logger log = LoggerFactory.getLogger(<span class="keyword">this</span>.getClass());</div><div class="line"></div><div class="line">    <span class="meta">@Autowired</span></div><div class="line">    <span class="keyword">private</span> RestTemplate restTemplate;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">getUser</span><span class="params">(@PathVariable Long id)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> restTemplate.getForObject(<span class="string">"http://Server-Provider/user/&#123;id&#125;"</span>, User.class, id);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> List&lt;User&gt; <span class="title">getUsers</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.restTemplate.getForObject(<span class="string">"http://Server-Provider/user"</span>, List.class);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">addUser</span><span class="params">()</span> </span>&#123;</div><div class="line">        User user = <span class="keyword">new</span> User(<span class="number">1L</span>, <span class="string">"mrbird"</span>, <span class="string">"123456"</span>);</div><div class="line">        HttpStatus status = <span class="keyword">this</span>.restTemplate.postForEntity(<span class="string">"http://Server-Provider/user"</span>, user, <span class="keyword">null</span>).getStatusCode();</div><div class="line">        <span class="keyword">if</span> (status.is2xxSuccessful()) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="string">"新增用户成功"</span>;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">return</span> <span class="string">"新增用户失败"</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateUser</span><span class="params">()</span> </span>&#123;</div><div class="line">        User user = <span class="keyword">new</span> User(<span class="number">1L</span>, <span class="string">"mrbird"</span>, <span class="string">"123456"</span>);</div><div class="line">        <span class="keyword">this</span>.restTemplate.put(<span class="string">"http://Server-Provider/user"</span>, user);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteUser</span><span class="params">(@PathVariable Long id)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.restTemplate.delete(<span class="string">"http://Server-Provider/user/&#123;1&#125;"</span>, id);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p></p><p>接着改造UserService的<code>getUser</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@HystrixCommand</span>(fallbackMethod = <span class="string">"getUserDefault"</span>)</div><div class="line"><span class="function"><span class="keyword">public</span> User <span class="title">getUser</span><span class="params">(@PathVariable Long id)</span> </span>&#123;</div><div class="line">   <span class="keyword">return</span> restTemplate.getForObject(<span class="string">"http://Server-Provider/user/&#123;id&#125;"</span>, User.class, id);</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">public</span> User <span class="title">getUserDefault</span><span class="params">(Long id)</span> </span>&#123;</div><div class="line">    User user = <span class="keyword">new</span> User();</div><div class="line">    user.setId(-<span class="number">1L</span>);</div><div class="line">    user.setUsername(<span class="string">"defaultUser"</span>);</div><div class="line">    user.setPassword(<span class="string">"123456"</span>);</div><div class="line">    <span class="keyword">return</span> user;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p></p><p>我们在<code>getUser</code>方法上加入了<code>@HystrixCommand</code>注解，注解的<code>fallbackMethod</code>属性指定了被调用的方法不可用时的回调方法（服务熔断时的回调处理逻辑，即服务降级），这里为<code>getUserDefault</code>方法（必须与<code>getUser</code>方法的参数及返回值类型一致）。</p><p>在UserController中调用UserService的<code>getUser</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@RestController</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestController</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> Logger log = LoggerFactory.getLogger(<span class="keyword">this</span>.getClass());</div><div class="line"></div><div class="line">    <span class="meta">@Autowired</span></div><div class="line">    <span class="keyword">private</span> UserService userService;</div><div class="line"></div><div class="line">    <span class="meta">@GetMapping</span>(<span class="string">"user/&#123;id&#125;"</span>)</div><div class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">getUser</span><span class="params">(@PathVariable Long id)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> userService.getUser(id);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p></p><p>修改完后启动Ribbon-Consumer并重重新启动8082端口的Eureka-Client，发送数次GET请求<a href="http://localhost:9000/user/1" target="_blank" rel="external">http://localhost:9000/user/1</a>后，再次关闭8082端口的Eureka-Client。</p><p>断开后，继续发送GET请求<a href="http://localhost:9000/user/1" target="_blank" rel="external">http://localhost:9000/user/1</a>，当轮询到8082端口时返回数据如下图所示：</p><p><img src="img/QQ截图20180710154714.png" alt="QQ截图20180710154714.png"></p><p>可以看到，当轮询到服务不可用时，触发了熔断机制，接口回调了<code>fallbackMethod</code>指定的方法。</p><p>我们也可以模拟服务超时的情况，可以在Eureka-Client提供的接口方法中设置线程等待，等待时间大于2000（Hystrix默认超时时间为2000 毫秒）即可触发调用方Ribbon-Consumer的服务熔断。</p><h2 id="HystrixCommand详解"><a href="#HystrixCommand详解" class="headerlink" title="@HystrixCommand详解"></a>@HystrixCommand详解</h2><p><code>@HystrixCommand</code>注解还包含许多别的属性功能，下面介绍一些常用的属性配置。</p><h3 id="服务降级"><a href="#服务降级" class="headerlink" title="服务降级"></a>服务降级</h3><p>上面TestController中的<code>getUser</code>中我们用<code>@HystrixCommand</code>注解指定了服务降级方法<code>getUserDefault</code>。如果<code>getUserDefault</code>方法也抛出异常，那么我们可以再次使用<code>@HystrixCommand</code>注解指定<code>getUserDefault</code>方法降级的方法，比如定义一个<code>getUserDefault2</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@HystrixCommand</span>(fallbackMethod = <span class="string">"getUserDefault2"</span>)</div><div class="line"><span class="function"><span class="keyword">public</span> User <span class="title">getUserDefault</span><span class="params">(Long id)</span> </span>&#123;</div><div class="line">    String a = <span class="keyword">null</span>;</div><div class="line">    <span class="comment">// 测试服务降级</span></div><div class="line">    a.toString();</div><div class="line">    User user = <span class="keyword">new</span> User();</div><div class="line">    user.setId(-<span class="number">1L</span>);</div><div class="line">    user.setUsername(<span class="string">"defaultUser"</span>);</div><div class="line">    user.setPassword(<span class="string">"123456"</span>);</div><div class="line">    <span class="keyword">return</span> user;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> User <span class="title">getUserDefault2</span><span class="params">(Long id)</span> </span>&#123;</div><div class="line">    User user = <span class="keyword">new</span> User();</div><div class="line">    user.setId(-<span class="number">2L</span>);</div><div class="line">    user.setUsername(<span class="string">"defaultUser2"</span>);</div><div class="line">    user.setPassword(<span class="string">"123456"</span>);</div><div class="line">    <span class="keyword">return</span> user;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p></p><p>重启Ribbon-Consumer，并关闭8082端口的Eureka Client服务，访问<a href="http://localhost:9000/user/1" target="_blank" rel="external">http://localhost:9000/user/1</a>：</p><p><img src="img/QQ截图20180712112335.png" alt="QQ截图20180712112335.png"></p><h3 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h3><p>在使用<code>@HystrixCommand</code>注解标注的方法中，除了<code>HystrixBadRequestException</code>异常外，别的异常都会触发服务降级。假如我们想指定某个异常不触发服务降级，可以使用<code>@HystrixCommand</code>注解的<code>ignoreExceptions</code>属性进行忽略。如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@HystrixCommand</span>(fallbackMethod = <span class="string">"getUserDefault2"</span>, ignoreExceptions = &#123;NullPointerException.class&#125;)</div><div class="line"><span class="function"><span class="keyword">public</span> User <span class="title">getUserDefault</span><span class="params">(Long id)</span> </span>&#123;</div><div class="line">    String a = <span class="keyword">null</span>;</div><div class="line">    <span class="comment">// 测试服务降级</span></div><div class="line">    a.toString();</div><div class="line">    User user = <span class="keyword">new</span> User();</div><div class="line">    user.setId(-<span class="number">1L</span>);</div><div class="line">    user.setUsername(<span class="string">"defaultUser"</span>);</div><div class="line">    user.setPassword(<span class="string">"123456"</span>);</div><div class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> HystrixBadRequestException()</div><div class="line">    <span class="keyword">return</span> user;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p></p><p>此外，对于方法抛出的异常信息，我们可以在服务降级的方法中使用<code>Throwable</code>对象获取，如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@HystrixCommand</span>(fallbackMethod = <span class="string">"getUserDefault2"</span>)</div><div class="line"><span class="function"><span class="keyword">public</span> User <span class="title">getUserDefault</span><span class="params">(Long id, Throwable e)</span> </span>&#123;</div><div class="line">    System.out.println(e.getMessage());</div><div class="line">    User user = <span class="keyword">new</span> User();</div><div class="line">    user.setId(-<span class="number">2L</span>);</div><div class="line">    user.setUsername(<span class="string">"defaultUser2"</span>);</div><div class="line">    user.setPassword(<span class="string">"123456"</span>);</div><div class="line">    <span class="keyword">return</span> user;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p></p><h3 id="命名与分组"><a href="#命名与分组" class="headerlink" title="命名与分组"></a>命名与分组</h3><p>通过指定<code>@HystrixCommand</code>注解的<code>commandKey</code>、<code>groupKey</code>以及<code>threadPoolKey</code>属性可以设置命令名称、分组以及线程池划分，如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@HystrixCommand</span>(fallbackMethod = <span class="string">"getUserDefault"</span>, commandKey = <span class="string">"getUserById"</span>, groupKey = <span class="string">"userGroup"</span>,</div><div class="line">        threadPoolKey = <span class="string">"getUserThread"</span>)</div><div class="line"><span class="function"><span class="keyword">public</span> User <span class="title">getUser</span><span class="params">(@PathVariable Long id)</span> </span>&#123;</div><div class="line">	log.info(<span class="string">"获取用户信息"</span>);</div><div class="line">    <span class="keyword">return</span> restTemplate.getForObject(<span class="string">"http://Server-Provider/user/&#123;id&#125;"</span>, User.class, id);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p></p><p>上面的配置指定了命令的名称为<code>getUserById</code>，组名为<code>userGroup</code>，线程池名称为<code>getUserThread</code>。</p><p>通过设置命令组，Hystrix会根据组来组织和统计命令的告警、仪表盘等信息。默认情况下，Hystrix命令通过组名来划分线程池，即组名相同的命令放到同一个线程池里，如果通过<code>threadPoolKey</code>设置了线程池名称，则按照线程池名称划分。</p><p>当<code>getUser</code>方法被调用时，日志打印如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">2018-06-06 15:32:55.945  INFO 16192 --- [getUserThread-1] com.example.demo.Service.UserService  : 获取用户信息</div></pre></td></tr></table></figure><p></p><p>可看到线程名称为getUserThread-1。</p><h3 id="Hystrix缓存"><a href="#Hystrix缓存" class="headerlink" title="Hystrix缓存"></a>Hystrix缓存</h3><p>我们在Controller中调用三次<code>getUser</code>方法，参数都为1L：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@RestController</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestController</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@Autowired</span></div><div class="line">    <span class="keyword">private</span> UserService userService;</div><div class="line"></div><div class="line">    <span class="meta">@GetMapping</span>(<span class="string">"testCache"</span>)</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testCache</span><span class="params">()</span></span>&#123;</div><div class="line">        userService.getUser(<span class="number">1L</span>);</div><div class="line">        userService.getUser(<span class="number">1L</span>);</div><div class="line">        userService.getUser(<span class="number">1L</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p></p><p>当访问<a href="http://localhost:9000/testCache" target="_blank" rel="external">http://localhost:9000/testCache</a>时，控制台输出如下： <img src="img/QQ截图20180712173742.png" alt="QQ截图20180712173742.png"></p><p>开启缓存可以让<code>getUser</code>方法只被调用一次，剩下两次直接从缓存里获取。</p><p><strong>开启缓存</strong></p><p>要在Hystrix中开启缓存很简单，只需使用<code>@CacheResult</code>注解即可，修改UserService的<code>getUser</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@CacheResult</span></div><div class="line"><span class="function"><span class="keyword">public</span> User <span class="title">getUser</span><span class="params">(@PathVariable Long id)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> restTemplate.getForObject(<span class="string">"http://Server-Provider/user/&#123;id&#125;"</span>, User.class, id);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p></p><p>通过上面的设定，Hystrix会将返回的User对象进行缓存，缓存的key默认为方法的所有参数，这里只有一个id参数，所以缓存的key为用户id。</p><p>这里在测试的时候遇到一个异常：</p><div class="note danger"><p>java.lang.IllegalStateException: Request caching is not available. Maybe you need to initialize the HystrixRequestContext? at com.netflix.hystrix.HystrixRequestCache.get(HystrixRequestCache.java:104) ~[hystrix-core-1.5.12.jar:1.5.12] at com.netflix.hystrix.AbstractCommand$7.call(AbstractCommand.java:478) ~[hystrix-core-1.5.12.jar:1.5.12] at com.netflix.hystrix.AbstractCommand$7.call(AbstractCommand.java:454) ~[hystrix-core-1.5.12.jar:1.5.12] …</p></div><p></p><p>在Hystrix的issue中找到了类似的提问：<a href="https://github.com/Netflix/Hystrix/issues/1314" target="_blank" rel="external">https://github.com/Netflix/Hystrix/issues/1314</a>。</p><p>大致意思是在使用Hytrix缓存之前，需要通过<code>HystrixRequestContext.initializeContext</code>初始化Hystrix请求上下文，请求结束之后需要调用<code>shutdown</code>方法关闭请求。</p><p>所以我们可以定义一个过滤器来实现这个过程：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Component</span></div><div class="line"><span class="meta">@WebFilter</span>(filterName = <span class="string">"hystrixRequestContextServletFilter"</span>, urlPatterns = <span class="string">"/*"</span>, asyncSupported = <span class="keyword">true</span>)</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HystrixRequestContextServletFilter</span> <span class="keyword">implements</span> <span class="title">Filter</span> </span>&#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(FilterConfig filterConfig)</span> </span>&#123;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFilter</span><span class="params">(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain)</span> <span class="keyword">throws</span> IOException, ServletException </span>&#123;</div><div class="line">        HystrixRequestContext context = HystrixRequestContext.initializeContext();</div><div class="line">        filterChain.doFilter(servletRequest, servletResponse);</div><div class="line">        context.close();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p></p><div class="note info"><p>到这里，我才意识到，其实Hystrix的缓存还是蛮鸡肋的，请求缓存不是只写入一次结果就不再变化的，而是每次请求到达Controller的时候，我们都需要为HystrixRequestContext进行初始化，之前的缓存也就是不存在了，我们是在同一个请求中保证结果相同，同一次请求中的第一次访问后对结果进行缓存，缓存的生命周期只有一次请求！</p></div><p>改造完毕后，重启项目再次访问<a href="http://localhost:9000/testCache" target="_blank" rel="external">http://localhost:9000/testCache</a>，控制台输出如下：</p><p><img src="img/QQ截图20180712181439.png" alt="QQ截图20180712181439.png"></p><p><strong>设定key值</strong></p><p>我们也可以明确的指定缓存的key值是什么。指定key的值有两种方式：</p><ol><li><p>通过<code>@CacheKey</code>注解指定，如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@CacheResult</span></div><div class="line"><span class="meta">@HystrixCommand</span>(fallbackMethod = <span class="string">"getUserDefault"</span>, commandKey = <span class="string">"getUserById"</span>, groupKey = <span class="string">"userGroup"</span>,</div><div class="line">        threadPoolKey = <span class="string">"getUserThread"</span>)</div><div class="line"><span class="function"><span class="keyword">public</span> User <span class="title">getUser</span><span class="params">(@CacheKey(<span class="string">"id"</span>)</span> @PathVariable Long id) </span>&#123;</div><div class="line">    log.info(<span class="string">"获取用户信息"</span>);</div><div class="line">    <span class="keyword">return</span> restTemplate.getForObject(<span class="string">"http://Server-Provider/user/&#123;id&#125;"</span>, User.class, id);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>也可以指定参数对象内部属性为key值：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@CacheResult</span></div><div class="line"><span class="meta">@HystrixCommand</span>(fallbackMethod = <span class="string">"getUserDefault"</span>, commandKey = <span class="string">"getUserById"</span>, groupKey = <span class="string">"userGroup"</span>,</div><div class="line">        threadPoolKey = <span class="string">"getUserThread"</span>)</div><div class="line"><span class="function"><span class="keyword">public</span> User <span class="title">getUser</span><span class="params">(@CacheKey(<span class="string">"id"</span>)</span> User user) </span>&#123;</div><div class="line">    log.info(<span class="string">"获取用户信息"</span>);</div><div class="line">    <span class="keyword">return</span> restTemplate.getForObject(<span class="string">"http://Server-Provider/user/&#123;id&#125;"</span>, User.class, user.getId());</div><div class="line">&#125;</div></pre></td></tr></table></figure></li><li><p>通过方法来指定，方法的返回值必须是String类型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getCacheKey</span><span class="params">(Long id)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> String.valueOf(id);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="meta">@CacheResult</span>(cacheKeyMethod = <span class="string">"getCacheKey"</span>)</div><div class="line"><span class="meta">@HystrixCommand</span>(fallbackMethod = <span class="string">"getUserDefault"</span>, commandKey = <span class="string">"getUserById"</span>, groupKey = <span class="string">"userGroup"</span>,</div><div class="line">        threadPoolKey = <span class="string">"getUserThread"</span>)</div><div class="line"><span class="function"><span class="keyword">public</span> User <span class="title">getUser</span><span class="params">(Long id)</span> </span>&#123;</div><div class="line">    log.info(<span class="string">"获取用户信息"</span>);</div><div class="line">    <span class="keyword">return</span> restTemplate.getForObject(<span class="string">"http://Server-Provider/user/&#123;id&#125;"</span>, User.class, id);</div><div class="line">&#125;</div></pre></td></tr></table></figure></li></ol><p>值得注意的是，方法2的优先级比方法1高。</p><p><strong>缓存清除</strong></p><p>在涉及到更新User信息的方法上，我们要及时的清除相应的缓存，否则将会导致缓存数据和实际数据不一致的问题。我们在UserService的<code>updateUser</code>方法上做缓存清除操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@CacheRemove</span>(commandKey = <span class="string">"getUserById"</span>)</div><div class="line"><span class="meta">@HystrixCommand</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateUser</span><span class="params">(@CacheKey(<span class="string">"id"</span>)</span> User user) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.restTemplate.put(<span class="string">"http://Server-Provider/user"</span>, user);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p></p><p><code>@CacheRemove</code>的<code>commandKey</code>属性和<code>getUser</code>里定义的一致。</p><h3 id="请求合并"><a href="#请求合并" class="headerlink" title="请求合并"></a>请求合并</h3><p>请求合并就是将多个单个请求合并成一个请求，去调用服务提供者，从而降低服务提供者负载的，一种应对高并发的解决办法。</p><p>Hystrix中提供了一个<code>@HystrixCollapser</code>注解，该注解可以将处于一个很短的时间段（默认10 毫秒）内对同一依赖服务的多个请求进行整合并以批量方式发起请求。为了演示<code>@HystrixCollapser</code>注解的使用方法，我们改造下Eureka-Client（服务提供者）的UserController接口，提供一个批量处理的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@RestController</span></div><div class="line"><span class="meta">@RequestMapping</span>(<span class="string">"user"</span>)</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> Logger log = LoggerFactory.getLogger(<span class="keyword">this</span>.getClass());</div><div class="line"></div><div class="line">    <span class="meta">@GetMapping</span>(<span class="string">"users"</span>)</div><div class="line">    <span class="function"><span class="keyword">public</span> List&lt;User&gt; <span class="title">get</span><span class="params">(String ids)</span> </span>&#123;</div><div class="line">        log.info(<span class="string">"批量获取用户信息"</span>);</div><div class="line">        List&lt;User&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">        <span class="keyword">for</span> (String id : ids.split(<span class="string">","</span>)) &#123;</div><div class="line">            list.add(<span class="keyword">new</span> User(Long.valueOf(id), <span class="string">"user"</span> + id, <span class="string">"123456"</span>));</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> list;</div><div class="line">    &#125;</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure><p></p><p>然后在Ribbon-Consumer的UserService里添加两个方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@HystrixCollapser</span>(batchMethod = <span class="string">"findUserBatch"</span>, collapserProperties = &#123;</div><div class="line">        <span class="meta">@HystrixProperty</span>(name = <span class="string">"timerDelayInMilliseconds"</span>, value = <span class="string">"100"</span>)</div><div class="line">&#125;)</div><div class="line"><span class="function"><span class="keyword">public</span> Future&lt;User&gt; <span class="title">findUser</span><span class="params">(Long id)</span> </span>&#123;</div><div class="line">    log.info(<span class="string">"获取单个用户信息"</span>);</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> AsyncResult&lt;User&gt;() &#123;</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> User <span class="title">invoke</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="keyword">return</span> restTemplate.getForObject(<span class="string">"http://Server-Provider/user/&#123;id&#125;"</span>, User.class, id);</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="meta">@HystrixCommand</span></div><div class="line"><span class="function"><span class="keyword">public</span> List&lt;User&gt; <span class="title">findUserBatch</span><span class="params">(List&lt;Long&gt; ids)</span> </span>&#123;</div><div class="line">    log.info(<span class="string">"批量获取用户信息,ids: "</span> + ids);</div><div class="line">    User[] users = restTemplate.getForObject(<span class="string">"http://Server-Provider/user/users?ids=&#123;1&#125;"</span>, User[].class, StringUtils.join(ids, <span class="string">","</span>));</div><div class="line">    <span class="keyword">return</span> Arrays.asList(users);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p></p><p><code>@HystrixCollapser</code>注解的<code>batchMethod</code>属性指定了批量处理的方法为下面定义的<code>findUserBatch</code>方法，<code>timerDelayInMilliseconds</code>的值为100（毫秒），意思是在100毫秒这个时间范围内的所有对<code>findUser</code>的调用，都将被合并为一个批量处理操作，进行批量处理操作的方法就是<code>findUserBatch</code>。</p><p>我们在TestController中添加一个测试方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@GetMapping</span>(<span class="string">"testRequestMerge"</span>)</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testRequerstMerge</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, ExecutionException </span>&#123;</div><div class="line">    Future&lt;User&gt; f1 = userService.findUser(<span class="number">1L</span>);</div><div class="line">    Future&lt;User&gt; f2 = userService.findUser(<span class="number">2L</span>);</div><div class="line">    Future&lt;User&gt; f3 = userService.findUser(<span class="number">3L</span>);</div><div class="line">    f1.get();</div><div class="line">    f2.get();</div><div class="line">    f3.get();</div><div class="line">    Thread.sleep(<span class="number">200</span>);</div><div class="line">    Future&lt;User&gt; f4 = userService.findUser(<span class="number">4L</span>);</div><div class="line">    f4.get();</div><div class="line">&#125;</div></pre></td></tr></table></figure><p></p><p>上面的测试方法中对<code>findUser</code>方法进行了4次的调用，最后一次调用（f4）之前先让线程等待200毫秒（大于<code>timerDelayInMilliseconds</code>中定义的100毫秒），所以我们的预期是前三次调用会被合并，而最后一次调用不会被合并进去。</p><p>启动Ribbon-Consumer，访问<a href="http://localhost:9000/testRequestMerge" target="_blank" rel="external">http://localhost:9000/testRequestMerge</a>,控制台输出如下：</p><p><img src="img/QQ截图20180712185806.png" alt="QQ截图20180712185806.png"></p><p>可以看到，控制台的输出符合我们的预期，f1、f2和f3被合并成了一个请求。</p><p>而且可以看到，控制台并没有打印出<code>findUser</code>方法中的<code>获取单个用户信息</code>的日志，实际上<code>findUser</code>方法并不会被调用，所以上面的代码可以简化为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"> <span class="meta">@HystrixCollapser</span>(batchMethod = <span class="string">"findUserBatch"</span>, collapserProperties = &#123;</div><div class="line">        <span class="meta">@HystrixProperty</span>(name = <span class="string">"timerDelayInMilliseconds"</span>, value = <span class="string">"100"</span>)</div><div class="line">&#125;)</div><div class="line"><span class="function"><span class="keyword">public</span> Future&lt;User&gt; <span class="title">findUser</span><span class="params">(Long id)</span> </span>&#123;</div><div class="line">    log.info(<span class="string">"获取单个用户信息"</span>);</div><div class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="meta">@HystrixCommand</span></div><div class="line"><span class="function"><span class="keyword">public</span> List&lt;User&gt; <span class="title">findUserBatch</span><span class="params">(List&lt;Long&gt; ids)</span> </span>&#123;</div><div class="line">    log.info(<span class="string">"批量获取用户信息,ids: "</span> + ids);</div><div class="line">    User[] users = restTemplate.getForObject(<span class="string">"http://Server-Provider/user/users?ids=&#123;1&#125;"</span>, User[].class, StringUtils.join(ids, <span class="string">","</span>));</div><div class="line">    <span class="keyword">return</span> Arrays.asList(users);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p></p><p>虽然通过请求的合并可以减轻带宽和服务的压力，但合并请求的过程也会带来额外的开销。就拿上面的<code>testCache</code>来说，比如我们对单个<code>findUser</code>的方法调用耗时5ms，那么调用4次耗时可以粗略的估算为20ms。当我们使用Hystrix的请求合并功能后，前3次请求（f1、f2和f3）进行了合并，第4次请求（f4）没有进行合并，那么耗时可以粗略的估算为<code>3*5+100+5=120ms</code>（100为上面<code>timerDelayInMilliseconds</code>中指定的时间范围，在该时间段过后，才会调用第4次请求），结果明显比单独调用4次来得高。所以实际中是否该使用Hystrix的请求合并功能，需结合实际需求进行抉择。</p><h2 id="Hystrix属性"><a href="#Hystrix属性" class="headerlink" title="Hystrix属性"></a>Hystrix属性</h2><p>除了上面涉及到的Hystrix属性配置外，其还包含了大量的别的可用配置。配置可以分为四个级别，优先级从低到高分别为：全局默认配置、全局配置、实例默认值、实例配置。</p><h3 id="Commond"><a href="#Commond" class="headerlink" title="Commond"></a>Commond</h3><h4 id="execution"><a href="#execution" class="headerlink" title="execution"></a>execution</h4><p><code>execution.isolation.strategy</code>： 该属性用来设置执行的隔离策略，它有如下两个选项。</p><ol><li><p><code>THREAD</code>: 通过线程池隔离的策略。它在独立的线程上执行， 并且它的并发限制受线程池中线程数量的限制。</p></li><li><p><code>SEMAPHORE</code>: 通过信号量隔离的策略。它在调用线程上执行， 并且它的并发限制受信号量计数的限制。</p></li></ol><table><tr><th>属性级别</th><th>默认值、配置方式、配置属性</th></tr><tr><td>全局默认配置</td><td>THREAD</td></tr><tr><td>全局配置</td><td>hystrix.command.default.execution.isolation.strategy</td></tr><tr><td>实例默认值</td><td>@HystrixProperty(name=”execution.isolation.strategy”, value=”THREAD”)</td></tr><tr><td>实例配置</td><td>hystrix.command.HystrixCommandKey.execution.isolation.strategy</td></tr></table><div class="note info"><p>实例配置中的HystrixCommandKey对应@HystrixCommand注解中commandKey 属性指定的值。</p></div><p><code>execution.isolation.thread.timeoutinMilliseconds</code>： 该属性用来配置HystrixCommand执行的超时时间，单位为毫秒。当HystrixCommand执行时间超过该配置值之后， Hystrix会将该执行命令标记为TIMEOUT并进入服务降级处理逻辑。</p><table><tr><th>属性级别</th><th>默认值、配置方式、配置属性</th></tr><tr><td>全局默认配置</td><td>1000亳秒</td></tr><tr><td>全局配置</td><td>hystrix.command.default.execution.isolation.thread. timeoutinMilliseconds</td></tr><tr><td>实例默认值</td><td>@HystrixProperty(name=”execution.isolation.thread.timeoutinMilliseconds”,value=”2000”)</td></tr><tr><td>实例配置</td><td>hystrix.command.HystrixCommandKey.execution.isolation.thread.timeoutinMilliseconds</td></tr></table><p><code>execution.timeout.enabled</code>: 该属性用来配置HystrixCommand的执行是否启用超时时间。默认为true, 如果设置为false, 那么<code>execution.isolation.thread.timeoutinMilliseconds</code>属性的配置将不再起作用。</p><table><tr><th>属性级别</th><th>默认值、配置方式、配置属性</th></tr><tr><td>全局默认配置</td><td>true</td></tr><tr><td>全局配置</td><td>hystrix.command.default.execution.timeout.enabled</td></tr><tr><td>实例默认值</td><td>@HystrixProperty(name=”execution.timeout.enabled”, value=”false”)</td></tr><tr><td>实例配置</td><td>hystrix.command.HystrixCommandKey.execution.timeout.enabled</td></tr></table><p><code>execution.isolation.thread.interruptOnTimeout</code>: 该属性用来配置当HystrixCommand执行超时的时候是否要将它中断。</p><table><tr><th>属性级别</th><th>默认值、配置方式、配置属性</th></tr><tr><td>全局默认配置</td><td>true</td></tr><tr><td>全局配置</td><td>hystrix.command.default.execution.isolation.thread.interruptOnTimeout</td></tr><tr><td>实例默认值</td><td>@HystrixProperty(name=”execution.isolation.thread.interruptOnTimeout”,value=”false”)</td></tr><tr><td>实例配置</td><td>hystrix.command.HystrixCommandKey.execution.isolation.thread.interruptOnTimeout</td></tr></table><p><code>execution.isolation.thread.interruptOnCancel</code>: 该属性用来配置当HystrixCommand执行被取消的时候是否要将它中断。</p><table><tr><th>属性级别</th><th>默认值、配置方式、配置属性</th></tr><tr><td>全局默认配置</td><td>true</td></tr><tr><td>全局配置</td><td>hystrix.command.default.execution.isolation.thread.interruptOnCancel</td></tr><tr><td>实例默认值</td><td>@HystrixProperty(name=”execution.isolation.thread.interruptOnCancel”,value= “false”)</td></tr><tr><td>实例配置</td><td>hystrix.command.HystrixCommandKey.execution.isolation.thread.interruptOnCancel</td></tr></table><p><code>execution.isolation.semaphore.maxConcurrentRequests</code>: 当HystrixCommand的隔离策略使用信号量的时候，该属性用来配置信号量的大小（并发请求数）。当最大并发请求数达到该设置值时，后续的请求将会被拒绝。</p><table><tr><th>属性级别</th><th>默认值、配置方式、配置属性</th></tr><tr><td>全局默认配置</td><td>10</td></tr><tr><td>全局配置</td><td>hystrix.command.default.execution.isolation.semaphore.maxConcurrentRequests</td></tr><tr><td>实例默认值</td><td>@HystrixProperty(name=”execution.isolation.semaphore.maxConcurrentRequests”, value=”2”)</td></tr><tr><td>实例配置</td><td>hystrix.command.HystrixCommandKey.execution.isolation.semaphore.maxConcurrentRequests</td></tr></table><h4 id="fallback"><a href="#fallback" class="headerlink" title="fallback"></a>fallback</h4><p><code>fallback.enabled</code>: 该属性用来设置服务降级策略是否启用，如果设置为false,那么当请求失败或者拒绝发生时，将不会调用降级服务。</p><table><tr><th>属性级别</th><th>默认值、配置方式、配置属性</th></tr><tr><td>全局默认配置</td><td>true</td></tr><tr><td>全局配置</td><td>hystrix.command.default.fallback.enabled</td></tr><tr><td>实例默认值</td><td>@HystrixProperty(name= “fallback.enabled”, value=”false”)</td></tr><tr><td>实例配置</td><td>hystrix.command.HystrixCommandKey.fallback.enabled</td></tr></table><h4 id="circuitBreaker断路器"><a href="#circuitBreaker断路器" class="headerlink" title="circuitBreaker断路器"></a>circuitBreaker断路器</h4><p><code>circuitBreaker.enabled</code>: 该属性用来确定当服务请求命令失败时， 是否使用断路器来跟踪其健康指标和熔断请求。</p><table><tr><th>属性级别</th><th>默认值、配置方式、配置属性</th></tr><tr><td>全局默认配置</td><td>true</td></tr><tr><td>全局配置</td><td>hystrix.command.default.circuitBreaker.enabled</td></tr><tr><td>实例默认值</td><td>@HystrixProperty(name=”circutBreaker.enabled”,value=”false”)</td></tr><tr><td>实例配置</td><td>hystrix.command.HystrixCommandKey.circuitBreaker.enabled</td></tr></table><p><code>circuitBreaker.requestVolumeThreshold</code>: 该属性用来设置在滚动时间窗中，断路器熔断的最小请求数。例如，默认该值为20 的时候，如果滚动时间窗（默认10秒）内仅收到了19个请求， 即使这19个请求都失败了，断路器也不会打开。</p><table><tr><th>属性级别</th><th>默认值、配置方式、配置属性</th></tr><tr><td>全局默认配置</td><td>20</td></tr><tr><td>全局配置</td><td>hystrix.command.default.circuitBreaker.requestVolumeThreshold</td></tr><tr><td>实例默认值</td><td>@HystrixProperty(name=”circuitBreaker.requestVolumeThreshold”, value=”30”)</td></tr><tr><td>实例配置</td><td>hystrix.comrnand.HystrixComrnandKey.circuitBreaker.requestVolumeThreshold</td></tr></table><p><code>circuitBreaker.sleepWindowinMilliseconds</code>: 该属性用来设置当断路器打开之后的休眠时间窗。休眠时间窗结束之后，会将断路器置为“半开” 状态， 尝试熔断的请求命令，如果依然失败就将断路器继续设置为“打开” 状态，如果成功就设置为“关闭” 状态。</p><table><tr><th>属性级别</th><th>默认值、配置方式、配置属性</th></tr><tr><td>全局默认配置</td><td>5000</td></tr><tr><td>全局配置</td><td>hystrix.command.default.circuitBreaker.sleepWindowinMilliseconds</td></tr><tr><td>实例默认值</td><td>@HystrixProperty(name=”circuitBreaker.sleepWindowinMilliseconds”,value=”3000”)</td></tr><tr><td>实例配置</td><td>hystrix.command.HystrixCommandKey.circuitBreaker.sleepWindowinMilliseconds</td></tr></table><p><code>circuitBreaker.errorThresholdPercentage</code>: 该属性用来设置断路器打开的错误百分比条件。例如，默认值为5000 的情况下，表示在滚动时间窗中，在请求数量超过<code>circuitBreaker.requestVolumeThreshold</code>阅值的前提下，如果错误请求数的百分比超过50, 就把断路器设置为“打开” 状态， 否则就设置为“关闭” 状态。</p><table><tr><th>属性级别</th><th>默认值、配置方式、配置属性</th></tr><tr><td>全局默认配置</td><td>50</td></tr><tr><td>全局配置</td><td>hystrix.command.default.circuitBreaker.errorThresholdPercentage</td></tr><tr><td>实例默认值</td><td>@HystrixProperty(name=”circuitBreaker.errorThresholdPercentage”, value=”40”)</td></tr><tr><td>实例配置</td><td>hystrix.command.HystrixCommandKey.circuitBreaker.errorThresholdPercentage</td></tr></table><p><code>circuitBreaker.forceOpen</code>: 如果将该属性设置为true, 断路器将强制进入“打开” 状态，它会拒绝所有请求。该属性优先于<code>circuitBreaker.forceClosed</code>属性。</p><table><tr><th>属性级别</th><th>默认值、配置方式、配置属性</th></tr><tr><td>全局默认配置</td><td>false</td></tr><tr><td>全局配置</td><td>hystrix.command.default.circuitBreaker.forceOpen</td></tr><tr><td>实例默认值</td><td>@HystrixProperty (name=”circuitBreaker.forceOpen”, value=”true”)</td></tr><tr><td>实例配置</td><td>hystrix.command.HystrixCommandKey.circuitBreaker.forceOpen</td></tr></table><p><code>circuitBreaker.forceClosed</code>: 如果将该属性设置为true, 断路器将强制进入“关闭” 状态， 它会接收所有请求。如果<code>circuitBreaker.forceOpen</code>属性为true, 该属性不会生效。</p><table><tr><th>属性级别</th><th>默认值、配置方式、配置属性</th></tr><tr><td>全局默认配置</td><td>false</td></tr><tr><td>全局配置</td><td>hystrix.command.default.circuitBreaker.forceClosed</td></tr><tr><td>实例默认值</td><td>@HystrixProperty(name=”circui七Breaker.forceClosed”, value=”true”)</td></tr><tr><td>实例配置</td><td>hystrix.comrnand.HystrixComrnandKey.circuitBreaker.forceClosed</td></tr></table><h4 id="metrics配置"><a href="#metrics配置" class="headerlink" title="metrics配置"></a>metrics配置</h4><p>该配置与HystrixCommand执行中捕获的指标信息有关。</p><p><code>metrics.rollingStats.timeinMilliseconds</code>: 该属性用来设置滚动时间窗的长度， 单位为毫秒。该时间用于断路器判断健康度时需要收集信息的持续时间。断路器在收集指标信息的时候会根据设置的时间窗长度拆分成多个“桶” 来累计各度量值，每个“桶” 记录了一段时间内的采集指标。例如，当采用默认值10000毫秒时， 断路器默认将其拆分成10个桶（桶的数量也可通过<code>metrics.rollingStats.numBuckets</code>参数设置），每个桶记录1000毫秒内的指标信息。</p><table><tr><th>属性级别</th><th>默认值、配置方式、配置属性</th></tr><tr><td>全局默认配置</td><td>10000</td></tr><tr><td>全局配置</td><td>hystrix.command.default.metrics.rollingStats.timeinMilliseconds</td></tr><tr><td>实例默认值</td><td>@HystrixProperty(name=”metrics.rollingStats.timeinMilliseconds”,value=”20000”)</td></tr><tr><td>实例配置</td><td>hystrix.command.HystrixCommandKey.metrics.rollingStats.timeinMilliseconds</td></tr></table><p><code>metrics.rollingstats.numBuckets</code>: 该属性用来设置滚动时间窗统计指标信息时划分“桶” 的数量。</p><table><tr><th>属性级别</th><th>默认值、配置方式、配置属性</th></tr><tr><td>全局默认配置</td><td>10</td></tr><tr><td>全局配置</td><td>hystrix.command.default.metrics.rollingStats.numBuckets</td></tr><tr><td>实例默认值</td><td>@HystrixProperty(name=”metrics.rollingStats.numBuckets”,value=”20”)</td></tr><tr><td>实例配置</td><td>hystrix.comrnand.HystrixComrnandKey.metrics.rollingStats.numBuckets</td></tr></table><p><code>metrics.rollingPercentile.enabled</code>: 该属性用来设置对命令执行的延迟是否使用百分位数来跟踪和计算。如果设置为false，那么所有的概要统计都将返回-1。</p><table><tr><th>属性级别</th><th>默认值、配置方式、配置属性</th></tr><tr><td>全局默认配置</td><td>true</td></tr><tr><td>全局配置</td><td>hystrix.command.default.metrics.rollingPercentile.enabled</td></tr><tr><td>实例默认值</td><td>@HystrixProperty(name=”metrics.rollingPercentile.enabled”, value=”false”)</td></tr><tr><td>实例配置</td><td>hystrix.command.HystrixCommandKey.metrics.rollingPercentile.enabled</td></tr></table><p><code>metrics.rollingPercentile.timeinMilliseconds</code>: 该属性用来设置百分位统计的滚动窗口的持续时间，单位为毫秒。</p><table><tr><th>属性级别</th><th>默认值、配置方式、配置属性</th></tr><tr><td>全局默认配置</td><td>60000</td></tr><tr><td>全局配置</td><td>hystrix.command.default.metrics.rollingPercentile.timeinMilliseconds</td></tr><tr><td>实例默认值</td><td>@HystrixProperty(name=”metrics.rollingPercentile.timeinMilliseconds”, value=”50000”)</td></tr><tr><td>实例配置</td><td>hystrix.command.HystrixCommandKey.metrics.rollingPercentile.timeinMilliseconds</td></tr></table><p><code>metrics.rollingPercentile.numBuckets</code>: 该属性用来设置百分位统计滚动窗口中使用“桶”的数量。</p><table><tr><th>属性级别</th><th>默认值、配置方式、配置属性</th></tr><tr><td>全局默认配置</td><td>6</td></tr><tr><td>全局配置</td><td>hystrix.command.default.metrics.rollingPercentile.numBuckets</td></tr><tr><td>实例默认值</td><td>@HystrixProperty(name=”metrics.rollingPercentilee.numBuckets”,value=”5”)</td></tr><tr><td>实例配置</td><td>hystrix.command.HystrixCommandKey.metrics.rollingPercentile.numBuckets</td></tr></table><p><code>metrics.rollingPercentile.bucketSize</code>: 该属性用来设置在执行过程中每个“桶” 中保留的最大执行次数。如果在滚动时间窗内发生超过该设定值的执行次数，就从最初的位置开始重写。例如，将该值设置为100, 滚动窗口为10秒，若在10秒内一个“桶”中发生了500次执行，那么该“桶”中只保留最后的100次执行的统计。另外，增加该值的大小将会增加内存量的消耗，并增加排序百分位数所需的计算时间。</p><table><tr><th>属性级别</th><th>默认值、配置方式、配置属性</th></tr><tr><td>全局默认配置</td><td>100</td></tr><tr><td>全局配置</td><td>hystrix.command.default.metrics.rollingPercentile.bucketSize</td></tr><tr><td>实例默认值</td><td>@HystrixProperty(name=”metrics.rollingPercentile.bucketSize”,value= “120”)</td></tr><tr><td>实例配置</td><td>hystrix.command.HystrixCommandKey.metrics.rollingPercentile.bucketSize</td></tr></table><p><code>metrics.healthSnapshot.intervalinMilliseconds</code>: 该属性用来设置采集影响断路器状态的健康快照（请求的成功、错误百分比）的间隔等待时间。</p><table><tr><th>属性级别</th><th>默认值、配置方式、配置属性</th></tr><tr><td>全局默认配置</td><td>500</td></tr><tr><td>全局配置</td><td>hystrix.comrnand.default.metrics.healthSnapshot.intervalinMilliseconds</td></tr><tr><td>实例默认值</td><td>@HystrixProperty(name=”metrics.healthSnapshot.intervalinMilliseconds”,value=”600”)</td></tr><tr><td>实例配置</td><td>hystrix.command.HystrixCommandKey.metrics.healthSnapshot.intervalinMilliseconds</td></tr></table><h4 id="requestContext"><a href="#requestContext" class="headerlink" title="requestContext"></a>requestContext</h4><p><code>requestCache.enabled</code>: 此属性用来配置是否开启请求缓存。</p><table><tr><th>属性级别</th><th>默认值、配置方式、配置属性</th></tr><tr><td>全局默认配置</td><td>true</td></tr><tr><td>全局配置</td><td>hystrix.command.default.requestCache.enabled</td></tr><tr><td>实例默认值</td><td>@HystrixProperty(name=”requestCache.enabled”, value=”false”)</td></tr><tr><td>实例配置</td><td>hystrix.command.HystrixCommandKey.requestCache.enabled</td></tr></table><h3 id="collapser"><a href="#collapser" class="headerlink" title="collapser"></a>collapser</h3><p><code>maxRequestsinBatch</code>: 该参数用来设置一次请求合并批处理中允许的最大请求数。</p><table><tr><th>属性级别</th><th>默认值、配置方式、配置属性</th></tr><tr><td>全局默认配置</td><td>Integer.MAX_VALUE</td></tr><tr><td>全局配置</td><td>hystrix.collapser.default.maxRequestsinBatch</td></tr><tr><td>实例默认值</td><td>@HystrixProperty(name=”maxRequestsinBatch”,value=”false”)</td></tr><tr><td>实例配置</td><td>hystrix.collapser.HystrixCollapserKey.maxRequestsinBatch</td></tr></table><p><code>timerDelayinMilliseconds</code>: 该参数用来设置批处理过程中每个命令延迟的时间，单位为毫秒。</p><table><tr><th>属性级别</th><th>默认值、配置方式、配置属性</th></tr><tr><td>全局默认配置</td><td>10</td></tr><tr><td>全局配置</td><td>hystrix.collapser.default.timerDelayinMilliseconds</td></tr><tr><td>实例默认值</td><td>@HystrixProperty(name=”timerDelayinMilliseconds”,value=”20”)</td></tr><tr><td>实例配置</td><td>hystrix.collapser.HystrixCollapserKey.timerDelayinMilliseconds</td></tr></table><p><code>request Cache.enabled</code>: 该参数用来设置批处理过程中是否开启请求缓存。</p><table><tr><th>属性级别</th><th>默认值、配置方式、配置属性</th></tr><tr><td>全局默认配置</td><td>true</td></tr><tr><td>全局配置</td><td>hystrix.collapser.default.requestCache.enabled</td></tr><tr><td>实例默认值</td><td>@HystrixProperty(name=”requestCache.enabled”, value=”false”)</td></tr><tr><td>实例配置</td><td>hystrix.collapser.HystrixCollapserKey.requestCache.enabled</td></tr></table><h3 id="threadPool"><a href="#threadPool" class="headerlink" title="threadPool"></a>threadPool</h3><p><code>coreSize</code>: 该参数用来设置执行命令线程池的核心线程数，该值也就是命令执行的最大并发量。</p><table><tr><th>属性级别</th><th>默认值、配置方式、配置属性</th></tr><tr><td>全局默认配置</td><td>10</td></tr><tr><td>全局配置</td><td>hystrix.threadpool.default.coreSize</td></tr><tr><td>实例默认值</td><td>@HystrixProperty(name=”coreSize”, value=”false”)</td></tr><tr><td>实例配置</td><td>hystrix.threadpool.HystrixThreadPoolKey.coreSize</td></tr></table><p><code>maxQueueSize</code>: 该参数用来设置线程池的最大队列大小。当设置为-1时，线程池将使用<code>SynchronousQueue</code>实现的队列，否则将使用<code>LinkedBlockingQueue</code>实现的队列。</p><table><tr><th>属性级别</th><th>默认值、配置方式、配置属性</th></tr><tr><td>全局默认配置</td><td>-1</td></tr><tr><td>全局配置</td><td>hystrix.threadpool.default.maxQueueSize</td></tr><tr><td>实例默认值</td><td>@HystrixProperty(name=”maxQueueSize”,value=”lO”)</td></tr><tr><td>实例配置</td><td>hystrix.threadpool.HystrixThreadPoolKey.maxQueueSize</td></tr></table><p><code>queueSizeRejectionThreshold</code>: 该参数用来为队列设置拒绝阈值。通过该参数，即使队列没有达到最大值也能拒绝请求。该参数主要是对<code>LinkedBlockingQueue</code>队列的补充， 因为<code>LinkedBlockingQueue</code>队列不能动态修改它的对象大小，而通过该属性就可以调整拒绝请求的队列大小了。</p><table><tr><th>属性级别</th><th>默认值、配置方式、配置属性</th></tr><tr><td>全局默认配置</td><td>5</td></tr><tr><td>全局配置</td><td>hystrix.threadpool.default.queueSizeRejectionThreshold</td></tr><tr><td>实例默认值</td><td>@HystrixProperty(name=”queueSizeRejectionThreshold”, value=”lO”</td></tr><tr><td>实例配置</td><td>hystrix.threadpool.HystrixThreadPoolKey.queueSizeRejectionThreshold</td></tr></table><p>不得不说，配置是真的多……</p><p><img src="img/QQ图片20180713111516.gif" alt="QQ图片20180713111516.gif"></p><p>源码链接：<a href="https://github.com/wuyouzhuguli/Spring-Boot-Demos/tree/master/30.Spring-Cloud-Hystrix-Circuit-Breaker" target="_blank" rel="external">https://github.com/wuyouzhuguli/Spring-Boot-Demos/tree/master/30.Spring-Cloud-Hystrix-Circuit-Breaker</a></p><blockquote><p>参考文章 <a href="https://book.douban.com/subject/27025912/" target="_blank" rel="external">《Spring Cloud微服务实战》</a></p></blockquote><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Tue Aug 21 2018 16:24:25 GMT+0800 (中国标准时间) --&gt;&lt;p&gt;在微服务的架构中，服务间通常会形成相互依赖的关系，比如现在有三个微服务节点：A，B和C，B为A的消费者，C为B的消费者。假如由于网络波动或者A服务自身故障，导致B调用A服务的线程被挂起进入长时间的等待。在高并发的情况下可能导致B的资源被耗竭随之崩溃，从而导致C服务也不可用。这种连环式的雪崩效应在微服务中较为常见，为了解决这个问题，服务熔断技术应运而出。熔断一词来自电路学，指的是电路在出现短路状况时，“断路器”能够及时地切断故障电路，避免电路过载发热引发火灾。&lt;/p&gt;&lt;p&gt;类似的，微服务架构中的断路器能够及时地发现故障服务，并向服务调用方返回错误响应，而不是长时间的等待。Spring Cloud Hystrix在Hystrix（又是一款由Netflix开发的开源软件，Github地址&lt;a href=&quot;https://github.com/Netflix/Hystrix&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://github.com/Netflix/Hystrix&lt;/a&gt;）的基础上进行了封装，提供了服务熔断，服务降级，线程隔离等功能，通过这些功能可以提供服务的容错率。
    
    </summary>
    
    
      <category term="Spring" scheme="http://mrbird.cc/tags/Spring/"/>
    
      <category term="Spring Cloud" scheme="http://mrbird.cc/tags/Spring-Cloud/"/>
    
      <category term="Hystrix" scheme="http://mrbird.cc/tags/Hystrix/"/>
    
  </entry>
  
  <entry>
    <title>Spring Cloud Ribbon客户端负载均衡</title>
    <link href="http://mrbird.cc/Spring-Cloud-Ribbon-LoadBalance.html"/>
    <id>http://mrbird.cc/Spring-Cloud-Ribbon-LoadBalance.html</id>
    <published>2018-06-03T01:51:49.000Z</published>
    <updated>2018-07-06T09:02:36.023Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Tue Aug 21 2018 16:24:25 GMT+0800 (中国标准时间) --><p>为了提高服务的可用性，我们一般会将相同的服务部署多个实例，负载均衡的作用就是使获取服务的请求被均衡的分配到各个实例中。负载均衡一般分为<strong>服务端负载均衡</strong>和<strong>客户端负载均衡</strong>，服务端的负载均衡通过硬件（如F5）或者软件（如Nginx）来实现，而Ribbon实现的是客户端负载均衡。服务端负载均衡是在硬件设备或者软件模块中维护一份可用服务清单，然后客户端发送服务请求到这些负载均衡的设备上，这些设备根据一些算法均衡的将请求转发出去。而客户端负载均衡则是客户端自己从服务注册中心（如之前提到的Eureka Server）中获取服务清单缓存到本地，然后通过Ribbon内部算法均衡的去访问这些服务。<a id="more"></a></p><h2 id="Ribbon简介"><a href="#Ribbon简介" class="headerlink" title="Ribbon简介"></a>Ribbon简介</h2><p>Ribbon是由<a href="https://github.com/Netflix" target="_blank" rel="external">Netflix</a>开发的一款基于HTTP和TCP的负载均衡的开源软件。我们可以直接给Ribbon配置好服务列表清单，也可以配合Eureka主动的去获取服务清单，需要使用到这些服务的时候Ribbon通过轮询或者随机等均衡算法去获取服务。</p><p>在<a href="/Spring-Cloud-Eureka.html">Spring Cloud Eureka服务治理</a>一节中，我们已经在Server-Consumer中配置了Ribbon，并通过加了<code>@LoadBalanced</code>注解的RestTemplate对象去均衡的消费服务，所以这节主要记录的是RestTemplate的详细使用方法和一些额外的Ribbon配置。</p><h2 id="RestTemplate详解"><a href="#RestTemplate详解" class="headerlink" title="RestTemplate详解"></a>RestTemplate详解</h2><p>从名称上来看就可以知道它是一个用来发送REST请求的摸板，所以包含了GET,POST,PUT,DELETE等HTTP Method对应的方法。</p><h3 id="发送Get请求"><a href="#发送Get请求" class="headerlink" title="发送Get请求"></a>发送Get请求</h3><p>RestTemplate中与GET请求对应的方法有<code>getForEntity</code>和<code>getForObject</code>。</p><p><strong>getForEntity</strong></p><p><code>getForEntity</code>方法返回<code>ResponseEntity</code>对象，该对象包含了返回报文头，报文体和状态码等信息。<code>getForEntity</code>有三个重载方法：</p><ol><li><p><code>getForEntity(String url, Class&lt;T&gt; responseType, Object... uriVariables)</code>；</p></li><li><p><code>getForEntity(String url, Class&lt;T&gt; responseType, Map&lt;String, ?&gt; uriVariables)</code>；</p></li><li><p><code>getForEntity(URI url, Class&lt;T&gt; responseType)</code>；</p></li></ol><p>第一个参数为Url，第二个参数为返回值的类型，第三个参数为请求的参数（可以是数组，也可以是Map）。</p><p>举个<code>getForEntity(String url, Class&lt;T&gt; responseType, Object... uriVariables)</code>的使用例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@GetMapping</span>(<span class="string">"user/&#123;id:\\d+&#125;"</span>)</div><div class="line"><span class="function"><span class="keyword">public</span> User <span class="title">getUser</span><span class="params">(@PathVariable Long id)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.restTemplate.getForEntity(<span class="string">"http://Server-Provider/user/&#123;name&#125;"</span>, User.class, id).getBody();</div><div class="line">&#125;</div></pre></td></tr></table></figure><p></p><p><code>{1}</code>为参数的占位符，匹配参数数组的第一个元素。因为第二个参数指定了类型为User，所以调用<code>getBody</code>方法返回类型也为User。</p><p>方法参数除了可以放在数组里外，也可以放在Map里，举个<code>getForEntity(String url, Class&lt;T&gt; responseType, Map&lt;String, ?&gt; uriVariables)</code>使用例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@GetMapping</span>(<span class="string">"user/&#123;id:\\d+&#125;"</span>)</div><div class="line"><span class="function"><span class="keyword">public</span> User <span class="title">getUser</span><span class="params">(@PathVariable Long id)</span> </span>&#123;</div><div class="line">    Map&lt;String, Object&gt; params = <span class="keyword">new</span> HashMap&lt;&gt;();</div><div class="line">    params.put(<span class="string">"id"</span>, id);</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.restTemplate.getForEntity(<span class="string">"http://Server-Provider/user/&#123;id&#125;"</span>, User.class, params).getBody();</div><div class="line">&#125;</div></pre></td></tr></table></figure><p></p><p>只有两个参数的重载方法<code>getForEntity(URI url, Class&lt;T&gt; responseType)</code>第一个参数接收<code>java.net.URI</code>类型，可以通过<code>org.springframework.web.util.UriComponentsBuilder</code>来创建，举个该方法的使用例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@GetMapping</span>(<span class="string">"user/&#123;id:\\d+&#125;"</span>)</div><div class="line"><span class="function"><span class="keyword">public</span> User <span class="title">getUser</span><span class="params">(@PathVariable Long id)</span> </span>&#123;</div><div class="line">    Map&lt;String, Object&gt; params = <span class="keyword">new</span> HashMap&lt;&gt;();</div><div class="line">    params.put(<span class="string">"id"</span>, id);</div><div class="line">    URI uri = UriComponentsBuilder.fromUriString(<span class="string">"http://Server-Provider/user/&#123;id&#125;"</span>)</div><div class="line">            .build().expand(params).encode().toUri();</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.restTemplate.getForEntity(uri, User.class).getBody();</div><div class="line">&#125;</div></pre></td></tr></table></figure><p></p><p>其中<code>expand</code>方法也可以接收数组和Map两种类型的参数。</p><p><strong>getForObject</strong></p><p><code>getForObject</code>方法和<code>getForEntity</code>方法类似，<code>getForObject</code>方法相当于<code>getForEntity</code>方法调用了<code>getBody</code>方法，直接返回结果对象，为不是<code>ResponseEntity</code>对象。</p><p><code>getForObject</code>方法和<code>getForEntity</code>方法一样，也有三个重载方法，参数类型和<code>getForEntity</code>方法一致，所以不再列出。</p><h3 id="发送POST请求"><a href="#发送POST请求" class="headerlink" title="发送POST请求"></a>发送POST请求</h3><p>使用RestTemplate发送POST请求主要有<code>postForEntity</code>，<code>postForObject</code>和<code>postForLocation</code>（这个目前较少使用，所以不做介绍）三个方法。</p><p><code>postForEntity</code>和<code>postForObject</code>也分别有三个重载方法，方法参数和使用方式和上面介绍的<code>getForEntity</code>和<code>getForObject</code>一样，所以不再详细介绍。简单举个<code>getForObject</code>的使用例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"> <span class="meta">@GetMapping</span>(<span class="string">"user"</span>)</div><div class="line"><span class="function"><span class="keyword">public</span> List&lt;User&gt; <span class="title">getUsers</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.restTemplate.getForObject(<span class="string">"http://Server-Provider/user"</span>, List.class);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p></p><h3 id="发送PUT请求"><a href="#发送PUT请求" class="headerlink" title="发送PUT请求"></a>发送PUT请求</h3><p>使用RestTemplate发送PUT请求，使用的是它的<code>put</code>方法，<code>put</code>方法返回值是<code>void</code>类型，该方法也有三个重载方法：</p><ol><li><p><code>put(String url, Object request, Object... uriVariables)</code>；</p></li><li><p><code>put(String url, Object request, Map&lt;String, ?&gt; uriVariables)</code>；</p></li><li><p><code>put(URI url, Object request)</code>。</p></li></ol><p>举个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@GetMapping</span>(<span class="string">"user/update"</span>)</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateUser</span><span class="params">()</span> <span class="keyword">throws</span> JsonProcessingException </span>&#123;</div><div class="line">    User user = <span class="keyword">new</span> User(<span class="number">1L</span>, <span class="string">"mrbird"</span>, <span class="string">"123456"</span>);</div><div class="line">    <span class="keyword">this</span>.restTemplate.put(<span class="string">"http://Server-Provider/user"</span>, user);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p></p><p>在RESTful风格的接口中，判断成功失败不再是通过返回值的某个标识来判断的，而是通过返回报文的状态码是否为200来判断。当这个方法成功执行并返回时，返回报文状态为200，即可判断方法执行成功。</p><h3 id="发送DELETE请求"><a href="#发送DELETE请求" class="headerlink" title="发送DELETE请求"></a>发送DELETE请求</h3><p>使用RestTemplate发送DELETE请求，使用的是它的<code>delete</code>方法，<code>delete</code>方法返回值是<code>void</code>类型，该方法也有三个重载方法：</p><ol><li><p><code>delete(String url, Object... uriVariables)</code>；</p></li><li><p><code>delete(String url, Map&lt;String, ?&gt; uriVariables)</code>;</p></li><li><p><code>delete(URI url)</code>。</p></li></ol><p>举个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@GetMapping</span>(<span class="string">"user/delete/&#123;id:\\d+&#125;"</span>)</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteUser</span><span class="params">(@PathVariable Long id)</span> </span>&#123;</div><div class="line">    <span class="keyword">this</span>.restTemplate.delete(<span class="string">"http://Server-Provider/user/&#123;1&#125;"</span>, id);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p></p><h2 id="RestTemplates实战"><a href="#RestTemplates实战" class="headerlink" title="RestTemplates实战"></a>RestTemplates实战</h2><p>我们在<a href="/Spring-Cloud-Eureka.html">Spring Cloud Eureka服务治理</a>中的Eureka客户端（Server-Provider）中编写一套RESTful风格的测试接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@RestController</span></div><div class="line"><span class="meta">@RequestMapping</span>(<span class="string">"user"</span>)</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> Logger log = LoggerFactory.getLogger(<span class="keyword">this</span>.getClass());</div><div class="line"></div><div class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/&#123;id:\\d+&#125;"</span>)</div><div class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">get</span><span class="params">(@PathVariable Long id)</span> </span>&#123;</div><div class="line">        log.info(<span class="string">"获取用户id为 "</span> + id + <span class="string">"的信息"</span>);</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> User(id, <span class="string">"mrbird"</span>, <span class="string">"123456"</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@GetMapping</span></div><div class="line">    <span class="function"><span class="keyword">public</span> List&lt;User&gt; <span class="title">get</span><span class="params">()</span> </span>&#123;</div><div class="line">        List&lt;User&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">        list.add(<span class="keyword">new</span> User(<span class="number">1L</span>, <span class="string">"mrbird"</span>, <span class="string">"123456"</span>));</div><div class="line">        list.add(<span class="keyword">new</span> User(<span class="number">2L</span>, <span class="string">"scott"</span>, <span class="string">"123456"</span>));</div><div class="line">        log.info(<span class="string">"获取用户信息 "</span> + list);</div><div class="line">        <span class="keyword">return</span> list;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@PostMapping</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(@RequestBody User user)</span> </span>&#123;</div><div class="line">        log.info(<span class="string">"新增用户成功 "</span> + user);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@PutMapping</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(@RequestBody User user)</span> </span>&#123;</div><div class="line">        log.info(<span class="string">"更新用户成功 "</span> + user);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@DeleteMapping</span>(<span class="string">"/&#123;id:\\d+&#125;"</span>)</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">(@PathVariable Long id)</span> </span>&#123;</div><div class="line">        log.info(<span class="string">"删除用户成功 "</span> + id);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p></p><p>User对象代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1339434510787399891L</span>;</div><div class="line">    <span class="keyword">private</span> Long id;</div><div class="line">    <span class="keyword">private</span> String username;</div><div class="line">    <span class="keyword">private</span> String password;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">()</span> </span>&#123;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">(Long id, String username, String password)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.id = id;</div><div class="line">        <span class="keyword">this</span>.username = username;</div><div class="line">        <span class="keyword">this</span>.password = password;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="string">"User&#123;"</span> +</div><div class="line">                <span class="string">"id="</span> + id +</div><div class="line">                <span class="string">", username='"</span> + username + <span class="string">'\''</span> +</div><div class="line">                <span class="string">", password='"</span> + password + <span class="string">'\''</span> +</div><div class="line">                <span class="string">'&#125;'</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// get,set略</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><p></p><p>需要注意的是，User对象必须有默认的构造方法，否则在JSON与实体对象转换的时候会抛出如下异常：</p><div class="note danger"><p>JSON parse error: Can not construct instance of model.Class: no suitable constructor found</p></div><p></p><p>然后在Server-Consumer中使用RestTemplates分别去获取这些服务：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@RestController</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestController</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@Autowired</span></div><div class="line">    <span class="keyword">private</span> RestTemplate restTemplate;</div><div class="line"></div><div class="line">    <span class="meta">@GetMapping</span>(<span class="string">"user/&#123;id:\\d+&#125;"</span>)</div><div class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">getUser</span><span class="params">(@PathVariable Long id)</span> </span>&#123;</div><div class="line">        Map&lt;String, Object&gt; params = <span class="keyword">new</span> HashMap&lt;&gt;();</div><div class="line">        params.put(<span class="string">"id"</span>, id);</div><div class="line">        URI uri = UriComponentsBuilder.fromUriString(<span class="string">"http://Server-Provider/user/&#123;id&#125;"</span>)</div><div class="line">                .build().expand(params).encode().toUri();</div><div class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.restTemplate.getForEntity(uri, User.class).getBody();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@GetMapping</span>(<span class="string">"user"</span>)</div><div class="line">    <span class="function"><span class="keyword">public</span> List&lt;User&gt; <span class="title">getUsers</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.restTemplate.getForObject(<span class="string">"http://Server-Provider/user"</span>, List.class);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@GetMapping</span>(<span class="string">"user/add"</span>)</div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">addUser</span><span class="params">()</span> </span>&#123;</div><div class="line">        User user = <span class="keyword">new</span> User(<span class="number">1L</span>, <span class="string">"mrbird"</span>, <span class="string">"123456"</span>);</div><div class="line">        HttpStatus status = <span class="keyword">this</span>.restTemplate.postForEntity(<span class="string">"http://Server-Provider/user"</span>, user, <span class="keyword">null</span>).getStatusCode();</div><div class="line">        <span class="keyword">if</span> (status.is2xxSuccessful()) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="string">"新增用户成功"</span>;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">return</span> <span class="string">"新增用户失败"</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@GetMapping</span>(<span class="string">"user/update"</span>)</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateUser</span><span class="params">()</span> </span>&#123;</div><div class="line">        User user = <span class="keyword">new</span> User(<span class="number">1L</span>, <span class="string">"mrbird"</span>, <span class="string">"123456"</span>);</div><div class="line">        <span class="keyword">this</span>.restTemplate.put(<span class="string">"http://Server-Provider/user"</span>, user);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@GetMapping</span>(<span class="string">"user/delete/&#123;id:\\d+&#125;"</span>)</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteUser</span><span class="params">(@PathVariable Long id)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.restTemplate.delete(<span class="string">"http://Server-Provider/user/&#123;1&#125;"</span>, id);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p></p><p>我们分别启动两个Eureka Server用于集群，两个Eureka Client（Server-Provider）实例，然后启动Server-Consumer。</p><p>使用Restlet Client访问<a href="http://localhost:9000/user/1" target="_blank" rel="external">http://localhost:9000/user/1</a>（<span>后面每个方法我们都访问两次，用于观察负载均衡</span>），返回结果如下：</p><p><img src="img/QQ截图20180705173808.png" alt="QQ截图20180705173808.png"></p><p>剩下的方法测试结果这里不贴出来了，当我们分别访问下面的连接后：</p><ul><li><p><a href="http://localhost:9000/user/" target="_blank" rel="external">http://localhost:9000/user/</a></p></li><li><p><a href="http://localhost:9000/user/add" target="_blank" rel="external">http://localhost:9000/user/add</a></p></li><li><p><a href="http://localhost:9000/user/update" target="_blank" rel="external">http://localhost:9000/user/update</a></p></li><li><p><a href="http://localhost:9000/user/delete/1" target="_blank" rel="external">http://localhost:9000/user/delete/1</a></p></li></ul><p>查看Eureka客户端8082和8083的后台日志：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">2018-06-03 18:17:26.231  INFO 11188 --- [           main] .s.c.n.e.s.EurekaAutoServiceRegistration : Updating port to 8083</div><div class="line">2018-06-03 18:17:26.236  INFO 11188 --- [           main] com.example.demo.DemoApplication         : Started DemoApplication in 52.252 seconds (JVM running for 54.321)</div><div class="line">2018-06-03 18:21:29.097  INFO 11188 --- [io-8083-exec-10] o.a.c.c.C.[Tomcat].[localhost].[/]       : Initializing Spring FrameworkServlet &apos;dispatcherServlet&apos;</div><div class="line">2018-06-03 18:21:29.098  INFO 11188 --- [io-8083-exec-10] o.s.web.servlet.DispatcherServlet        : FrameworkServlet &apos;dispatcherServlet&apos;: initialization started</div><div class="line">2018-06-03 18:21:29.177  INFO 11188 --- [io-8083-exec-10] o.s.web.servlet.DispatcherServlet        : FrameworkServlet &apos;dispatcherServlet&apos;: initialization completed in 79 ms</div><div class="line">2018-06-03 18:21:29.312  INFO 11188 --- [io-8083-exec-10] c.e.demo.controller.UserController       : 获取用户id为 1的信息</div><div class="line">2018-06-03 18:21:50.798  INFO 11188 --- [nio-8083-exec-9] c.e.demo.controller.UserController       : 获取用户信息 [User&#123;id=1, username=&apos;mrbird&apos;, password=&apos;123456&apos;&#125;, User&#123;id=2, username=&apos;scott&apos;, password=&apos;123456&apos;&#125;]</div><div class="line">2018-06-03 18:22:25.351  INFO 11188 --- [trap-executor-0] c.n.d.s.r.aws.ConfigClusterResolver      : Resolving eureka endpoints via configuration</div><div class="line">2018-06-03 18:22:44.718  INFO 11188 --- [nio-8083-exec-8] c.e.demo.controller.UserController       : 新增用户成功 User&#123;id=1, username=&apos;mrbird&apos;, password=&apos;123456&apos;&#125;</div><div class="line">2018-06-03 18:24:34.313  INFO 11188 --- [nio-8083-exec-6] c.e.demo.controller.UserController       : 删除用户成功 1</div><div class="line"></div><div class="line"></div><div class="line">2018-06-03 18:17:21.296  INFO 16188 --- [           main] .s.c.n.e.s.EurekaAutoServiceRegistration : Updating port to 8082</div><div class="line">2018-06-03 18:17:21.303  INFO 16188 --- [           main] com.example.demo.DemoApplication         : Started DemoApplication in 57.152 seconds (JVM running for 58.239)</div><div class="line">2018-06-03 18:21:27.517  INFO 16188 --- [io-8082-exec-10] o.a.c.c.C.[Tomcat].[localhost].[/]       : Initializing Spring FrameworkServlet &apos;dispatcherServlet&apos;</div><div class="line">2018-06-03 18:21:27.517  INFO 16188 --- [io-8082-exec-10] o.s.web.servlet.DispatcherServlet        : FrameworkServlet &apos;dispatcherServlet&apos;: initialization started</div><div class="line">2018-06-03 18:21:27.567  INFO 16188 --- [io-8082-exec-10] o.s.web.servlet.DispatcherServlet        : FrameworkServlet &apos;dispatcherServlet&apos;: initialization completed in 50 ms</div><div class="line">2018-06-03 18:21:27.732  INFO 16188 --- [io-8082-exec-10] c.e.demo.controller.UserController       : 获取用户id为 1的信息</div><div class="line">2018-06-03 18:21:49.639  INFO 16188 --- [nio-8082-exec-9] c.e.demo.controller.UserController       : 获取用户信息 [User&#123;id=1, username=&apos;mrbird&apos;, password=&apos;123456&apos;&#125;, User&#123;id=2, username=&apos;scott&apos;, password=&apos;123456&apos;&#125;]</div><div class="line">2018-06-03 18:22:12.313  INFO 16188 --- [trap-executor-0] c.n.d.s.r.aws.ConfigClusterResolver      : Resolving eureka endpoints via configuration</div><div class="line">2018-06-03 18:22:46.111  INFO 16188 --- [nio-8082-exec-8] c.e.demo.controller.UserController       : 新增用户成功 User&#123;id=1, username=&apos;mrbird&apos;, password=&apos;123456&apos;&#125;</div><div class="line">2018-06-03 18:23:55.732  INFO 16188 --- [nio-8082-exec-6] c.e.demo.controller.UserController       : 更新用户成功 User&#123;id=1, username=&apos;mrbird&apos;, password=&apos;123456&apos;&#125;</div><div class="line">2018-06-03 18:23:58.297  INFO 16188 --- [nio-8082-exec-5] c.e.demo.controller.UserController       : 更新用户成功 User&#123;id=1, username=&apos;mrbird&apos;, password=&apos;123456&apos;&#125;</div><div class="line">2018-06-03 18:24:37.266  INFO 16188 --- [nio-8082-exec-3] c.e.demo.controller.UserController       : 删除用户成功 1</div><div class="line">2018-06-03 18:27:12.314  INFO 16188 --- [trap-executor-0] c.n.d.s.r.aws.ConfigClusterResolver      : Resolving eureka endpoints via configuration</div></pre></td></tr></table></figure><p></p><p>发现方法都成功调用，并且是均衡的。</p><h2 id="Spring-Cloud-Ribbon配置"><a href="#Spring-Cloud-Ribbon配置" class="headerlink" title="Spring Cloud Ribbon配置"></a>Spring Cloud Ribbon配置</h2><p>Spring Cloud Ribbon的配置分为全局和指定服务名称。比如我要指定全局的服务请求连接超时时间为200毫秒：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="attr">ribbon:</span></div><div class="line"><span class="attr">  ConnectTimeout:</span> <span class="number">200</span></div></pre></td></tr></table></figure><p></p><p>如果只是设置获取Server Provider服务的请求连接超时时间，我们只需要在配置最前面加上服务名称就行了，如：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="attr">Server-Provider:</span></div><div class="line"><span class="attr">  ribbon:</span></div><div class="line"><span class="attr">    ConnectTimeout:</span> <span class="number">200</span></div></pre></td></tr></table></figure><p></p><p>设置获取Server-Provider服务的负载均衡算法从轮询改为随机：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="attr">Server-Provider:</span></div><div class="line"><span class="attr">  ribbon:</span></div><div class="line"><span class="attr">    NFLoadBalancerRuleClassName:</span> <span class="string">com.netflix.loadbalancer.RandomRule</span></div></pre></td></tr></table></figure><p></p><p>设置处理Server-Provider服务的超时时间：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="attr">Server-Provider:</span></div><div class="line"><span class="attr">  ribbon:</span></div><div class="line"><span class="attr">    ReadTimeout:</span> <span class="number">1000</span></div></pre></td></tr></table></figure><p></p><p>开启重试机制，即获取服务失败是否从另外一个节点重试，默认值为false：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="attr">spring:</span></div><div class="line"><span class="attr">  cloud:</span></div><div class="line"><span class="attr">    loadbalancer:</span></div><div class="line"><span class="attr">      retry:</span></div><div class="line"><span class="attr">        enabled:</span> <span class="literal">true</span></div></pre></td></tr></table></figure><p></p><p>对Server-Provider的所有请求在失败的时候都进行重试：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="attr">Server-Provider:</span></div><div class="line"><span class="attr">  ribbon:</span></div><div class="line"><span class="attr">    OkToRetryOnAllOperations:</span> <span class="literal">true</span></div></pre></td></tr></table></figure><p></p><p>切换Server-Provider实例的重试次数：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="attr">Server-Provider:</span></div><div class="line"><span class="attr">  ribbon:</span></div><div class="line"><span class="attr">    MaxAutoRetriesNextServer:</span> <span class="number">1</span></div></pre></td></tr></table></figure><p></p><p>对Server-Provider当前实例的重试次数：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="attr">Server-Provider:</span></div><div class="line"><span class="attr">  ribbon:</span></div><div class="line"><span class="attr">    MaxAutoRetries:</span> <span class="number">1</span></div></pre></td></tr></table></figure><p></p><p>根据如上配置当访问Server-Provider服务实例（比如是8082）遇到故障的时候，Ribbon会再尝试访问一次当前实例（次数由MaxAutoRetries配置），如果不行，就换到8083实例进行访问（更换次数由 MaxAutoRetriesNextServer决定），如果还是不行，那就GG思密达，返回失败。</p><p>如果不和Eureka搭配使用的话，我们就需要手动指定服务清单给Ribbon：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="attr">Server-Provider:</span></div><div class="line"><span class="attr">  ribbon:</span></div><div class="line"><span class="attr">    listOfServers:</span> <span class="attr">localhost:8082,localhost:8083</span></div></pre></td></tr></table></figure><p></p><p>上面配置了名称为Server-Provider的服务，有两个节点可供使用（8082和8083）。</p><p>源码链接：<a href="">待上传</a></p><blockquote><p>参考文章 <a href="https://book.douban.com/subject/27025912/" target="_blank" rel="external">《Spring Cloud微服务实战》</a></p></blockquote><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Tue Aug 21 2018 16:24:25 GMT+0800 (中国标准时间) --&gt;&lt;p&gt;为了提高服务的可用性，我们一般会将相同的服务部署多个实例，负载均衡的作用就是使获取服务的请求被均衡的分配到各个实例中。负载均衡一般分为&lt;strong&gt;服务端负载均衡&lt;/strong&gt;和&lt;strong&gt;客户端负载均衡&lt;/strong&gt;，服务端的负载均衡通过硬件（如F5）或者软件（如Nginx）来实现，而Ribbon实现的是客户端负载均衡。服务端负载均衡是在硬件设备或者软件模块中维护一份可用服务清单，然后客户端发送服务请求到这些负载均衡的设备上，这些设备根据一些算法均衡的将请求转发出去。而客户端负载均衡则是客户端自己从服务注册中心（如之前提到的Eureka Server）中获取服务清单缓存到本地，然后通过Ribbon内部算法均衡的去访问这些服务。
    
    </summary>
    
    
      <category term="Spring" scheme="http://mrbird.cc/tags/Spring/"/>
    
      <category term="Spring Cloud" scheme="http://mrbird.cc/tags/Spring-Cloud/"/>
    
      <category term="Ribbon" scheme="http://mrbird.cc/tags/Ribbon/"/>
    
  </entry>
  
  <entry>
    <title>Spring Cloud Eureka服务治理</title>
    <link href="http://mrbird.cc/Spring-Cloud-Eureka.html"/>
    <id>http://mrbird.cc/Spring-Cloud-Eureka.html</id>
    <published>2018-06-01T08:59:43.000Z</published>
    <updated>2018-08-21T07:57:24.786Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Tue Aug 21 2018 16:24:25 GMT+0800 (中国标准时间) --><p>考虑当前有两个微服务实例A和B，A服务需要调用B服务的某个REST接口。假如某一天B服务迁移到了另外一台服务器，IP和端口也发生了变化，这时候我们不得不去修改A服务中调用B服务REST接口的静态配置。随着公司业务的发展，微服务的数量也越来越多，服务间的关系可能变得非常复杂，传统的微服务维护变得愈加困难，也很容易出错。所谓服务治理就是用来实现各个微服务实例的自动化注册与发现，在这种模式下，服务间的调用不再通过指定具体的实例地址来实现，而是通过向服务注册中心获取服务名并发起请求调用实现。<a id="more"></a></p><p>Eureka是由<a href="https://github.com/Netflix" target="_blank" rel="external">Netflix</a>开发的一款服务治理开源框架，Spring-cloud对其进行了集成。Eureka既包含了服务端也包含了客户端，Eureka服务端是一个<strong>服务注册中心(Eureka Server)</strong>，提供服务的注册和发现，即当前有哪些服务注册进来可供使用；Eureka客户端为<strong>服务提供者(Server Provider)</strong>，它将自己提供的服务注册到Eureka服务端，并周期性地发送心跳来更新它的服务租约，同时也能从服务端查询当前注册的服务信息并把它们缓存到本地并周期性地刷新服务状态。这样<strong>服务消费者(Server Consumer)</strong>便可以从服务注册中心获取服务名称，并消费服务。</p><p>三者关系如下图所示:</p><p><img src="img/687474703a2f2f6e6f74652e796f7564616f2e636f6d2f7977732f6170692f706572736f6e616c2f66696c652f33363341343841303839344634334330394143433739433042443237383335443f6d6574686f643d646f776e6c6f61642673686172654b65793d61.png" alt="687474703a2f2f6e6f74652e796f7564616f2e636f6d2f7977732f6170692f706572736f6e616c2f66696c652f33363341343841303839344634334330394143433739433042443237383335443f6d6574686f643d646f776e6c6f61642673686172654b65793d61.png"></p><h2 id="搭建Eureka-Server服务注册中心"><a href="#搭建Eureka-Server服务注册中心" class="headerlink" title="搭建Eureka-Server服务注册中心"></a>搭建Eureka-Server服务注册中心</h2><p>说了那么多，我们先来搭建一个Eureka服务端来充当服务注册中心。</p><p>新建一个Spring Boot项目，<code>artifactId</code>填Eureka-Service，然后引入<code>Spring Cloud Edgware.SR3</code>和<code>spring-cloud-starter-eureka-server</code>:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>Edgware.SR3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-eureka-server<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></div></pre></td></tr></table></figure><p></p><p>在启动类上添加<code>@EnableEurekaServer</code>注解，表明这是一个Eureka服务端：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@EnableEurekaServer</span></div><div class="line"><span class="meta">@SpringBootApplication</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoApplication</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        SpringApplication.run(DemoApplication.class, args);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p></p><p>接着在application.yml中添加一些配置：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="attr">server:</span></div><div class="line"><span class="attr">  port:</span> <span class="number">8080</span></div><div class="line">  </div><div class="line"><span class="attr">eureka:</span></div><div class="line"><span class="attr">  instance:</span></div><div class="line"><span class="attr">    hostname:</span> <span class="string">localhost</span></div><div class="line"><span class="attr">  client:</span></div><div class="line"><span class="attr">    register-with-eureka:</span> <span class="literal">false</span></div><div class="line"><span class="attr">    fetch-registry:</span> <span class="literal">false</span></div><div class="line"><span class="attr">    serviceUrl:</span></div><div class="line"><span class="attr">      defaultZone:</span> <span class="attr">http://$&#123;eureka.instance.hostname&#125;:$&#123;server.port&#125;/eureka/</span></div></pre></td></tr></table></figure><p></p><p>上面配置了服务的端口为8080，剩下几个为Eureka配置：</p><ul><li><p><code>eureka.instance.hostname</code>指定了Eureka服务端的IP；</p></li><li><p><code>eureka.client.register-with-eureka</code>表示是否将服务注册到Eureka服务端，由于自身就是Eureka服务端，所以设置为false；</p></li><li><p><code>eureka.client.fetch-registry</code>表示是否从Eureka服务端获取服务信息，因为这里只搭建了一个Eureka服务端，并不需要从别的Eureka服务端同步服务信息，所以这里设置为false；</p></li><li><p><code>eureka.client.serviceUrl.defaultZone</code>指定Eureka服务端的地址，默认值为<code>http://localhost:8761/eureka</code>。</p></li></ul><p>配置完毕后启动服务，访问<a href="http://localhost:8080/" target="_blank" rel="external">http://localhost:8080/</a>，可看到：</p><p><img src="img/QQ截图20180703185733.png" alt="QQ截图20180703185733.png"></p><p>由于还没有Eureka客户端将服务注册进来，所以Instances currently registered with Eureka列表是空的。</p><p>下面我们接着搭建一个Eureka客户端来提供服务。</p><h2 id="搭建Eureka-Client服务提供者"><a href="#搭建Eureka-Client服务提供者" class="headerlink" title="搭建Eureka-Client服务提供者"></a>搭建Eureka-Client服务提供者</h2><p>新建一个Spring Boot项目，<code>artifactId</code>填Eureka-Client，然后引入以下依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>Edgware.SR3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-eureka<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></div></pre></td></tr></table></figure><p></p><p>接着编写一个TestController，对外提供一些REST服务：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@RestController</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestController</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> Logger log = LoggerFactory.getLogger(<span class="keyword">this</span>.getClass());</div><div class="line"></div><div class="line">    <span class="meta">@Autowired</span></div><div class="line">    <span class="keyword">private</span> DiscoveryClient client;</div><div class="line"></div><div class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/info"</span>)</div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">info</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="meta">@SuppressWarnings</span>(<span class="string">"deprecation"</span>)</div><div class="line">        ServiceInstance instance = client.getLocalServiceInstance();</div><div class="line">        String info = <span class="string">"host："</span> + instance.getHost() + <span class="string">"，service_id："</span> + instance.getServiceId();</div><div class="line">        log.info(info);</div><div class="line">        <span class="keyword">return</span> info;</div><div class="line">    &#125;</div><div class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/hello"</span>)</div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="string">"hello world"</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p></p><p>上面代码注入了<code>org.springframework.cloud.client.discovery.DiscoveryClient</code>对象，可以获取当前服务的一些信息。</p><p>编写启动类，在启动类上加<code>@EnableDiscoveryClient</code>注解，表明这是一个Eureka客户端：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@EnableDiscoveryClient</span></div><div class="line"><span class="meta">@SpringBootApplication</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoApplication</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        SpringApplication.run(DemoApplication.class, args);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p></p><p>最后配置application.yml：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="attr">server:</span></div><div class="line"><span class="attr">  port:</span> <span class="number">8082</span></div><div class="line">  </div><div class="line"><span class="attr">spring:</span></div><div class="line"><span class="attr">  application:</span></div><div class="line"><span class="attr">    name:</span> <span class="string">Server-Provider</span></div><div class="line">    </div><div class="line"><span class="attr">eureka:</span></div><div class="line"><span class="attr">  client:</span></div><div class="line"><span class="attr">    register-with-eureka:</span> <span class="literal">true</span></div><div class="line"><span class="attr">    fetch-registry:</span> <span class="literal">true</span></div><div class="line"><span class="attr">    serviceUrl:</span></div><div class="line"><span class="attr">      defaultZone:</span> <span class="attr">http://localhost:8080/eureka/</span></div></pre></td></tr></table></figure><p></p><p>稍微说明下这些配置的意思：</p><ul><li><p><code>server.port</code>指定了服务的端口为8082；</p></li><li><p><code>spring.application.name</code>指定服务名称为<code>Server-Provider</code>，后续服务消费者要获取上面TestController中接口的时候会用到这个服务名；</p></li><li><p><code>eureka.client.serviceUrl.defaultZone</code>指定Eureka服务端的地址，这里为上面定义的Eureka服务端地址；</p></li><li><p><code>eureka.client.register-with-eureka</code>和<code>eureka.client.fetch-registry</code>上面已经解释了其意思，虽然这两个配置的默认值就是true，但这里还是显式配置下，使Eureka客户端的功能更为直观（即向服务端注册服务并定时从服务端获取服务缓存到本地）。</p></li></ul><p>配置好后，启动Eureka-Client，可以从控制台中看到注册成功的消息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">Registered Applications size is zero : true</div><div class="line">Application version is -1: true</div><div class="line">Getting all instance registry info from the eureka server</div><div class="line">The response status is 200</div><div class="line">Starting heartbeat executor: renew interval is: 30</div><div class="line">InstanceInfoReplicator onDemand update allowed rate per min is 4</div><div class="line">Discovery Client initialized at timestamp 1530667498944 with initial instances </div><div class="line">Registering application Server-Provider with eureka with status UP</div><div class="line">Saw local status change event StatusChangeEvent [timestamp=1530667498949, current=UP, previous=STARTING] </div><div class="line">DiscoveryClient_SERVER-PROVIDER/192.168.73.109:Server-Provider:8082: registering service... </div><div class="line">DiscoveryClient_SERVER-PROVIDER/192.168.73.109:Server-Provider:8082 - registration status: 204</div><div class="line">Tomcat started on port(s): 8082 (http)</div><div class="line">Updating port to 8082</div><div class="line">Started DemoApplication in 7.007 seconds (JVM running for 8.355)</div></pre></td></tr></table></figure><p>第3，4行输出表示已经成功从Eureka服务端获取到了服务；第5行表示发送心跳给Eureka服务端，续约（renew）服务；第8到11行表示已经成功将服务注册到了Eureka服务端。</p><p>再次访问<a href="http://localhost:8080/" target="_blank" rel="external">http://localhost:8080/</a>，可看到服务列表里已经出现了名字为Server-providerde服务了：</p><p><img src="img/QQ截图20180704085804.png" alt="QQ截图20180704085804.png"></p><p>UP表示在线的意思（如果Eureka客户端正常关闭，那么这里的状态将变为DOWN），点击后面的链接<a href="192.168.73.109:Server-Provider:8082" target="_blank" rel="external">192.168.73.109:Server-Provider:8082</a>将访问该服务的<code>/info</code>接口：</p><p><img src="img/QQ截图20180704090853.png" alt="QQ截图20180704090853.png"></p><p>这时候关闭Eureka客户端，再次刷新<a href="http://localhost:8080/" target="_blank" rel="external">http://localhost:8080/</a>：</p><p><img src="img/QQ截图20180704091123.png" alt="QQ截图20180704091123.png"></p><p>可看到虽然Eureka客户端已经关闭了，但是Eureka服务端页面的服务服务列表中依然还有该服务，并且页面红色文字提示：</p><div class="note danger"><p>EMERGENCY! EUREKA MAY BE INCORRECTLY CLAIMING INSTANCES ARE UP WHEN THEY’RE NOT. RENEWALS ARE LESSER THAN THRESHOLD AND HENCE THE INSTANCES ARE NOT BEING EXPIRED JUST TO BE SAFE.</p></div><p>大致意思是Eureka已经进入了<strong>保护模式</strong>。微服务在部署之后可能由于网络问题造成Eureka客户端无法成功的发送心跳给Eureka服务端，这时候Eureka服务端认定Eureka客户端已经挂掉了，虽然实际上Eureka客户端还在正常的运行着。而保护模式就是为了解决这个问题，即当Eureka服务端在短时间内同时丢失了过多的Eureka客户端时，Eureka服务端会进入保护模式，不去剔除这些客户端。因为我们这里只部署了一个Eureka客户端服务，所以关闭客户端后满足“短时间内丢失过多Eureka客户端”的条件。</p><p>在开发中可以先将保护模式给关了，我们在Eureka服务端加上一条配置:</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="attr">eureka:</span></div><div class="line"><span class="attr">  server:</span></div><div class="line"><span class="attr">    enable-self-preservation:</span> <span class="literal">false</span></div></pre></td></tr></table></figure><p></p><h2 id="Eureka-Server集群"><a href="#Eureka-Server集群" class="headerlink" title="Eureka-Server集群"></a>Eureka-Server集群</h2><p>Eureka服务端充当了重要的角色，所有Eureka客户端都将自己提供的服务注册到Eureka服务端，然后供所有服务消费者使用。如果单节点的Eureka服务端宕机了，那么所有服务都无法正常的访问，这必将是灾难性的。为了提高Eureka服务端的可用性，我们一般会对其集群部署，即同时部署多个Eureka服务端，并且可以相互间同步服务。</p><p>在搭建Eureka服务端的时候我们曾把下面两个配置给关闭了：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="attr">eureka:</span></div><div class="line"><span class="attr">  client:</span></div><div class="line"><span class="attr">    register-with-eureka:</span> <span class="literal">false</span></div><div class="line"><span class="attr">    fetch-registry:</span> <span class="literal">false</span></div></pre></td></tr></table></figure><p></p><p>实际上在Eureka集群模式中，开启这两个参数可以让当前Eureka服务端将自己也作为服务注册到别的Eureka服务端，并且从别的Eureka服务端获取服务进行同步。所以这里我们将这两个参数置为true（默认就是true），下面开始搭建Eureka服务端集群，为了简单起见这里只搭建两个节点的Eureka服务端集群。</p><p>在Eureka-Server项目的<code>src/main/resource</code>目录下新建application-peer1.yml，配置如下：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="attr">server:</span></div><div class="line"><span class="attr">  port:</span> <span class="number">8080</span></div><div class="line"></div><div class="line"><span class="attr">spring:</span></div><div class="line"><span class="attr">  application:</span></div><div class="line"><span class="attr">    name:</span> <span class="string">Eureka-Server</span></div><div class="line"></div><div class="line"><span class="attr">eureka:</span></div><div class="line"><span class="attr">  instance:</span></div><div class="line"><span class="attr">    hostname:</span> <span class="string">peer1</span></div><div class="line"><span class="attr">  client:</span></div><div class="line"><span class="attr">    serviceUrl:</span></div><div class="line"><span class="attr">      defaultZone:</span> <span class="attr">http://peer2:8081/eureka/</span></div><div class="line"><span class="attr">  server:</span></div><div class="line"><span class="attr">    enable-self-preservation:</span> <span class="literal">false</span></div></pre></td></tr></table></figure><p></p><p><code>server.port=8080</code>指定端口为8080；<code>spring.application.name=Eureka-Server</code>指定了服务名称为Eureka-Server；<code>eureka.instance.hostname=peer1</code>指定地址为peer1；<code>eureka.client.serviceUrl.defaultZone=http://peer2:8081/eureka/</code>指定Eureka服务端的地址为另外一个Eureka服务端的地址peer2。</p><p>下面我们创建另外一个Eureka服务端peer2的yml配置application-peer2.yml：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="attr">server:</span></div><div class="line"><span class="attr">  port:</span> <span class="number">8081</span></div><div class="line"></div><div class="line"><span class="attr">spring:</span></div><div class="line"><span class="attr">  application:</span></div><div class="line"><span class="attr">    name:</span> <span class="string">Eureka-Server</span></div><div class="line"></div><div class="line"><span class="attr">eureka:</span></div><div class="line"><span class="attr">  instance:</span></div><div class="line"><span class="attr">    hostname:</span> <span class="string">peer2</span></div><div class="line"><span class="attr">  client:</span></div><div class="line"><span class="attr">    serviceUrl:</span></div><div class="line"><span class="attr">      defaultZone:</span> <span class="attr">http://peer1:8080/eureka/</span></div><div class="line"><span class="attr">  server:</span></div><div class="line"><span class="attr">    enable-self-preservation:</span> <span class="literal">false</span></div></pre></td></tr></table></figure><p></p><p>peer2中的<code>serviceUrl</code>我们指向Eureka服务端peer1。</p><p>为了让这种在一台机器上配置两个hostname的方式生效，我们需要修改下hosts文件（位置C:\Windows\System32\drivers\etc）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">127.0.0.1       peer1</div><div class="line">127.0.0.1       peer2</div></pre></td></tr></table></figure><p></p><p>我们将Eureka-Server项目打包成jar，然后分别运行以下两条命令来部署peer1和peer2：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">java -jar Eureka-Service-0.0.1-SNAPSHOT.jar --spring-profiles-active=peer1</div><div class="line">java -jar Eureka-Service-0.0.1-SNAPSHOT.jar --spring-profiles-active=peer2</div></pre></td></tr></table></figure><p></p><p>启动后，我们来访问peer1<a href="http://localhost:8080/" target="_blank" rel="external">http://localhost:8080/</a>：</p><p><img src="img/QQ截图20180704100749.png" alt="QQ截图20180704100749.png"></p><p>可看到DS Replicas(副本)指向了peer2，registered-replicas和available-replicas都指向了<a href="http://peer2:8081/eureka/" target="_blank" rel="external">http://peer2:8081/eureka/</a>。</p><p>访问<a href="http://localhost:8081/" target="_blank" rel="external">http://localhost:8081/</a>我们也可以看到类似的信息。</p><p>因为Eureka服务端做了集群处理，所以Eureka客户端指定的服务端地址也要进行修改：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="attr">eureka:</span></div><div class="line"><span class="attr">  client:</span></div><div class="line"><span class="attr">    serviceUrl:</span></div><div class="line"><span class="attr">      defaultZone:</span> <span class="attr">http://peer1:8080/eureka/,http://peer2:8081/eureka/</span></div></pre></td></tr></table></figure><p></p><p>我们将Eureka客户端（Server-Provider）打成jar包，然后分别用端口8082和8083启动两个服务：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">java -jar Eureka-Client-0.0.1-SNAPSHOT.jar --server.port=8082</div><div class="line">java -jar Eureka-Client-0.0.1-SNAPSHOT.jar --server.port=8083</div></pre></td></tr></table></figure><p></p><p>然后访问<a href="http://peer2:8080/eureka/" target="_blank" rel="external">http://peer2:8080/eureka/</a>或者<a href="http://peer2:8081/eureka/" target="_blank" rel="external">http://peer2:8081/eureka/</a>： <img src="img/QQ截图20180704104219.png" alt="QQ截图20180704104219.png"></p><h2 id="搭建Server-Consumer服务消费者"><a href="#搭建Server-Consumer服务消费者" class="headerlink" title="搭建Server-Consumer服务消费者"></a>搭建Server-Consumer服务消费者</h2><p>在实际项目中，Eureka客户端即是服务提供者，也是服务消费者，即自身的接口可能被别的服务访问，同时也可能调用别的服务接口。这里为了更好的演示，我们把服务消费者单独的分开来演示。</p><p>新建一个Spring Boot项目，<code>artifactId</code>填Server-Consumer，其主要的任务就是将自身的服务注册到Eureka服务端，并且获取Eureka服务端提供的服务并进行消费。这里服务的消费我们用<a href="https://github.com/Netflix/ribbon" target="_blank" rel="external">Ribbon</a>来完成，Ribbon是一款实现服务负载均衡的开源软件，这里不做详细介绍。</p><p>引入Eureka客户端和Ribbon依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>Edgware.SR3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-eureka<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-ribbon<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></div></pre></td></tr></table></figure><p></p><p>同样的，在入口类中加入<code>@EnableDiscoveryClient</code>注解用于发现服务和注册服务，并配置一个<code>RestTemplate Bean</code>，然后加上<code>@LoadBalanced</code>注解来开启负载均衡：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</div><div class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</div><div class="line"><span class="keyword">import</span> org.springframework.cloud.client.discovery.EnableDiscoveryClient;</div><div class="line"><span class="keyword">import</span> org.springframework.cloud.client.loadbalancer.LoadBalanced;</div><div class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</div><div class="line"><span class="keyword">import</span> org.springframework.web.client.RestTemplate;</div><div class="line"></div><div class="line"><span class="meta">@EnableDiscoveryClient</span></div><div class="line"><span class="meta">@SpringBootApplication</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoApplication</span> </span>&#123;</div><div class="line">    <span class="meta">@Bean</span></div><div class="line">    <span class="meta">@LoadBalanced</span></div><div class="line">    <span class="function">RestTemplate <span class="title">restTemplate</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> RestTemplate();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        SpringApplication.run(DemoApplication.class, args);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p></p><p>接着编写一个TestController，用于消费服务：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@RestController</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestController</span> </span>&#123;</div><div class="line">    <span class="meta">@Autowired</span></div><div class="line">    <span class="keyword">private</span> RestTemplate restTemplate;</div><div class="line"></div><div class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/info"</span>)</div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getInfo</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.restTemplate.getForEntity(<span class="string">"http://Server-Provider/info"</span>, String.class).getBody();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p></p><p>上面代码注入了<code>RestTemplate</code>，<code>getInfo</code>中使用<code>RestTemplate</code>对象均衡的去获取服务并消费。可以看到我们使用服务名称（Server-Provider）去获取服务的，而不是使用传统的IP加端口的形式。这就体现了使用Eureka去获取服务的好处，我们只要保证这个服务名称不变即可，IP和端口不再是我们关心的点。</p><p>最后编写下配置文件application.yml：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="attr">server:</span></div><div class="line"><span class="attr">  port:</span> <span class="number">9000</span></div><div class="line">  </div><div class="line"><span class="attr">spring:</span></div><div class="line"><span class="attr">  application:</span></div><div class="line"><span class="attr">    name:</span> <span class="string">Server-Consumer</span></div><div class="line">    </div><div class="line"><span class="attr">eureka:</span></div><div class="line"><span class="attr">  client:</span></div><div class="line"><span class="attr">    serviceUrl:</span></div><div class="line"><span class="attr">      defaultZone:</span> <span class="attr">http://peer1:8080/eureka/,http://peer2:8081/eureka/</span></div></pre></td></tr></table></figure><p></p><p>端口为9000，服务名称为<code>Server-Consumer</code>并指定了Eureka服务端的地址。</p><p>启动该项目，访问<a href="http://localhost:9000/info" target="_blank" rel="external">http://localhost:9000/info</a>：</p><p><img src="img/QQ截图20180704112445.png" alt="QQ截图20180704112445.png"></p><p>成功获取到了信息，我们多次访问这个接口，然后观察8082和8083Eureka客户端的后台：</p><p><img src="img/QQ截图20180704112611.png" alt="QQ截图20180704112611.png"></p><p><img src="img/QQ截图20180704112650.png" alt="QQ截图20180704112650.png"></p><p>可以看到它们的后台都打印出了信息，说明我们从9000去获取服务是均衡的。</p><p>这时候我们关闭一个Eureka服务端，再次访问<a href="http://localhost:9000/info" target="_blank" rel="external">http://localhost:9000/info</a>，还是可以成功获取到信息，这就是Eureka服务端集群的好处。</p><h2 id="Eureka-Server添加认证"><a href="#Eureka-Server添加认证" class="headerlink" title="Eureka-Server添加认证"></a>Eureka-Server添加认证</h2><p>出于安全的考虑，我们可能会对Eureka服务端添加用户认证的功能。我们在Eureka-Server引入Spring-Security依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-security<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div></pre></td></tr></table></figure><p></p><p>然后在application.yml中配置用户名和密码：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="attr">security:</span></div><div class="line"><span class="attr">  basic:</span></div><div class="line"><span class="attr">    enabled:</span> <span class="literal">true</span></div><div class="line"><span class="attr">  user:</span></div><div class="line"><span class="attr">    name:</span> <span class="string">mrbird</span></div><div class="line"><span class="attr">    password:</span> <span class="number">123456</span></div></pre></td></tr></table></figure><p></p><p>Eureka服务端配置了密码之后，所有<code>eureka.client.serviceUrl.defaultZone</code>的配置也必须配置上用户名和密码，格式为：<code>eureka.client.serviceUrl.defaultZone=http://${userName}:${password}@${hosetname}:${port}/eureka/</code>，如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">eureka:</div><div class="line">  client:</div><div class="line">    serviceUrl:</div><div class="line">      defaultZone: http:<span class="comment">//mrbird:123456@peer2:8081/eureka/</span></div></pre></td></tr></table></figure><p></p><p>重新打包并部署后，访问<a href="http://localhost:8080/" target="_blank" rel="external">http://localhost:8080/</a>，页面将弹出验证窗口，输入用户名和密码后即可访问。</p><h2 id="Eureka配置"><a href="#Eureka配置" class="headerlink" title="Eureka配置"></a>Eureka配置</h2><p>下面我们总结一下在Eureka中常用的配置选项及代表的含义：</p><table><tr><th>配置</th><th>含义</th><th>默认值</th></tr><tr><td>eureka.client.enabled</td><td>是否启用Eureka Client</td><td>true</td></tr><tr><td>eureka.client.register-with-eureka</td><td>表示是否将自己注册到Eureka Server</td><td>true</td></tr><tr><td>eureka.client.fetch-registry</td><td>表示是否从Eureka Server获取注册的服务信息</td><td>true</td></tr><tr><td>eureka.client.serviceUrl.defaultZone</td><td>配置Eureka Server地址，用于注册服务和获取服务</td><td><a href="http://localhost:8761/eureka" target="_blank" rel="external">http://localhost:8761/eureka</a></td></tr><tr><td>eureka.client.registry-fetch-interval-seconds</td><td>默认值为30秒，即每30秒去Eureka Server上获取服务并缓存</td><td>30</td></tr><tr><td>eureka.instance.lease-renewal-interval-in-seconds</td><td>向Eureka Server发送心跳的间隔时间，单位为秒，用于服务续约</td><td>30</td></tr><tr><td>eureka.instance.lease-expiration-duration-in-seconds</td><td>定义服务失效时间，即Eureka Server检测到Eureka Client木有心跳后（客户端意外下线）多少秒将其剔除</td><td>90</td></tr><tr><td>eureka.server.enable-self-preservation</td><td>用于开启Eureka Server自我保护功能</td><td>true</td></tr><tr><td>eureka.client.instance-info-replication-interval-seconds</td><td>更新实例信息的变化到Eureka服务端的间隔时间，单位为秒</td><td>30</td></tr><tr><td>eureka.client.eureka-service-url-poll-interval-seconds</td><td>轮询Eureka服务端地址更改的间隔时间，单位为秒。</td><td>300</td></tr><tr><td>eureka.instance.prefer-ip-address</td><td>表示使用IP进行配置为不是域名</td><td>false</td></tr><tr><td>eureka.client.healthcheck.enabled</td><td>默认Erueka Server是通过心跳来检测Eureka Client的健康状况的，通过置为true改变Eeureka Server对客户端健康检测的方式，改用Actuator的/health端点来检测。</td><td>false</td></tr></table><p>Eureka还有许多别的配置，具体可以参考<code>EurekaClientConfigBean</code>，<code>EurekaServerConfigBean</code>和<code>EurekaInstanceConfigBean</code>配置类的源码。</p><p>参考链接：<a href="http://cloud.spring.io/spring-cloud-netflix/1.4.x/multi/multi__service_discovery_eureka_clients.html" target="_blank" rel="external">http://cloud.spring.io/spring-cloud-netflix/1.4.x/multi/multi__service_discovery_eureka_clients.html</a></p><p>源码链接：<a href="https://github.com/wuyouzhuguli/Spring-Boot-Demos/tree/master/28.Spring-Cloud-Eureka-Server-Discovery" target="_blank" rel="external">https://github.com/wuyouzhuguli/Spring-Boot-Demos/tree/master/28.Spring-Cloud-Eureka-Server-Discovery</a></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Tue Aug 21 2018 16:24:25 GMT+0800 (中国标准时间) --&gt;&lt;p&gt;考虑当前有两个微服务实例A和B，A服务需要调用B服务的某个REST接口。假如某一天B服务迁移到了另外一台服务器，IP和端口也发生了变化，这时候我们不得不去修改A服务中调用B服务REST接口的静态配置。随着公司业务的发展，微服务的数量也越来越多，服务间的关系可能变得非常复杂，传统的微服务维护变得愈加困难，也很容易出错。所谓服务治理就是用来实现各个微服务实例的自动化注册与发现，在这种模式下，服务间的调用不再通过指定具体的实例地址来实现，而是通过向服务注册中心获取服务名并发起请求调用实现。
    
    </summary>
    
    
      <category term="Spring" scheme="http://mrbird.cc/tags/Spring/"/>
    
      <category term="Spring Cloud" scheme="http://mrbird.cc/tags/Spring-Cloud/"/>
    
      <category term="Eureka" scheme="http://mrbird.cc/tags/Eureka/"/>
    
  </entry>
  
  <entry>
    <title>Spring Boot中开启Spring Security</title>
    <link href="http://mrbird.cc/Spring-Boot&amp;Spring-Security.html"/>
    <id>http://mrbird.cc/Spring-Boot&amp;Spring-Security.html</id>
    <published>2018-04-30T12:41:00.000Z</published>
    <updated>2018-08-21T08:07:59.105Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Tue Aug 21 2018 16:24:25 GMT+0800 (中国标准时间) --><p>Spring Security是一款基于Spring的安全框架，主要包含认证和授权两大安全模块，和另外一款流行的安全框架Apache Shiro相比，它拥有更为强大的功能。Spring Security也可以轻松的自定义扩展以满足各种需求，并且对常见的Web安全攻击提供了防护支持。如果你的Web框架选择的是Spring，那么在安全方面Spring Security会是一个不错的选择。</p><p>这里我们使用Spring Boot来集成Spring Security，Spring Boot版本为<code>1.5.14.RELEASE</code>，Spring Security版本为<code>4.2.7RELEASE</code>。<a id="more"></a></p><h2 id="开启Spring-Security"><a href="#开启Spring-Security" class="headerlink" title="开启Spring Security"></a>开启Spring Security</h2><p>创建一个Spring Boot项目，然后引入spring-boot-starter-security：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-security<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div></pre></td></tr></table></figure><p></p><p>接下来我们创建一个TestController，对外提供一个<code>/hello</code>服务：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@RestController</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestController</span> </span>&#123;</div><div class="line">    <span class="meta">@GetMapping</span>(<span class="string">"hello"</span>)</div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="string">"hello spring security"</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p></p><p>这时候我们直接启动项目，访问<a href="http://localhost:8080/hello" target="_blank" rel="external">http://localhost:8080/hello</a>，可看到页面弹出了个HTTP Basic认证框：</p><p><img src="img/QQ截图20180707095933.png" alt="QQ截图20180707095933.png"></p><p>当Spring项目中引入了Spring Security依赖的时候，项目会默认开启如下配置：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="attr">security:</span></div><div class="line"><span class="attr">  basic:</span></div><div class="line"><span class="attr">    enabled:</span> <span class="literal">true</span></div></pre></td></tr></table></figure><p></p><p>这个配置开启了一个HTTP basic类型的认证，所有服务的访问都必须先过这个认证，默认的用户名为user，密码由Sping Security自动生成，回到IDE的控制台，可以找到密码信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Using default security password: e9ed391c-93de-4611-ac87-d871d9e749ac</div></pre></td></tr></table></figure><p></p><p>输入用户名user，密码e9ed391c-93de-4611-ac87-d871d9e749ac后，我们便可以成功访问<code>/hello</code>接口。</p><h2 id="基于表单认证"><a href="#基于表单认证" class="headerlink" title="基于表单认证"></a>基于表单认证</h2><p>我们可以通过一些配置将HTTP Basic认证修改为基于表单的认证方式。</p><p>创建一个配置类<code>BrowserSecurityConfig</code>继承<code>org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter</code>这个抽象类并重写<code>configure(HttpSecurity http)</code>方法。<code>WebSecurityConfigurerAdapter</code>是由Spring Security提供的Web应用安全配置的适配器：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Configuration</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BrowserSecurityConfig</span> <span class="keyword">extends</span> <span class="title">WebSecurityConfigurerAdapter</span> </span>&#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">        http.formLogin() <span class="comment">// 表单方式</span></div><div class="line">                .and()</div><div class="line">                .authorizeRequests() <span class="comment">// 授权配置</span></div><div class="line">                .anyRequest()  <span class="comment">// 所有请求</span></div><div class="line">                .authenticated(); <span class="comment">// 都需要认证</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p></p><p>Spring Security提供了这种链式的方法调用。上面配置指定了认证方式为表单登录，并且所有请求都需要进行认证。这时候我们重启项目，再次访问<a href="http://localhost:8080/hello" target="_blank" rel="external">http://localhost:8080/hello</a>，可以看到认证方式已经是form表单的方式了：</p><p><img src="img/QQ截图20180707102535.png" alt="QQ截图20180707102535.png"></p><p>用户名依旧是user，密码由Spring Security自动生成。当输入凭证错误时，页面上将显示错误信息：</p><p><img src="img/QQ截图20180707103009.png" alt="QQ截图20180707103009.png"></p><p>如果需要换回HTTP Basic的认证方式，我们只需要简单修改<code>configure</code>方法中的配置：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">    <span class="comment">// http.formLogin() // 表单方式</span></div><div class="line">    http.httpBasic() <span class="comment">// HTTP Basic方式</span></div><div class="line">            .and()</div><div class="line">            .authorizeRequests() <span class="comment">// 授权配置</span></div><div class="line">            .anyRequest()  <span class="comment">// 所有请求</span></div><div class="line">            .authenticated(); <span class="comment">// 都需要认证</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><p></p><h2 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h2><p>上面我们开启了一个最简单的Spring Security安全配置，下面我们来了解下Spring Security的基本原理。通过上面的的配置，代码的执行过程可以简化为下图表示：</p><p><img src="img/QQ截图20180707111356.png" alt="QQ截图20180707111356.png"></p><p>如上图所示，Spring Security包含了众多的过滤器，这些过滤器形成了一条链，所有请求都必须通过这些过滤器后才能成功访问到资源。其中<code>UsernamePasswordAuthenticationFilter</code>过滤器用于处理基于表单方式的登录认证，而<code>BasicAuthenticationFilter</code>用于处理基于HTTP Basic方式的登录验证，后面还可能包含一系列别的过滤器（可以通过相应配置开启）。在过滤器链的末尾是一个名为<code>FilterSecurityInterceptor</code>的拦截器，用于判断当前请求身份认证是否成功，是否有相应的权限，当身份认证失败或者权限不足的时候便会抛出相应的异常。<code>ExceptionTranslateFilter</code>捕获并处理，所以我们在<code>ExceptionTranslateFilter</code>过滤器用于处理了<code>FilterSecurityInterceptor</code>抛出的异常并进行处理，比如需要身份认证时将请求重定向到相应的认证页面，当认证失败或者权限不足时返回相应的提示信息。</p><p>下面我们通过debug来验证这个过程（登录方式改回表单的方式）。</p><p>我们在<code>/hello</code>服务上打个断点：</p><p><img src="img/QQ截图20180707132345.png" alt="QQ截图20180707132345.png"></p><p>在<code>FilterSecurityInterceptor</code>的invoke方法的<code>super.beforeInvocation</code>上打个断点：</p><p><img src="img/QQ截图20180707132824.png" alt="QQ截图20180707132824.png"></p><p>当这行代码执行通过后，便可以调用下一行的<code>doFilter</code>方法来真正调用<code>/hello</code>服务，否则将抛出相应的异常。</p><p>当<code>FilterSecurityInterceptor</code>抛出异常时，异常将由<code>ExceptionTranslateFilter</code>捕获并处理，所以我们在<code>ExceptionTranslateFilter</code>的<code>doFilter</code>方法<code>catch</code>代码块第一行打个断点：</p><p><img src="img/QQ截图20180707133347.png" alt="QQ截图20180707133347.png"></p><p>我们待会模拟的是用户未登录直接访问<code>/hello</code>，所以应该是抛出用户未认证的异常，所以接下来应该跳转到<code>UsernamePasswordAuthenticationFilter</code>处理表单方式的用户认证。在<code>UsernamePasswordAuthenticationFilter</code>的<code>attemptAuthentication</code>方法上打个断点：</p><p><img src="img/QQ截图20180707134106.png" alt="QQ截图20180707134106.png"></p><p>准备完毕后，我们启动项目，然后访问<a href="http://localhost:8080/hello" target="_blank" rel="external">http://localhost:8080/hello</a>，代码直接跳转到<code>FilterSecurityInteceptor</code>的断点上：</p><p><img src="img/QQ截图20180707134540.png" alt="QQ截图20180707134540.png"></p><p>往下执行，因为当前请求没有经过身份认证，所以将抛出异常并被<code>ExceptionTranslateFilter</code>捕获：</p><p><img src="img/QQ截图20180707134915.png" alt="QQ截图20180707134540.png"></p><p>捕获异常后重定向到登录表单登录页面，当我们在表单登录页面输入信息点login后，代码跳转到<code>UsernamePasswordAuthenticationFilter</code>过滤器的<code>attemptAuthentication</code>方法上：</p><p><img src="img/QQ截图20180707135743.png" alt="QQ截图20180707135743.png"></p><p>判断用户名和密码是否正确之后，代码又跳回<code>FilterSecurityInterceptor</code>的<code>beforeInvocation</code>方法执行上：</p><p><img src="img/QQ截图20180707140158.png" alt="QQ截图20180707140158.png"></p><p>当认证通过时，<code>FilterSecurityInterceptor</code>代码往下执行<code>doFilter</code>，然后代码最终跳转到<code>/hello</code>上：</p><p><img src="img/QQ截图20180707140532.png" alt="QQ截图20180707140532.png"></p><p>浏览器页面将显示<code>hello spring security</code>信息。</p><p>源码链接：<a href="https://github.com/wuyouzhuguli/Spring-Boot-Demos/tree/master/34.Start-Spring-Security" target="_blank" rel="external">https://github.com/wuyouzhuguli/Spring-Boot-Demos/tree/master/34.Start-Spring-Security</a></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Tue Aug 21 2018 16:24:25 GMT+0800 (中国标准时间) --&gt;&lt;p&gt;Spring Security是一款基于Spring的安全框架，主要包含认证和授权两大安全模块，和另外一款流行的安全框架Apache Shiro相比，它拥有更为强大的功能。Spring Security也可以轻松的自定义扩展以满足各种需求，并且对常见的Web安全攻击提供了防护支持。如果你的Web框架选择的是Spring，那么在安全方面Spring Security会是一个不错的选择。&lt;/p&gt;&lt;p&gt;这里我们使用Spring Boot来集成Spring Security，Spring Boot版本为&lt;code&gt;1.5.14.RELEASE&lt;/code&gt;，Spring Security版本为&lt;code&gt;4.2.7RELEASE&lt;/code&gt;。
    
    </summary>
    
    
      <category term="Spring" scheme="http://mrbird.cc/tags/Spring/"/>
    
      <category term="Security" scheme="http://mrbird.cc/tags/Security/"/>
    
      <category term="Spring Security" scheme="http://mrbird.cc/tags/Spring-Security/"/>
    
  </entry>
  
  <entry>
    <title>Spring Boot中使用过滤器和拦截器</title>
    <link href="http://mrbird.cc/Spring-Boot-Filter-Interceptor.html"/>
    <id>http://mrbird.cc/Spring-Boot-Filter-Interceptor.html</id>
    <published>2018-04-24T12:33:18.000Z</published>
    <updated>2018-08-21T07:50:04.556Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Tue Aug 21 2018 16:24:25 GMT+0800 (中国标准时间) --><p>过滤器（Filter）和拦截器（Interceptor）是Web项目中常用的两个功能，本文将简单介绍在Spring Boot中使用过滤器和拦截器来计算Controller中方法的执行时长，并且简单对比两者的区别。<a id="more"></a></p><p>现有如下Controller：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@RestController</span></div><div class="line"><span class="meta">@RequestMapping</span>(<span class="string">"user"</span>)</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/&#123;id:\\d+&#125;"</span>)</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">get</span><span class="params">(@PathVariable String id)</span> </span>&#123;</div><div class="line">        System.out.println(id);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p></p><p>下面通过配置过滤器和拦截器来实现对<code>get</code>方法执行时间计算的功能。</p><h2 id="过滤器"><a href="#过滤器" class="headerlink" title="过滤器"></a>过滤器</h2><p>定义一个<code>TimeFilter</code>类，实现<code>javax.servlet.Filter</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TimeFilter</span> <span class="keyword">implements</span> <span class="title">Filter</span></span>&#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(FilterConfig filterConfig)</span> <span class="keyword">throws</span> ServletException </span>&#123;</div><div class="line">        System.out.println(<span class="string">"过滤器初始化"</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFilter</span><span class="params">(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain)</span> <span class="keyword">throws</span> IOException, ServletException </span>&#123;</div><div class="line">        System.out.println(<span class="string">"开始执行过滤器"</span>);</div><div class="line">        Long start = <span class="keyword">new</span> Date().getTime();</div><div class="line">        filterChain.doFilter(servletRequest, servletResponse);</div><div class="line">        System.out.println(<span class="string">"【过滤器】耗时 "</span> + (<span class="keyword">new</span> Date().getTime() - start));</div><div class="line">        System.out.println(<span class="string">"结束执行过滤器"</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"过滤器销毁"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p></p><p><code>TimeFilter</code>重写了<code>Filter</code>的三个方法，方法名称已经很直白的描述了其作用，这里不再赘述。</p><p>要使该过滤器在Spring Boot中生效，还需要一些配置。这里主要有两种配置方式。</p><h3 id="配置方式一"><a href="#配置方式一" class="headerlink" title="配置方式一"></a>配置方式一</h3><p>可通过在<code>TimeFilter</code>上加上如下注解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Component</span></div><div class="line"><span class="meta">@WebFilter</span>(urlPatterns = &#123;<span class="string">"/*"</span>&#125;)</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TimeFilter</span> <span class="keyword">implements</span> <span class="title">Filter</span> </span>&#123;</div><div class="line">   ...</div><div class="line">&#125;</div></pre></td></tr></table></figure><p></p><p><code>@Component</code>注解让<code>TimeFilter</code>成为Spring上下文中的一个Bean，<code>@WebFilter</code>注解的<code>urlPatterns</code>属性配置了哪些请求可以进入该过滤器，<code>/*</code>表示所有请求。</p><p>启动项目时可以看到控制台输出了<code>过滤器初始化</code>，启动后访问<a href="http://localhost:8080/user/1" target="_blank" rel="external">http://localhost:8080/user/1</a>，控制台输出如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">开始执行过滤器</div><div class="line">1</div><div class="line">【过滤器】耗时 31</div><div class="line">结束执行过滤器</div></pre></td></tr></table></figure><p></p><h3 id="配置方式二"><a href="#配置方式二" class="headerlink" title="配置方式二"></a>配置方式二</h3><p>除了在过滤器类上加注解外，我们也可以通过<code>FilterRegistrationBean</code>来注册过滤器。</p><p>定义一个<code>WebConfig</code>类，加上<code>@Configuration</code>注解表明其为配置类，然后通过<code>FilterRegistrationBean</code>来注册过滤器:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Configuration</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebConfig</span> </span>&#123;</div><div class="line">    <span class="meta">@Bean</span></div><div class="line">    <span class="function"><span class="keyword">public</span> FilterRegistrationBean <span class="title">timeFilter</span><span class="params">()</span> </span>&#123;</div><div class="line">        FilterRegistrationBean filterRegistrationBean = <span class="keyword">new</span> FilterRegistrationBean();</div><div class="line">        TimeFilter timeFilter = <span class="keyword">new</span> TimeFilter();</div><div class="line">        filterRegistrationBean.setFilter(timeFilter);</div><div class="line"></div><div class="line">        List&lt;String&gt; urlList = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">        urlList.add(<span class="string">"/*"</span>);</div><div class="line"></div><div class="line">        filterRegistrationBean.setUrlPatterns(urlList);</div><div class="line">        <span class="keyword">return</span> filterRegistrationBean;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p></p><p><code>FilterRegistrationBean</code>除了注册过滤器<code>TimeFilter</code>外还通过<code>setUrlPatterns</code>方法配置了URL匹配规则。重启项目访问<a href="http://localhost:8080/user/1" target="_blank" rel="external">http://localhost:8080/user/1</a>，我们可以看到和上面一样的效果。</p><div class="note info"><p>通过过滤器我们只可以获取到servletRequest对象，所以并不能获取到方法的名称，所属类，参数等额外的信息。</p></div><h2 id="拦截器"><a href="#拦截器" class="headerlink" title="拦截器"></a>拦截器</h2><p>定义一个<code>TimeInterceptor</code>类，实现<code>org.springframework.web.servlet.HandlerInterceptor</code>接口:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TimeInterceptor</span> <span class="keyword">implements</span> <span class="title">HandlerInterceptor</span> </span>&#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">preHandle</span><span class="params">(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">        System.out.println(<span class="string">"处理拦截之前"</span>);</div><div class="line">        httpServletRequest.setAttribute(<span class="string">"startTime"</span>, <span class="keyword">new</span> Date().getTime());</div><div class="line">        System.out.println(((HandlerMethod) o).getBean().getClass().getName());</div><div class="line">        System.out.println(((HandlerMethod) o).getMethod().getName());</div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postHandle</span><span class="params">(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o, ModelAndView modelAndView)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">        System.out.println(<span class="string">"开始处理拦截"</span>);</div><div class="line">        Long start = (Long) httpServletRequest.getAttribute(<span class="string">"startTime"</span>);</div><div class="line">        System.out.println(<span class="string">"【拦截器】耗时 "</span> + (<span class="keyword">new</span> Date().getTime() - start));</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterCompletion</span><span class="params">(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o, Exception e)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">        System.out.println(<span class="string">"处理拦截之后"</span>);</div><div class="line">        Long start = (Long) httpServletRequest.getAttribute(<span class="string">"startTime"</span>);</div><div class="line">        System.out.println(<span class="string">"【拦截器】耗时 "</span> + (<span class="keyword">new</span> Date().getTime() - start));</div><div class="line">        System.out.println(<span class="string">"异常信息 "</span> + e);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p></p><p><code>TimeInterceptor</code>实现了<code>HandlerInterceptor</code>接口的三个方法。<code>preHandle</code>方法在处理拦截之前执行，<code>postHandle</code>只有当被拦截的方法没有抛出异常成功时才会处理，<code>afterCompletion</code>方法无论被拦截的方法抛出异常与否都会执行。</p><p>通过这三个方法的参数可以看到，相较于过滤器，拦截器多了Object和Exception对象，所以可以获取的信息比过滤器要多的多。但过滤器仍无法获取到方法的参数等信息，我们可以通过切面编程来实现这个目的，具体可参考<a href="https://mrbird.cc/Spring-Boot-AOP%20log.html">https://mrbird.cc/Spring-Boot-AOP%20log.html</a>。</p><p>要使拦截器在Spring Boot中生效，还需要如下两步配置：</p><p>1.在拦截器类上加入<code>@Component</code>注解；</p><p>2.在<code>WebConfig</code>中通过<code>InterceptorRegistry</code>注册过滤器:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Configuration</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebConfig</span> <span class="keyword">extends</span> <span class="title">WebMvcConfigurerAdapter</span> </span>&#123;</div><div class="line">    <span class="meta">@Autowired</span></div><div class="line">    <span class="keyword">private</span> TimeInterceptor timeInterceptor;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> </span>&#123;</div><div class="line">        registry.addInterceptor(timeInterceptor);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p></p><p>启动项目，访问<a href="http://localhost:8080/user/1" target="_blank" rel="external">http://localhost:8080/user/1</a>，控制台输出如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">处理拦截之前</div><div class="line">cc.mrbird.controller.UserController</div><div class="line">get</div><div class="line">1</div><div class="line">开始处理拦截</div><div class="line">【拦截器】耗时 24</div><div class="line">处理拦截之后</div><div class="line">【拦截器】耗时 24</div><div class="line">异常信息 null</div></pre></td></tr></table></figure><p></p><p>从输出中我们可以了解到三个方法的执行顺序，并且三个方法都被执行了。</p><p>我们在<code>UserController</code>的<code>get</code>方法中手动抛出一个异常：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"> <span class="meta">@GetMapping</span>(<span class="string">"/&#123;id:\\d+&#125;"</span>)</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">get</span><span class="params">(@PathVariable String id)</span> </span>&#123;</div><div class="line">    System.out.println(id);</div><div class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"user not exist"</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p></p><p>重启项目后，访问<a href="http://localhost:8080/user/1" target="_blank" rel="external">http://localhost:8080/user/1</a>，控制台输出如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">处理拦截之前</div><div class="line">cc.mrbird.controller.UserController</div><div class="line">get</div><div class="line">1</div><div class="line">处理拦截之后</div><div class="line">【拦截器】耗时 0</div><div class="line">异常信息 java.lang.RuntimeException: user not exist</div></pre></td></tr></table></figure><p></p><p>可看到，<code>postHandle</code>方法并没有被执行。</p><h2 id="执行时机对比"><a href="#执行时机对比" class="headerlink" title="执行时机对比"></a>执行时机对比</h2><p>我们将过滤器和拦截器都配置上，然后启动项目访问<a href="http://localhost:8080/user/1" target="_blank" rel="external">http://localhost:8080/user/1</a>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">开始执行过滤器</div><div class="line">处理拦截之前</div><div class="line">cc.mrbird.controller.UserController</div><div class="line">get</div><div class="line">1</div><div class="line">开始处理拦截</div><div class="line">【拦截器】耗时 25</div><div class="line">处理拦截之后</div><div class="line">【拦截器】耗时 25</div><div class="line">异常信息 null</div><div class="line">【过滤器】耗时 34</div><div class="line">结束执行过滤器</div></pre></td></tr></table></figure><p></p><p>可看到过滤器要先于拦截器执行，晚于拦截器结束。下图很好的描述了它们的执行时间区别：</p><p><img src="img/32361-20180530095349427-444141538.png" alt="32361-20180530095349427-444141538.png"></p><p>源码链接<a href="https://github.com/wuyouzhuguli/Spring-Boot-Demos/tree/master/26.Spring-Boot-Filter-Interceptor" target="_blank" rel="external">https://github.com/wuyouzhuguli/Spring-Boot-Demos/tree/master/26.Spring-Boot-Filter-Interceptor</a></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Tue Aug 21 2018 16:24:25 GMT+0800 (中国标准时间) --&gt;&lt;p&gt;过滤器（Filter）和拦截器（Interceptor）是Web项目中常用的两个功能，本文将简单介绍在Spring Boot中使用过滤器和拦截器来计算Controller中方法的执行时长，并且简单对比两者的区别。
    
    </summary>
    
    
      <category term="Spring" scheme="http://mrbird.cc/tags/Spring/"/>
    
      <category term="Spring Boot" scheme="http://mrbird.cc/tags/Spring-Boot/"/>
    
  </entry>
  
  <entry>
    <title>Spring Boot异常处理</title>
    <link href="http://mrbird.cc/Spring-Boot-Exception.html"/>
    <id>http://mrbird.cc/Spring-Boot-Exception.html</id>
    <published>2018-04-20T07:39:37.000Z</published>
    <updated>2018-08-21T07:47:22.998Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Tue Aug 21 2018 16:24:25 GMT+0800 (中国标准时间) --><p>Spring Boot对异常的处理有一套默认的机制：当应用中产生异常时，Spring Boot根据发送请求头中的<code>accept</code>是否包含<code>text/html</code>来分别返回不同的响应信息。当从浏览器地址栏中访问应用接口时，请求头中的<code>accept</code>便会包含<code>text/html</code>信息，产生异常时，Spring Boot通过<code>org.springframework.web.servlet.ModelAndView</code>对象来装载异常信息，并以HTML的格式返回；而当从客户端访问应用接口产生异常时（客户端访问时，请求头中的<code>accept</code>不包含<code>text/html</code>），Spring Boot则以JSON的格式返回异常信息。下面来验证一下。<a id="more"></a></p><h2 id="默认异常处理机制"><a href="#默认异常处理机制" class="headerlink" title="默认异常处理机制"></a>默认异常处理机制</h2><p>假设应用中有如下一个Controller：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@RestController</span></div><div class="line"><span class="meta">@RequestMapping</span>(<span class="string">"user"</span>)</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/&#123;id:\\d+&#125;"</span>)</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">get</span><span class="params">(@PathVariable String id)</span> </span>&#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"user not exist"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p></p><p>在代码中我们主动的抛出了一个<code>RuntimeException</code>，使用浏览器访问<a href="http://localhost:8080/user/1" target="_blank" rel="external">http://localhost:8080/user/1</a>： <img src="img/QQ截图20180701163610.png" alt="QQ截图20180701163610.png"> 可看到页面返回了一些异常描述，并且请求头的<code>accpet</code>包含了<code>text/html</code>片段。</p><p>接着使用模拟发送REST请求的Chrome插件<a href="https://restlet.com/modules/client/" target="_blank" rel="external">Restlet Client</a>发送<a href="http://localhost:8080/user/1" target="_blank" rel="external">http://localhost:8080/user/1</a>：</p><p><img src="img/QQ截图20180701165348.png" alt="QQ截图20180701165348.png"></p><p>可以看到请求头的<code>accept</code>值为<code>*/*</code>，并且返回一段JSON格式的信息。</p><p>查看Spring Boot的<code>BasicErrorController</code>类便可看到这一默认机制的具体实现：</p><p><img src="img/111111.png" alt="QQ图片20180701165727.png"></p><p>可看到<code>errorHtml</code>和<code>error</code>方法的请求地址和方法是一样的，唯一的区别就是<code>errorHtml</code>通过<code>produces = {&quot;text/html&quot;}</code>判断请求头的<code>accpet</code>属性中是否包含<code>text/html</code>，如果包含，便走该方法。</p><h2 id="自定义html异常页面"><a href="#自定义html异常页面" class="headerlink" title="自定义html异常页面"></a>自定义html异常页面</h2><p>我们可以通过在<code>src/main/resources/resources/error</code>路径下定义友好的异常页面，比如定义一个500.html页面：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>500<span class="tag">&lt;/<span class="name">title</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></div><div class="line">    系统内部异常</div><div class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></div></pre></td></tr></table></figure><p></p><p>然后再次通过浏览器访问:<a href="http://localhost:8080/user/1" target="_blank" rel="external">http://localhost:8080/user/1</a>：</p><p><img src="img/QQ截图20180701170558.png" alt="QQ截图20180701170558.png"></p><p>同样的，我们也可以定义404.html等常见的HTTP状态码对应的异常页面。</p><p>通过自定义html异常页面并不会影响客户端发送请求异常返回的结果。</p><h2 id="自定义异常处理"><a href="#自定义异常处理" class="headerlink" title="自定义异常处理"></a>自定义异常处理</h2><p>除了可以通过自定义html异常页面来改变浏览器访问接口时产生的异常信息，我们也可以自定义异常处理来改表默认的客户端访问接口产生的异常信息。</p><p>我们手动定义一个<code>UserNotExistException</code>，继承<code>RuntimeException</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserNotExistException</span> <span class="keyword">extends</span> <span class="title">RuntimeException</span></span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">1574716826948451793L</span>;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> String id;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UserNotExistException</span><span class="params">(String id)</span></span>&#123;</div><div class="line">        <span class="keyword">super</span>(<span class="string">"user not exist"</span>);</div><div class="line">        <span class="keyword">this</span>.id = id;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getId</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> id;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(String id)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.id = id;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p></p><p>然后定义一个Controller异常处理类<code>ControllerExceptionHandler</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@ControllerAdvice</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ControllerExceptionHandler</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@ExceptionHandler</span>(UserNotExistException.class)</div><div class="line">    <span class="meta">@ResponseBody</span></div><div class="line">    <span class="meta">@ResponseStatus</span>(HttpStatus.INTERNAL_SERVER_ERROR)</div><div class="line">    <span class="function"><span class="keyword">public</span> Map&lt;String, Object&gt; <span class="title">handleUserNotExistsException</span><span class="params">(UserNotExistException e)</span> </span>&#123;</div><div class="line">        Map&lt;String, Object&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</div><div class="line">        map.put(<span class="string">"id"</span>, e.getId());</div><div class="line">        map.put(<span class="string">"message"</span>, e.getMessage());</div><div class="line">        <span class="keyword">return</span> map;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p></p><p>其中注解<code>@ExceptionHandler</code>指定了要处理的异常类型，注解<code>@ResponseStatus</code>指定异常处理方法返回的HTTP状态码为<code>HttpStatus.INTERNAL_SERVER_ERROR</code>，即500。<code>HttpStatus</code>是一个spring自带的枚举类型，封装了常见的HTTP状态码及描述：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">enum</span> HttpStatus &#123;</div><div class="line">    CONTINUE(<span class="number">100</span>, <span class="string">"Continue"</span>),</div><div class="line">    SWITCHING_PROTOCOLS(<span class="number">101</span>, <span class="string">"Switching Protocols"</span>),</div><div class="line">    PROCESSING(<span class="number">102</span>, <span class="string">"Processing"</span>),</div><div class="line">    CHECKPOINT(<span class="number">103</span>, <span class="string">"Checkpoint"</span>),</div><div class="line">    OK(<span class="number">200</span>, <span class="string">"OK"</span>),</div><div class="line">    CREATED(<span class="number">201</span>, <span class="string">"Created"</span>),</div><div class="line">    ACCEPTED(<span class="number">202</span>, <span class="string">"Accepted"</span>),</div><div class="line">    NON_AUTHORITATIVE_INFORMATION(<span class="number">203</span>, <span class="string">"Non-Authoritative Information"</span>),</div><div class="line">    NO_CONTENT(<span class="number">204</span>, <span class="string">"No Content"</span>),</div><div class="line">    RESET_CONTENT(<span class="number">205</span>, <span class="string">"Reset Content"</span>),</div><div class="line">    PARTIAL_CONTENT(<span class="number">206</span>, <span class="string">"Partial Content"</span>),</div><div class="line">    MULTI_STATUS(<span class="number">207</span>, <span class="string">"Multi-Status"</span>),</div><div class="line">    ALREADY_REPORTED(<span class="number">208</span>, <span class="string">"Already Reported"</span>),</div><div class="line">    IM_USED(<span class="number">226</span>, <span class="string">"IM Used"</span>),</div><div class="line">    MULTIPLE_CHOICES(<span class="number">300</span>, <span class="string">"Multiple Choices"</span>),</div><div class="line">    MOVED_PERMANENTLY(<span class="number">301</span>, <span class="string">"Moved Permanently"</span>),</div><div class="line">    FOUND(<span class="number">302</span>, <span class="string">"Found"</span>),</div><div class="line">    <span class="comment">/** <span class="doctag">@deprecated</span> */</span></div><div class="line">    <span class="meta">@Deprecated</span></div><div class="line">    MOVED_TEMPORARILY(<span class="number">302</span>, <span class="string">"Moved Temporarily"</span>),</div><div class="line">    SEE_OTHER(<span class="number">303</span>, <span class="string">"See Other"</span>),</div><div class="line">    NOT_MODIFIED(<span class="number">304</span>, <span class="string">"Not Modified"</span>),</div><div class="line">    <span class="comment">/** <span class="doctag">@deprecated</span> */</span></div><div class="line">    <span class="meta">@Deprecated</span></div><div class="line">    USE_PROXY(<span class="number">305</span>, <span class="string">"Use Proxy"</span>),</div><div class="line">    TEMPORARY_REDIRECT(<span class="number">307</span>, <span class="string">"Temporary Redirect"</span>),</div><div class="line">    PERMANENT_REDIRECT(<span class="number">308</span>, <span class="string">"Permanent Redirect"</span>),</div><div class="line">    BAD_REQUEST(<span class="number">400</span>, <span class="string">"Bad Request"</span>),</div><div class="line">    UNAUTHORIZED(<span class="number">401</span>, <span class="string">"Unauthorized"</span>),</div><div class="line">    PAYMENT_REQUIRED(<span class="number">402</span>, <span class="string">"Payment Required"</span>),</div><div class="line">    FORBIDDEN(<span class="number">403</span>, <span class="string">"Forbidden"</span>),</div><div class="line">    NOT_FOUND(<span class="number">404</span>, <span class="string">"Not Found"</span>),</div><div class="line">    METHOD_NOT_ALLOWED(<span class="number">405</span>, <span class="string">"Method Not Allowed"</span>),</div><div class="line">    NOT_ACCEPTABLE(<span class="number">406</span>, <span class="string">"Not Acceptable"</span>),</div><div class="line">    PROXY_AUTHENTICATION_REQUIRED(<span class="number">407</span>, <span class="string">"Proxy Authentication Required"</span>),</div><div class="line">    REQUEST_TIMEOUT(<span class="number">408</span>, <span class="string">"Request Timeout"</span>),</div><div class="line">    CONFLICT(<span class="number">409</span>, <span class="string">"Conflict"</span>),</div><div class="line">    GONE(<span class="number">410</span>, <span class="string">"Gone"</span>),</div><div class="line">    LENGTH_REQUIRED(<span class="number">411</span>, <span class="string">"Length Required"</span>),</div><div class="line">    PRECONDITION_FAILED(<span class="number">412</span>, <span class="string">"Precondition Failed"</span>),</div><div class="line">    PAYLOAD_TOO_LARGE(<span class="number">413</span>, <span class="string">"Payload Too Large"</span>),</div><div class="line">    <span class="comment">/** <span class="doctag">@deprecated</span> */</span></div><div class="line">    <span class="meta">@Deprecated</span></div><div class="line">    REQUEST_ENTITY_TOO_LARGE(<span class="number">413</span>, <span class="string">"Request Entity Too Large"</span>),</div><div class="line">    URI_TOO_LONG(<span class="number">414</span>, <span class="string">"URI Too Long"</span>),</div><div class="line">    <span class="comment">/** <span class="doctag">@deprecated</span> */</span></div><div class="line">    <span class="meta">@Deprecated</span></div><div class="line">    REQUEST_URI_TOO_LONG(<span class="number">414</span>, <span class="string">"Request-URI Too Long"</span>),</div><div class="line">    UNSUPPORTED_MEDIA_TYPE(<span class="number">415</span>, <span class="string">"Unsupported Media Type"</span>),</div><div class="line">    REQUESTED_RANGE_NOT_SATISFIABLE(<span class="number">416</span>, <span class="string">"Requested range not satisfiable"</span>),</div><div class="line">    EXPECTATION_FAILED(<span class="number">417</span>, <span class="string">"Expectation Failed"</span>),</div><div class="line">    I_AM_A_TEAPOT(<span class="number">418</span>, <span class="string">"I'm a teapot"</span>),</div><div class="line">    <span class="comment">/** <span class="doctag">@deprecated</span> */</span></div><div class="line">    <span class="meta">@Deprecated</span></div><div class="line">    INSUFFICIENT_SPACE_ON_RESOURCE(<span class="number">419</span>, <span class="string">"Insufficient Space On Resource"</span>),</div><div class="line">    <span class="comment">/** <span class="doctag">@deprecated</span> */</span></div><div class="line">    <span class="meta">@Deprecated</span></div><div class="line">    METHOD_FAILURE(<span class="number">420</span>, <span class="string">"Method Failure"</span>),</div><div class="line">    <span class="comment">/** <span class="doctag">@deprecated</span> */</span></div><div class="line">    <span class="meta">@Deprecated</span></div><div class="line">    DESTINATION_LOCKED(<span class="number">421</span>, <span class="string">"Destination Locked"</span>),</div><div class="line">    UNPROCESSABLE_ENTITY(<span class="number">422</span>, <span class="string">"Unprocessable Entity"</span>),</div><div class="line">    LOCKED(<span class="number">423</span>, <span class="string">"Locked"</span>),</div><div class="line">    FAILED_DEPENDENCY(<span class="number">424</span>, <span class="string">"Failed Dependency"</span>),</div><div class="line">    UPGRADE_REQUIRED(<span class="number">426</span>, <span class="string">"Upgrade Required"</span>),</div><div class="line">    PRECONDITION_REQUIRED(<span class="number">428</span>, <span class="string">"Precondition Required"</span>),</div><div class="line">    TOO_MANY_REQUESTS(<span class="number">429</span>, <span class="string">"Too Many Requests"</span>),</div><div class="line">    REQUEST_HEADER_FIELDS_TOO_LARGE(<span class="number">431</span>, <span class="string">"Request Header Fields Too Large"</span>),</div><div class="line">    UNAVAILABLE_FOR_LEGAL_REASONS(<span class="number">451</span>, <span class="string">"Unavailable For Legal Reasons"</span>),</div><div class="line">    INTERNAL_SERVER_ERROR(<span class="number">500</span>, <span class="string">"Internal Server Error"</span>),</div><div class="line">    NOT_IMPLEMENTED(<span class="number">501</span>, <span class="string">"Not Implemented"</span>),</div><div class="line">    BAD_GATEWAY(<span class="number">502</span>, <span class="string">"Bad Gateway"</span>),</div><div class="line">    SERVICE_UNAVAILABLE(<span class="number">503</span>, <span class="string">"Service Unavailable"</span>),</div><div class="line">    GATEWAY_TIMEOUT(<span class="number">504</span>, <span class="string">"Gateway Timeout"</span>),</div><div class="line">    HTTP_VERSION_NOT_SUPPORTED(<span class="number">505</span>, <span class="string">"HTTP Version not supported"</span>),</div><div class="line">    VARIANT_ALSO_NEGOTIATES(<span class="number">506</span>, <span class="string">"Variant Also Negotiates"</span>),</div><div class="line">    INSUFFICIENT_STORAGE(<span class="number">507</span>, <span class="string">"Insufficient Storage"</span>),</div><div class="line">    LOOP_DETECTED(<span class="number">508</span>, <span class="string">"Loop Detected"</span>),</div><div class="line">    BANDWIDTH_LIMIT_EXCEEDED(<span class="number">509</span>, <span class="string">"Bandwidth Limit Exceeded"</span>),</div><div class="line">    NOT_EXTENDED(<span class="number">510</span>, <span class="string">"Not Extended"</span>),</div><div class="line">    NETWORK_AUTHENTICATION_REQUIRED(<span class="number">511</span>, <span class="string">"Network Authentication Required"</span>);</div><div class="line">    ...</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure><p></p><p>编写完自定义异常处理逻辑后，我们将UserController中的方法抛出的异常改为<code>UserNotExistException</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"> <span class="meta">@GetMapping</span>(<span class="string">"/&#123;id:\\d+&#125;"</span>)</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">get</span><span class="params">(@PathVariable String id)</span> </span>&#123;</div><div class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> UserNotExistException(id);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p></p><p>重启项目，使用Restlet Client再次访问<a href="http://localhost:8080/user/1" target="_blank" rel="external">http://localhost:8080/user/1</a>，响应如下： <img src="img/QQ图片20180701172030.png" alt="QQ图片20180701172030.png"></p><blockquote><p>源码链接 <a href="https://github.com/wuyouzhuguli/Spring-Boot-Demos/tree/master/25.Spring-Boot-Exception" target="_blank" rel="external">https://github.com/wuyouzhuguli/Spring-Boot-Demos/tree/master/25.Spring-Boot-Exception</a></p></blockquote><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Tue Aug 21 2018 16:24:25 GMT+0800 (中国标准时间) --&gt;&lt;p&gt;Spring Boot对异常的处理有一套默认的机制：当应用中产生异常时，Spring Boot根据发送请求头中的&lt;code&gt;accept&lt;/code&gt;是否包含&lt;code&gt;text/html&lt;/code&gt;来分别返回不同的响应信息。当从浏览器地址栏中访问应用接口时，请求头中的&lt;code&gt;accept&lt;/code&gt;便会包含&lt;code&gt;text/html&lt;/code&gt;信息，产生异常时，Spring Boot通过&lt;code&gt;org.springframework.web.servlet.ModelAndView&lt;/code&gt;对象来装载异常信息，并以HTML的格式返回；而当从客户端访问应用接口产生异常时（客户端访问时，请求头中的&lt;code&gt;accept&lt;/code&gt;不包含&lt;code&gt;text/html&lt;/code&gt;），Spring Boot则以JSON的格式返回异常信息。下面来验证一下。
    
    </summary>
    
    
      <category term="Spring" scheme="http://mrbird.cc/tags/Spring/"/>
    
      <category term="Spring Boot" scheme="http://mrbird.cc/tags/Spring-Boot/"/>
    
  </entry>
  
  <entry>
    <title>【Java8实战】新的日期和时间API</title>
    <link href="http://mrbird.cc/java8-new-time-date-api.html"/>
    <id>http://mrbird.cc/java8-new-time-date-api.html</id>
    <published>2018-04-20T02:18:28.000Z</published>
    <updated>2018-07-02T07:26:23.284Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Tue Aug 21 2018 16:24:26 GMT+0800 (中国标准时间) --><p>Java 8之前的库对日期和时间的支持并不理想，为了解决这个问题，Java 8引入了一套全新的时间日期API，位于<code>java.time</code>路径下。</p><h2 id="LocalDate"><a href="#LocalDate" class="headerlink" title="LocalDate"></a>LocalDate</h2><p><code>LocalDate</code>类型包含了年月日信息，下面举些<code>LocalDate</code>的使用示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">LocalDate date = LocalDate.of(<span class="number">2018</span>, <span class="number">4</span>, <span class="number">20</span>); <span class="comment">// 2018-04-20</span></div><div class="line"><span class="keyword">int</span> year = date.getYear(); <span class="comment">// 2018</span></div><div class="line"><span class="keyword">int</span> month = date.getMonth().getValue(); <span class="comment">// 4</span></div><div class="line"><span class="keyword">int</span> day = date.getDayOfMonth(); <span class="comment">// 20</span></div><div class="line"><span class="comment">// 查看该月有多少天</span></div><div class="line"><span class="keyword">int</span> days = date.lengthOfMonth(); <span class="comment">// 30</span></div><div class="line"><span class="comment">// 是否是闰年</span></div><div class="line"><span class="keyword">boolean</span> isLeap = date.isLeapYear(); <span class="comment">// false</span></div></pre></td></tr></table></figure><p></p><a id="more"></a><p>可以使用<code>LocalDate.now()</code>获取当天的日期信息：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 查看当天 年月日</span></div><div class="line">LocalDate today = LocalDate.now(); <span class="comment">// 2018-04-20</span></div></pre></td></tr></table></figure><p></p><p>除了调用<code>LocalDate</code>的<code>getYear</code>方法外，我们也可以使用<code>ChronoField</code>枚举类型来实现相同的功能：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> year1 = date.get(ChronoField.YEAR); <span class="comment">// 2018</span></div><div class="line"><span class="keyword">int</span> month1 = date.get(ChronoField.MONTH_OF_YEAR); <span class="comment">// 4</span></div><div class="line"><span class="keyword">int</span> day1 = date.get(ChronoField.DAY_OF_MONTH); <span class="comment">// 20</span></div><div class="line"><span class="comment">// 当前日期属于该月第几周</span></div><div class="line"><span class="keyword">int</span> weekOfMonth = date.get(ChronoField.ALIGNED_WEEK_OF_MONTH); <span class="comment">// 3</span></div></pre></td></tr></table></figure><p></p><p><code>ChronoField</code>枚举类型包含了诸多的属性可供选择： <img src="img/QQ截图20180702142403.png" alt="QQ截图20180702142403.png"></p><p>我们也可以修改<code>LocalDate</code>对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">LocalDate date3 = LocalDate.of(<span class="number">2018</span>, <span class="number">4</span>, <span class="number">20</span>); <span class="comment">// 2018-04-20</span></div><div class="line">LocalDate date4 = date3.withDayOfMonth(<span class="number">22</span>); <span class="comment">// 2018-04-22</span></div><div class="line">LocalDate date5 = date3.with(ChronoField.DAY_OF_MONTH, <span class="number">22</span>); <span class="comment">// 2018-04-22</span></div><div class="line">LocalDate date6 = date3.withYear(<span class="number">2019</span>); <span class="comment">// 2019-04-20</span></div><div class="line">LocalDate date7 = date3.plusDays(<span class="number">5</span>); <span class="comment">// 2018-04-25</span></div><div class="line">LocalDate date8 = date3.plus(<span class="number">5</span>, ChronoUnit.DAYS); <span class="comment">// 2018-04-25</span></div><div class="line">LocalDate date9 = date3.minusYears(<span class="number">10</span>); <span class="comment">// 2008-04-20</span></div></pre></td></tr></table></figure><p></p><p><code>TemporalAdjusters</code>类提供了许多静态方法来修改<code>LocalDate</code>对象。当我们需要获取下一个周天，下一个工作日，本月的最后一天等信息时，<code>TemporalAdjusters</code>类便可派上用场：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.time.temporal.TemporalAdjusters.*;</div><div class="line"></div><div class="line">LocalDate date10 = date3.with(nextOrSame(DayOfWeek.MONDAY)); <span class="comment">// 2018-04-23</span></div><div class="line">LocalDate date11 = date3.with(lastDayOfMonth()); <span class="comment">// 2018-04-30</span></div><div class="line">LocalDate date12 = date3.with(previous(DayOfWeek.SATURDAY)); <span class="comment">// 2018-04-14</span></div></pre></td></tr></table></figure><p></p><p>可参考4月的日历来理解上面的结果： <img src="img/QQ截图20180702144931.png" alt="QQ截图20180702144931.png"></p><p>我们还可以对<code>LocalDate</code>进行格式化操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">String str1 = date.format(DateTimeFormatter.BASIC_ISO_DATE); <span class="comment">// 20180420</span></div><div class="line">String str2 = date.format(DateTimeFormatter.ISO_LOCAL_DATE); <span class="comment">// 2018-04-20</span></div><div class="line"></div><div class="line">DateTimeFormatter dtf = DateTimeFormatter.ofPattern(<span class="string">"yyyy-MM-dd"</span>);</div><div class="line">String str5 = date.format(dtf); <span class="comment">// 2018-04-20</span></div><div class="line">LocalDate date13 = LocalDate.parse(str5, dtf); <span class="comment">// 2018-04-20</span></div></pre></td></tr></table></figure><p></p><div class="note info"><p>LocalDate和下面要介绍的LocalTime，LocalDateTime之间共享了许多类似的方法，上面介绍的LocalDate修改、格式化等方法通用适用于LocalTime和LocalDateTime。</p></div><h2 id="LocalTime"><a href="#LocalTime" class="headerlink" title="LocalTime"></a>LocalTime</h2><p><code>LocalTime</code>和<code>LocalDate</code>类似，区别在于<code>LocalTime</code>包含的是时分秒（毫秒）信息。举些<code>LocalTime</code>的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">LocalTime time = LocalTime.of(<span class="number">20</span>, <span class="number">13</span>, <span class="number">54</span>); <span class="comment">// 20:13:54</span></div><div class="line"><span class="keyword">int</span> hour = time.getHour(); <span class="comment">// 20</span></div><div class="line"><span class="keyword">int</span> minute = time.getMinute(); <span class="comment">// 13</span></div><div class="line"><span class="keyword">int</span> second = time.getSecond(); <span class="comment">// 54</span></div></pre></td></tr></table></figure><p></p><p><code>LocalDate</code>和<code>LocalTime</code>都可以通过字符串来创建：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">LocalDate date = LocalDate.parse(<span class="string">"2018-04-20"</span>);</div><div class="line">LocalTime time = LocalTime.parse(<span class="string">"20:13:54"</span>);</div></pre></td></tr></table></figure><p></p><h2 id="LocalDateTime"><a href="#LocalDateTime" class="headerlink" title="LocalDateTime"></a>LocalDateTime</h2><p><code>LocalDateTime</code>是<code>LocalDate</code>和<code>LocalTime</code>的组合形式，包含了年月日时分秒信息。举些<code>LocalDateTime</code>的使用示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">LocalDateTime ldt1 = LocalDateTime.of(<span class="number">2018</span>, <span class="number">4</span>, <span class="number">20</span>, <span class="number">20</span>, <span class="number">13</span>, <span class="number">54</span>); <span class="comment">// 2018-04-20T20:13:54</span></div><div class="line">LocalDateTime ldt2 = LocalDateTime.of(date, time); <span class="comment">// 2018-04-20T20:13:54</span></div></pre></td></tr></table></figure><p></p><p><code>LocalDateTime</code>可以转换为<code>LocalDate</code>和<code>LocalTime</code>，转换后包含的信息减少了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">LocalDate date1 = ldt1.toLocalDate(); <span class="comment">// 2018-04-20</span></div><div class="line">LocalTime time1 = ldt1.toLocalTime(); <span class="comment">// 20:13:54</span></div></pre></td></tr></table></figure><p></p><p>同样的，<code>LocalDate</code>和<code>LocalTime</code>也可以转换为<code>LocalDateTime</code>，只需要补上日期或者时间：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">LocalDateTime ldt3 = date.atTime(time); <span class="comment">// 2018-04-20T20:13:54</span></div><div class="line">LocalDateTime ldt4 = date.atTime(<span class="number">20</span>, <span class="number">13</span>, <span class="number">54</span>); <span class="comment">// 2018-04-20T20:13:54</span></div><div class="line">LocalDateTime ldt5 = time.atDate(date); <span class="comment">// 2018-04-20T20:13:54</span></div></pre></td></tr></table></figure><p></p><h2 id="Duration"><a href="#Duration" class="headerlink" title="Duration"></a>Duration</h2><p><code>Duration</code>用于计算两个<code>LocalTime</code>或者<code>LocalDateTime</code>的时间差，例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">LocalTime time2 = LocalTime.of(<span class="number">23</span>, <span class="number">59</span>, <span class="number">59</span>);</div><div class="line">Duration duration = Duration.between(time1, time2);</div><div class="line"><span class="keyword">long</span> seconds = duration.getSeconds(); <span class="comment">// 13565</span></div></pre></td></tr></table></figure><p></p><p>time1和time2之间相差了13565秒。</p><p>手动创建<code>Duration</code>对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Duration threeMinutes = Duration.ofMinutes(<span class="number">3</span>);</div><div class="line">threeMinutes = Duration.of(<span class="number">3</span>, ChronoUnit.MINUTES); <span class="comment">// 创建了一个3分钟的Duration，两种创建方式等价</span></div></pre></td></tr></table></figure><p></p><h2 id="Period"><a href="#Period" class="headerlink" title="Period"></a>Period</h2><p><code>Period</code>用于计算两个<code>LocalDate</code>之间的时长。举些例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">LocalDate date2 = LocalDate.of(<span class="number">2018</span>, <span class="number">5</span>, <span class="number">21</span>);</div><div class="line">Period period = Period.between(date1, date2);</div><div class="line"><span class="keyword">int</span> monthsBetween = period.getMonths(); <span class="comment">// 1</span></div><div class="line"><span class="keyword">int</span> daysBetween = period.getDays(); <span class="comment">// 1</span></div></pre></td></tr></table></figure><p></p><p>2018-04-21和2018-04-20之间月份相差1，天数相差1。</p><p>同样的，我们也可以手动创建<code>Period</code>对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Period tenDays = Period.ofDays(<span class="number">10</span>);</div><div class="line">Period threeWeeks = Period.ofWeeks(<span class="number">3</span>);</div><div class="line">Period twoYearsSixMonthsOneDay = Period.of(<span class="number">2</span>, <span class="number">6</span>, <span class="number">1</span>);</div></pre></td></tr></table></figure><p></p><h2 id="其他一些常用的方法"><a href="#其他一些常用的方法" class="headerlink" title="其他一些常用的方法"></a>其他一些常用的方法</h2><h3 id="比较两个时间的先后"><a href="#比较两个时间的先后" class="headerlink" title="比较两个时间的先后"></a>比较两个时间的先后</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">LocalDate date15 = LocalDate.of(<span class="number">2018</span>,<span class="number">4</span>,<span class="number">21</span>);</div><div class="line">date.isEqual(date15); <span class="comment">// false</span></div><div class="line">date.isAfter(date15); <span class="comment">// false</span></div><div class="line">date.isBefore(date15); <span class="comment">// true</span></div></pre></td></tr></table></figure><h3 id="MonthDay类的使用"><a href="#MonthDay类的使用" class="headerlink" title="MonthDay类的使用"></a>MonthDay类的使用</h3><p><code>MonthDay</code>只包含月日信息，可以用于存放类似于生日，结婚纪念日等信息。举个使用<code>MonthDay</code>的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">LocalDate birthday = LocalDate.of(<span class="number">1999</span>, <span class="number">9</span>, <span class="number">9</span>);</div><div class="line">MonthDay monthDay = MonthDay.of(birthday.getMonth(), birthday.getDayOfMonth());</div><div class="line">MonthDay currentMonthDay = MonthDay.from(LocalDate.now());</div><div class="line"><span class="keyword">if</span> (currentMonthDay.equals(monthDay)) &#123;</div><div class="line">    System.out.println(<span class="string">"happy birthday!"</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p></p><p>假如用户的生日是1999年9月9号，那么可以通过这种方法来判断今天是否是用户的生日，如果是的话便发送生日祝福。同样的也有<code>YearMonth</code>类。</p><div class="note danger"><p>Java 8 新的日期时间API还提供了不同时区和历法的获取方法，由于较少使用而且不易于理解，这里不再列出。😕</p></div><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Tue Aug 21 2018 16:24:26 GMT+0800 (中国标准时间) --&gt;&lt;p&gt;Java 8之前的库对日期和时间的支持并不理想，为了解决这个问题，Java 8引入了一套全新的时间日期API，位于&lt;code&gt;java.time&lt;/code&gt;路径下。&lt;/p&gt;&lt;h2 id=&quot;LocalDate&quot;&gt;&lt;a href=&quot;#LocalDate&quot; class=&quot;headerlink&quot; title=&quot;LocalDate&quot;&gt;&lt;/a&gt;LocalDate&lt;/h2&gt;&lt;p&gt;&lt;code&gt;LocalDate&lt;/code&gt;类型包含了年月日信息，下面举些&lt;code&gt;LocalDate&lt;/code&gt;的使用示例：&lt;/p&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;LocalDate date = LocalDate.of(&lt;span class=&quot;number&quot;&gt;2018&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;20&lt;/span&gt;); &lt;span class=&quot;comment&quot;&gt;// 2018-04-20&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; year = date.getYear(); &lt;span class=&quot;comment&quot;&gt;// 2018&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; month = date.getMonth().getValue(); &lt;span class=&quot;comment&quot;&gt;// 4&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; day = date.getDayOfMonth(); &lt;span class=&quot;comment&quot;&gt;// 20&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 查看该月有多少天&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; days = date.lengthOfMonth(); &lt;span class=&quot;comment&quot;&gt;// 30&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 是否是闰年&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;boolean&lt;/span&gt; isLeap = date.isLeapYear(); &lt;span class=&quot;comment&quot;&gt;// false&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java" scheme="http://mrbird.cc/tags/Java/"/>
    
      <category term="Java 8" scheme="http://mrbird.cc/tags/Java-8/"/>
    
  </entry>
  
  <entry>
    <title>【Java8实战】使用Optional取代null</title>
    <link href="http://mrbird.cc/java8-optional-null.html"/>
    <id>http://mrbird.cc/java8-optional-null.html</id>
    <published>2018-04-19T00:34:31.000Z</published>
    <updated>2018-07-02T01:58:24.543Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Tue Aug 21 2018 16:24:26 GMT+0800 (中国标准时间) --><p>在Java中对一个空对象进行操作时，便会抛出最常见的异常<code>NullPointerException</code>。为了改善这个问题，Java 8中提供了一个<code>java.util.Optional&lt;T&gt;</code>类型。Optional类的Javadoc描述如下：这是一个可以为null的容器对象。如果值存在则<code>isPresent()</code>方法会返回true，调用<code>get()</code>方法会返回该对象。下面介绍Optional类的使用方法。<a id="more"></a> 假如有一个像下面这样的类层次结构：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Department</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> Employee employee;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Department</span><span class="params">(Employee employee)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.employee = employee;</div><div class="line">    &#125;</div><div class="line">    <span class="function">Employee <span class="title">getEmployee</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> employee;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> Girl girlFriend;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Employee</span><span class="params">(Girl girlFriend)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.girlFriend = girlFriend;</div><div class="line">    &#125;</div><div class="line">    <span class="function">Girl <span class="title">getGirlFriend</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> girlFriend;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Girl</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> String name;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Girl</span><span class="params">(String name)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.name = name;</div><div class="line">    &#125;</div><div class="line">    <span class="function">String <span class="title">getName</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> name;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p></p><p>部门<code>Department</code>类包含一个员工<code>employee</code>属性，类型为<code>Employee</code>，员工<code>Employee</code>类包含<code>girlFriend</code>属性，类型为<code>Girl</code>。假如现在要获取部门某个员工的女朋友，我们通常是这样获取的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> String <span class="title">getGirlFriendName</span><span class="params">(Department department)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (department != <span class="keyword">null</span>) &#123;</div><div class="line">        Employee employee = department.getEmployee();</div><div class="line">        <span class="keyword">if</span> (employee != <span class="keyword">null</span>) &#123;</div><div class="line">            Girl girl = employee.getGirlFriend();</div><div class="line">            <span class="keyword">if</span> (girl != <span class="keyword">null</span>) &#123;</div><div class="line">                <span class="keyword">return</span> girl.getName();</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">return</span> <span class="string">"单身汪"</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="string">"没有员工"</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="string">"部门为空"</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p></p><p>可以看到，在每次引用变量的属性时，都要先判断变量是否为空，如果不做该检查将可能导致<code>NullPointerException</code>。下面我们将使用Optional来改善这种层层嵌套，啰嗦的代码。</p><h2 id="创建Optional"><a href="#创建Optional" class="headerlink" title="创建Optional"></a>创建Optional</h2><p>创建一个Optional对象有好几种方式：</p><h3 id="创建一个空的Optional"><a href="#创建一个空的Optional" class="headerlink" title="创建一个空的Optional"></a>创建一个空的Optional</h3><p>我们可以使用静态工厂方法<code>Optional.empty</code>，创建一个空的Optional对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Optional&lt;Department&gt; department = Optional.empty();</div></pre></td></tr></table></figure><p></p><h3 id="根据非空值创建Optional"><a href="#根据非空值创建Optional" class="headerlink" title="根据非空值创建Optional"></a>根据非空值创建Optional</h3><p>我们也可以使用静态工厂方法<code>Optional.of</code>来创建一个非空对象的Optional对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Optional&lt;Employee&gt; optEmployee = Optional.of(employee);</div></pre></td></tr></table></figure><p></p><p>如果employee为空，这段代码会立即抛出一个<code>NullPointerException</code>。</p><h3 id="创建可以为null的Optional"><a href="#创建可以为null的Optional" class="headerlink" title="创建可以为null的Optional"></a>创建可以为null的Optional</h3><p>使用静态工厂方法<code>Optional.ofNullable</code>，我们可以创建一个允许null值的Optional对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Optional&lt;Employee&gt; optEmployee = Optional.ofNullable(employee);</div></pre></td></tr></table></figure><p></p><p>如果employee为空，对其调用<code>get</code>方法将抛出<code>NoSuchElementException</code>。</p><h2 id="Optional方法"><a href="#Optional方法" class="headerlink" title="Optional方法"></a>Optional方法</h2><p>Optional类包含了许多方法，下面介绍这些方法的使用。</p><h3 id="isPresent"><a href="#isPresent" class="headerlink" title="isPresent"></a>isPresent</h3><p>顾名思义，如果值存在返回true，否则返回false。如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"> Optional&lt;Department&gt; opt = Optional.ofNullable(department);</div><div class="line"><span class="keyword">if</span>(opt.isPresent())&#123;</div><div class="line">    System.out.println(opt.get().getEmployee());</div><div class="line">&#125;</div></pre></td></tr></table></figure><p></p><h3 id="get"><a href="#get" class="headerlink" title="get"></a>get</h3><p>如果Optional有值则将其返回，否则抛出<code>NoSuchElementException</code>。下面举个抛出<code>NoSuchElementException</code>的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">try</span> &#123;</div><div class="line">    Optional.empty().get();</div><div class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">    e.printStackTrace();</div><div class="line">&#125;</div></pre></td></tr></table></figure><p></p><p>代码将捕获到 <span style="color:red">java.util.NoSuchElementException: No value present</span> 异常。</p><h3 id="ifPresent"><a href="#ifPresent" class="headerlink" title="ifPresent"></a>ifPresent</h3><p>如果Optional实例有值则为其调用<code>Consumer</code>（函数描述符为<code>T -&gt; void</code>），否则不做处理。如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">girl.ifPresent(g -&gt; System.out.println(<span class="string">"我有女朋友，名字是："</span> + g.getName()));</div></pre></td></tr></table></figure><p></p><h3 id="orElse"><a href="#orElse" class="headerlink" title="orElse"></a>orElse</h3><p>如果Optional实例有值则将其返回，否则返回<code>orElse</code>方法传入的参数。如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">System.out.println(Optional.empty().orElse(<span class="string">"There is no value present!"</span>));</div></pre></td></tr></table></figure><p></p><p>程序将输出<code>There is no value present!</code>。</p><h3 id="orElseGet"><a href="#orElseGet" class="headerlink" title="orElseGet"></a>orElseGet</h3><p><code>orElseGet</code>与<code>orElse</code>方法类似，<code>orElse</code>方法将传入的字符串作为默认值，而<code>orElseGet</code>方法可以接受<code>Supplier</code>（函数描述符为<code>() -&gt; T</code>）来生成默认值。如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">System.out.println(Optional.empty().orElseGet(() -&gt; <span class="string">"There is no value present!"</span>));</div></pre></td></tr></table></figure><p></p><p>程序同样输出<code>There is no value present!</code>。</p><h3 id="orElseThrow"><a href="#orElseThrow" class="headerlink" title="orElseThrow"></a>orElseThrow</h3><p>如果有值则将其返回，否则抛出<code>Supplier</code>接口创建的异常。如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">try</span> &#123;</div><div class="line">    Optional.empty().orElseThrow(NoSuchElementException::<span class="keyword">new</span>);</div><div class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">    e.printStackTrace();</div><div class="line">&#125;</div></pre></td></tr></table></figure><p></p><p>代码将捕获到 <span style="color:red">java.util.NoSuchElementException: No value present</span> 异常。</p><h3 id="map"><a href="#map" class="headerlink" title="map"></a>map</h3><p>如果Optional有值，则对其执行调用<code>Function</code>函数描述符为（<code>T -&gt; R</code>）得到返回值。如果返回值不为null，则创建包含<code>Function</code>回值的Optional作为map方法返回值，否则返回空Optional。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Optional&lt;String&gt; upperName = name.map(String::toUpperCase);</div><div class="line">System.out.println(upperName.orElse(<span class="string">"No value found"</span>));</div></pre></td></tr></table></figure><p></p><h3 id="flatMap"><a href="#flatMap" class="headerlink" title="flatMap"></a>flatMap</h3><p>如果有值，为其执行<code>Function</code>函数返回Optional类型返回值，否则返回空Optional。<code>flatMap</code>与<code>map</code>方法类似，区别在于<code>flatMap</code>中的<code>Function</code>函数返回值必须是Optional。调用结束时，<code>flatMap</code>不会对结果用Optional封装。如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">upperName = name.flatMap((value) -&gt; Optional.of(value.toUpperCase()));</div><div class="line">System.out.println(upperName.orElse(<span class="string">"No value found"</span>));</div></pre></td></tr></table></figure><p></p><h3 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h3><p>filter个方法通过传入<code>Predicate</code>（函数描述符为<code>T -&gt; Boolean</code>）对Optional实例的值进行过滤。如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Optional&lt;String&gt; name = Optional.of(<span class="string">"Jane"</span>);</div><div class="line">Optional&lt;String&gt; LongName = name.filter((value) -&gt; value.length() &gt;= <span class="number">3</span>);</div><div class="line">System.out.println(LongName.orElse(<span class="string">"名字长度小于3个字符"</span>));</div></pre></td></tr></table></figure><p></p><p>方法输出<code>Jane</code>。</p><h2 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h2><p>介绍完Optional类的方法后，我们使用Optional改善一开始的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> String <span class="title">getGirlFriendName</span><span class="params">(Department department)</span> </span>&#123;</div><div class="line">    Optional&lt;Department&gt; opt = Optional.ofNullable(department);</div><div class="line">    <span class="keyword">return</span> opt.map(Department::getEmployee)</div><div class="line">            .map(Employee::getGirlFriend)</div><div class="line">            .map(Girl::getName)</div><div class="line">            .orElseThrow(NoSuchElementException::<span class="keyword">new</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p></p><p>整洁而又不失逼格。</p><p><img src="img/QQ图片20180702095708.jpg" alt="QQ图片20180702095708.jpg"></p><blockquote><p><a href="https://book.douban.com/subject/26772632/" target="_blank" rel="external">《Java 8实战》</a>读书笔记</p></blockquote><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Tue Aug 21 2018 16:24:26 GMT+0800 (中国标准时间) --&gt;&lt;p&gt;在Java中对一个空对象进行操作时，便会抛出最常见的异常&lt;code&gt;NullPointerException&lt;/code&gt;。为了改善这个问题，Java 8中提供了一个&lt;code&gt;java.util.Optional&amp;lt;T&amp;gt;&lt;/code&gt;类型。Optional类的Javadoc描述如下：这是一个可以为null的容器对象。如果值存在则&lt;code&gt;isPresent()&lt;/code&gt;方法会返回true，调用&lt;code&gt;get()&lt;/code&gt;方法会返回该对象。下面介绍Optional类的使用方法。
    
    </summary>
    
    
      <category term="Java" scheme="http://mrbird.cc/tags/Java/"/>
    
      <category term="Java 8" scheme="http://mrbird.cc/tags/Java-8/"/>
    
  </entry>
  
  <entry>
    <title>【Java8实战】使用并行流</title>
    <link href="http://mrbird.cc/Java8-parallelStream.html"/>
    <id>http://mrbird.cc/Java8-parallelStream.html</id>
    <published>2018-04-18T02:19:29.000Z</published>
    <updated>2018-06-27T07:33:24.169Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Tue Aug 21 2018 16:24:24 GMT+0800 (中国标准时间) --><p>除了顺序流外，Java 8中也可以对集合对象调用<code>parallelStream</code>方法或者对顺序流调用<code>parallel</code>方法来生成并行流。并行流就是一个把内容分成多个数据块，并用不同的线程分别处理每个数据块的流。这样在使用流处理数据规模较大的集合对象时可以充分的利用多核CPU来提高处理效率。不过在一些情况下，并行流未必会比顺序流快，甚至会慢很多，所以了解如何高效的使用并行流也至关重要。此外，我们也可以调用流的<code>sequential</code>方法，将并行流转换为顺序流。<a id="more"></a></p><h2 id="测试并行流的性能"><a href="#测试并行流的性能" class="headerlink" title="测试并行流的性能"></a>测试并行流的性能</h2><p>举个例子，对1到1000的整数求和，观察顺序流和并行流的处理时间：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StreamExample</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line"></div><div class="line">        StreamExample.test((n) -&gt; LongStream.rangeClosed(<span class="number">1L</span>, n).reduce(<span class="number">0L</span>, Long::sum), <span class="number">1000L</span>);</div><div class="line">        StreamExample.test((n) -&gt; LongStream.rangeClosed(<span class="number">1L</span>, n).parallel().reduce(<span class="number">0L</span>, Long::sum), <span class="number">1000L</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(LongConsumer c, Long n)</span> </span>&#123;</div><div class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</div><div class="line">        c.accept(n);</div><div class="line">        <span class="keyword">long</span> end = System.currentTimeMillis();</div><div class="line">        System.out.println(<span class="string">"处理时间："</span> + (end - start) + <span class="string">"msc"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p></p><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">处理时间：9msc</div><div class="line">处理时间：484msc</div></pre></td></tr></table></figure><p></p><p>结果和我们预期的不一致，这是因为在处理数据集规模不大的情况下，将流并行化所带来的额外开销比逻辑代码开销还大。我们将数据集扩大：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">StreamExample.test((n) -&gt; LongStream.rangeClosed(<span class="number">1L</span>, n).reduce(<span class="number">0L</span>, Long::sum), <span class="number">1000000000L</span>);</div><div class="line">StreamExample.test((n) -&gt; LongStream.rangeClosed(<span class="number">1L</span>, n).parallel().reduce(<span class="number">0L</span>, Long::sum), <span class="number">1000000000L</span>);</div></pre></td></tr></table></figure><p></p><p>运行结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">处理时间：<span class="number">2775</span>msc</div><div class="line">处理时间：<span class="number">725</span>msc</div></pre></td></tr></table></figure><p></p><div class="note info"><p>对于较小的数据量，选择并行流不是一个好的决定。并行处理少数几个元素的好处还抵不上并行化造成的额外开销。设N是要处理的元素的总数，Q是一个元素通过流水线的大致处理成本，则N*Q就是这个对成本的一个粗略的定性估计。Q值较高就意味着使用并行流时性能好的可能性比较大。</p></div><p>接着对比下使用并行流处理包装类型的求和与原始类型的求和运行时间对比：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">StreamExample.test((n) -&gt; Stream.iterate(<span class="number">1L</span>, a -&gt; a + <span class="number">1L</span>).limit(n).reduce(<span class="number">0L</span>, Long::sum), <span class="number">1000000000L</span>);</div><div class="line">StreamExample.test((n) -&gt; LongStream.rangeClosed(<span class="number">1L</span>, n).parallel().reduce(<span class="number">0L</span>, Long::sum), <span class="number">1000000000L</span>);</div></pre></td></tr></table></figure><p></p><p>运行结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">处理时间：<span class="number">21915</span>msc</div><div class="line">处理时间：<span class="number">920</span>msc</div></pre></td></tr></table></figure><p></p><p>因为iterate生成的是包装类型的对象，必须拆箱成原始类型才能求和，而且我们很难把iterate分成多个独立块来并行执行。所以可以看到来两者间的运行效率差了将近24倍！</p><div class="note info"><p>在实际中应避免频繁拆装箱；有些操作本身在并行流上的性能就比顺序流差。特别是limit和findFirst等依赖于元 素顺序的操作，它们在并行流上执行的代价非常大。例如，findAny会比findFirst性 能好，因为它不一定要按顺序来执行。</p></div><p></p><p>再看一个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StreamExample</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line"></div><div class="line">        ArrayList&lt;Long&gt; arrayList = Stream.iterate(<span class="number">1L</span>, a -&gt; a + <span class="number">1L</span>).limit(<span class="number">10000000L</span>).collect(toCollection(ArrayList::<span class="keyword">new</span>));</div><div class="line">        LinkedList&lt;Long&gt; linkedList = Stream.iterate(<span class="number">1L</span>, a -&gt; a + <span class="number">1L</span>).limit(<span class="number">10000000L</span>).collect(toCollection(LinkedList::<span class="keyword">new</span>));</div><div class="line"></div><div class="line">        StreamExample.test(() -&gt; arrayList.parallelStream().reduce(<span class="number">0L</span>, Long::sum));</div><div class="line">        StreamExample.test(() -&gt; linkedList.parallelStream().reduce(<span class="number">0L</span>, Long::sum));</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(Runner r)</span> </span>&#123;</div><div class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</div><div class="line">        r.run();</div><div class="line">        <span class="keyword">long</span> end = System.currentTimeMillis();</div><div class="line">        System.out.println(<span class="string">"处理时间："</span> + (end - start) + <span class="string">"msc"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="meta">@FunctionalInterface</span></div><div class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Runner</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p></p><p>上面代码对比了使用并行流处理ArrayList和使用并行流处理LinkedList的性能对比，运行结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">处理时间：1258msc</div><div class="line">处理时间：7933msc</div></pre></td></tr></table></figure><p></p><p>之所以出现这个结果，是因为ArrayList的拆分效率比LinkedList高得多，前者用不着遍历就可以平均拆分，而后者则必须遍历。</p><div class="note info"><p>使用并行流要考虑流背后的数据结构是否易于分解。用range方法创建的原始类型流也可以快速分解。</p></div><p>下表列出了流的数据源和可分解性：</p><table><tr><th>数据源</th><th>可分解性</th></tr><tr><td>ArrayList</td><td>很好</td></tr><tr><td>LinkedList</td><td>很差</td></tr><tr><td>IntStream.range</td><td>很好</td></tr><tr><td>Stream.iterate</td><td>很差</td></tr><tr><td>HashSet</td><td>好</td></tr><tr><td>TreeSet</td><td>好</td></tr></table><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>总而言之，使用并行流应该考虑以下几点：</p><ul><li><p>留意拆装箱成本；</p></li><li><p>流中依赖于元素顺序的操作，在并行流上执行的代价非常大；</p></li><li><p>考虑流的流水线操作总成本，对于较小的数据量，并不适合使用并行流；</p></li><li><p>考虑流背后的数据结构是否易于分解，不易分解的数据结构不适合使用并行流。</p></li></ul><blockquote><p><a href="https://book.douban.com/subject/26772632/" target="_blank" rel="external">《Java 8实战》</a>读书笔记</p></blockquote><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Tue Aug 21 2018 16:24:24 GMT+0800 (中国标准时间) --&gt;&lt;p&gt;除了顺序流外，Java 8中也可以对集合对象调用&lt;code&gt;parallelStream&lt;/code&gt;方法或者对顺序流调用&lt;code&gt;parallel&lt;/code&gt;方法来生成并行流。并行流就是一个把内容分成多个数据块，并用不同的线程分别处理每个数据块的流。这样在使用流处理数据规模较大的集合对象时可以充分的利用多核CPU来提高处理效率。不过在一些情况下，并行流未必会比顺序流快，甚至会慢很多，所以了解如何高效的使用并行流也至关重要。此外，我们也可以调用流的&lt;code&gt;sequential&lt;/code&gt;方法，将并行流转换为顺序流。
    
    </summary>
    
    
      <category term="Java" scheme="http://mrbird.cc/tags/Java/"/>
    
      <category term="Java 8" scheme="http://mrbird.cc/tags/Java-8/"/>
    
  </entry>
  
  <entry>
    <title>【Java8实战】使用流收集数据</title>
    <link href="http://mrbird.cc/java8stream2.html"/>
    <id>http://mrbird.cc/java8stream2.html</id>
    <published>2018-04-15T08:02:52.000Z</published>
    <updated>2018-06-22T08:36:32.085Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Tue Aug 21 2018 16:24:26 GMT+0800 (中国标准时间) --><p>在上一节中，我们了解到终端操作<code>collect</code>方法用于收集流中的元素，并放到不同类型的结果中，比如<code>List</code>、<code>Set</code>或者<code>Map</code>。其实<code>collect</code>方法可以接受各种Collectors接口的静态方法作为参数来实现更为强大的规约操作，比如查找最大值最小值，汇总，分区和分组等等。<a id="more"></a></p><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>为了演示Collectors接口中的静态方法使用，这里创建一个Dish类（菜谱类）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Dish</span> </span>&#123;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">enum</span> Type &#123;MEAT, FISH, OTHER&#125;</div><div class="line"></div><div class="line">    <span class="comment">/** 食物名称 */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String name;</div><div class="line">    <span class="comment">/** 是否是素食 */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> vegetarian;</div><div class="line">    <span class="comment">/** 卡路里 */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> calories;</div><div class="line">    <span class="comment">/** 类型：肉，海鲜，其他 */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Type type;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Dish</span><span class="params">(String name, <span class="keyword">boolean</span> vegetarian, <span class="keyword">int</span> calories, Type type)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.name = name;</div><div class="line">        <span class="keyword">this</span>.vegetarian = vegetarian;</div><div class="line">        <span class="keyword">this</span>.calories = calories;</div><div class="line">        <span class="keyword">this</span>.type = type;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">     <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</div><div class="line">       <span class="keyword">return</span> <span class="keyword">this</span>.getName();</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// get,set略</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><p></p><p>然后创建一个List，包含各种食材：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">List&lt;Dish&gt; list = Arrays.asList(</div><div class="line">        <span class="keyword">new</span> Dish(<span class="string">"pork"</span>, <span class="keyword">false</span>, <span class="number">800</span>, Dish.Type.MEAT),</div><div class="line">        <span class="keyword">new</span> Dish(<span class="string">"beef"</span>, <span class="keyword">false</span>, <span class="number">700</span>, Dish.Type.MEAT),</div><div class="line">        <span class="keyword">new</span> Dish(<span class="string">"chicken"</span>, <span class="keyword">false</span>, <span class="number">400</span>, Dish.Type.MEAT),</div><div class="line">        <span class="keyword">new</span> Dish(<span class="string">"french fries"</span>, <span class="keyword">true</span>, <span class="number">530</span>, Dish.Type.OTHER),</div><div class="line">        <span class="keyword">new</span> Dish(<span class="string">"rice"</span>, <span class="keyword">true</span>, <span class="number">350</span>, Dish.Type.OTHER),</div><div class="line">        <span class="keyword">new</span> Dish(<span class="string">"season fruit"</span>, <span class="keyword">true</span>, <span class="number">120</span>, Dish.Type.OTHER),</div><div class="line">        <span class="keyword">new</span> Dish(<span class="string">"pizza"</span>, <span class="keyword">true</span>, <span class="number">550</span>, Dish.Type.OTHER),</div><div class="line">        <span class="keyword">new</span> Dish(<span class="string">"prawns"</span>, <span class="keyword">false</span>, <span class="number">300</span>, Dish.Type.FISH),</div><div class="line">        <span class="keyword">new</span> Dish(<span class="string">"salmon"</span>, <span class="keyword">false</span>, <span class="number">450</span>, Dish.Type.FISH) );</div></pre></td></tr></table></figure><p></p><p>在测试类中导入所有Collectors接口的静态方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.util.stream.Collectors.*;</div></pre></td></tr></table></figure><p></p><h2 id="规约与汇总"><a href="#规约与汇总" class="headerlink" title="规约与汇总"></a>规约与汇总</h2><h3 id="最大最小值"><a href="#最大最小值" class="headerlink" title="最大最小值"></a>最大最小值</h3><p><code>Collectors.maxBy</code>和<code>Collectors.minBy</code>用来计算流中的最大或最小值，比如按卡路里的大小来筛选出卡路里最高的食材：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">list.stream()</div><div class="line">    .collect(maxBy(Comparator.comparingInt(Dish::getCalories)))</div><div class="line">    .ifPresent(System.out::println);</div></pre></td></tr></table></figure><p></p><p>输出<code>pork</code>。</p><h3 id="汇总"><a href="#汇总" class="headerlink" title="汇总"></a>汇总</h3><p><code>Collectors.summingInt</code>可以用于求和，参数类型为int类型。相应的基本类型对应的方法还有<code>Collectors.summingLong</code>和<code>Collectors.summingDouble</code>。比如求所有食材的卡路里：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">list.stream().collect(summingInt(Dish::getCalories)); <span class="comment">// 4200</span></div></pre></td></tr></table></figure><p></p><p><code>Collectors.averagingInt</code>方法用于求平均值，参数类型为int类型。相应的基本类型对应的方法还有<code>Collectors.averagingLong</code>和<code>Collectors.averagingDouble</code>。比如求所有食材的平均卡路里:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">list.stream().collect(averagingInt(Dish::getCalories)); <span class="comment">// 466.6666666666667</span></div></pre></td></tr></table></figure><p></p><p><code>Collectors.summarizingInt</code>方法可以一次性返回元素个数，最大值，最小值，平均值和总和：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">IntSummaryStatistics iss = list.stream().collect(summarizingInt(Dish::getCalories));</div><div class="line">System.out.println(iss); <span class="comment">// IntSummaryStatistics&#123;count=9, sum=4200, min=120, average=466.666667, max=800&#125;</span></div></pre></td></tr></table></figure><p></p><p>同样，相应的<code>summarizingLong</code>和<code>summarizingDouble</code>方法有相关的<code>LongSummaryStatistics</code>和<code>DoubleSummaryStatistics</code>类型，适用于收集的属性是原始类型long或double的情况。</p><h3 id="拼接"><a href="#拼接" class="headerlink" title="拼接"></a>拼接</h3><p><code>Collectors.joining</code>方法会把流中每一个对象应用<code>toString</code>方法得到的所有字符串连接成一个字符串。如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">list.stream().map(Dish::getName).collect(joining()); </div><div class="line"><span class="comment">// porkbeefchickenfrench friesriceseason fruitpizzaprawnssalmon</span></div></pre></td></tr></table></figure><p></p><p>内部拼接采用了<code>StringBuilder</code>。除此之外，也可以指定拼接符：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">list.stream().map(Dish::getName).collect(joining(<span class="string">"，"</span>));</div><div class="line"><span class="comment">// pork，beef，chicken，french fries，rice，season fruit，pizza，prawns，salmon</span></div></pre></td></tr></table></figure><p></p><h3 id="reducing"><a href="#reducing" class="headerlink" title="reducing"></a>reducing</h3><p><code>Collectors.reducing</code>方法可以实现求和，最大值最小值筛选，拼接等操作。上面介绍的方法在编程上更方便快捷，但<code>reducing</code>的可读性更高，实际使用哪种我觉得还是看个人喜好。举个使用<code>reducing</code>求最大值的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">list.stream().collect(reducing(<span class="number">0</span>, Dish::getCalories, Integer::max)); <span class="comment">// 800</span></div></pre></td></tr></table></figure><p></p><p>或者：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">list.stream().map(Dish::getCalories).collect(reducing(<span class="number">0</span>, Integer::max)); <span class="comment">// 800</span></div></pre></td></tr></table></figure><p></p><h2 id="分组"><a href="#分组" class="headerlink" title="分组"></a>分组</h2><p>分组功能类似于SQL里的<code>group by</code>，可以对流中的元素按照指定分组规则进行分组。</p><h3 id="普通分组"><a href="#普通分组" class="headerlink" title="普通分组"></a>普通分组</h3><p><code>Collectors.groupingBy</code>方法可以轻松的完成分组操作。比如现在对List中的食材按照类型进行分组：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Map&lt;Dish.Type, List&lt;Dish&gt;&gt; dishesByType = list.stream().collect(groupingBy(Dish::getType));</div><div class="line">System.out.println(dishesByType);</div></pre></td></tr></table></figure><p></p><p>输出结果<code>{OTHER=[french fries, rice, season fruit, pizza], FISH=[prawns, salmon], MEAT=[pork, beef, chicken]}</code>。</p><p>我们也可以自定义分组规则，比如按照卡路里的高低分为高热量，正常和低热量：</p><p>首先定义一个卡路里高低的枚举类型</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">enum</span> CaloricLevel &#123; DIET, NORMAL, FAT &#125;;</div></pre></td></tr></table></figure><p></p><p>然后编写分组规则：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">Map&lt;CaloricLevel, List&lt;Dish&gt;&gt; dishesByCalories = list.stream().collect(</div><div class="line">        groupingBy(d -&gt; &#123;</div><div class="line">            <span class="keyword">if</span> (d.getCalories() &lt;= <span class="number">400</span>) <span class="keyword">return</span> CaloricLevel.DIET;</div><div class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (d.getCalories() &lt;= <span class="number">700</span>) <span class="keyword">return</span> CaloricLevel.NORMAL;</div><div class="line">            <span class="keyword">else</span> <span class="keyword">return</span> CaloricLevel.FAT;</div><div class="line">        &#125;)</div><div class="line">);</div><div class="line">System.out.println(dishesByCalories);</div></pre></td></tr></table></figure><p></p><p>输出结果：<code>{DIET=[chicken, rice, season fruit, prawns], NORMAL=[beef, french fries, pizza, salmon], FAT=[pork]}</code>。</p><h3 id="多级分组"><a href="#多级分组" class="headerlink" title="多级分组"></a>多级分组</h3><p><code>Collectors.groupingBy</code>支持嵌套实现多级分组，比如将食材按照类型分类，然后再按照卡路里的高低分类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"> Map&lt;Dish.Type, Map&lt;CaloricLevel, List&lt;Dish&gt;&gt;&gt; dishesGroup = list.stream().collect(</div><div class="line">        groupingBy(Dish::getType, groupingBy(d -&gt; &#123;</div><div class="line">                    <span class="keyword">if</span> (d.getCalories() &lt;= <span class="number">400</span>) <span class="keyword">return</span> CaloricLevel.DIET;</div><div class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (d.getCalories() &lt;= <span class="number">700</span>) <span class="keyword">return</span> CaloricLevel.NORMAL;</div><div class="line">                    <span class="keyword">else</span> <span class="keyword">return</span> CaloricLevel.FAT;</div><div class="line">                &#125;)</div><div class="line">        ));</div><div class="line">System.out.println(dishesGroup);</div></pre></td></tr></table></figure><p></p><p>返回结果是一个二级Map，输出结果<code>{FISH={DIET=[prawns], NORMAL=[salmon]}, OTHER={DIET=[rice, season fruit], NORMAL=[french fries, pizza]}, MEAT={DIET=[chicken], FAT=[pork], NORMAL=[beef]}}</code>。</p><p>实际上，第二个参数除了<code>Collectors.groupingBy</code>外，也可以传递其他规约操作，规约的结果类型对应Map里的第二个泛型。举些例子，将食材按照类型分，然后统计各个类型对应的数量：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Map&lt;Dish.Type, Long&gt; dishesCountByType = list.stream().collect(groupingBy(Dish::getType,counting()));</div><div class="line">System.out.println(dishesCountByType);</div></pre></td></tr></table></figure><p></p><p>因为<code>Collectors.counting</code>方法返回Long类型，所以Map第二个泛型也必须指定为Long。输出结果：<code>{OTHER=4, FISH=2, MEAT=3}</code>。</p><p>或者对食材按照类型分，然后选出卡路里最高的食物：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Map&lt;Dish.Type, Optional&lt;Dish&gt;&gt; map = list.stream().collect(groupingBy(</div><div class="line">        Dish::getType, maxBy(Comparator.comparing(Dish::getCalories))</div><div class="line">));</div><div class="line">System.out.println(map);</div></pre></td></tr></table></figure><p></p><p>输出结果：<code>{OTHER=Optional[pizza], MEAT=Optional[pork], FISH=Optional[salmon]}</code>。如果不希望输出结果包含Optional，可以使用<code>Collectors.collectingAndThen</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Map&lt;Dish.Type, Dish&gt; map = list.stream().collect(groupingBy(</div><div class="line">        Dish::getType, collectingAndThen(maxBy(Comparator.comparing(Dish::getCalories)), Optional::get)</div><div class="line">));</div><div class="line">System.out.println(map);</div></pre></td></tr></table></figure><p></p><p>输出结果：<code>{OTHER=pizza, FISH=salmon, MEAT=pork}</code>。</p><p>常与<code>Collectors.groupingBy</code>组合使用的方法还有<code>Collectors.mapping</code>。<code>Collectors.mapping</code>方法接受两个参数：一个函数对流中的元素做变换，另一个则将变换的结果对象收集起来，比如对食材按照类型分类，然后输出各种类型食材下卡路里等级情况：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">Map&lt;Dish.Type, HashSet&lt;CaloricLevel&gt;&gt; map = list.stream().collect(groupingBy(</div><div class="line">        Dish::getType, mapping(</div><div class="line">                d -&gt; &#123;</div><div class="line">                    <span class="keyword">if</span> (d.getCalories() &lt;= <span class="number">400</span>) <span class="keyword">return</span> CaloricLevel.DIET;</div><div class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (d.getCalories() &lt;= <span class="number">700</span>) <span class="keyword">return</span> CaloricLevel.NORMAL;</div><div class="line">                    <span class="keyword">else</span> <span class="keyword">return</span> CaloricLevel.FAT;</div><div class="line">                &#125;, toCollection(HashSet::<span class="keyword">new</span>)</div><div class="line">        )</div><div class="line">));</div><div class="line">System.out.println(map);</div></pre></td></tr></table></figure><p></p><p><code>Collectors.toCollection</code>方法可以方便的构造各种类型的集合。输出结果：<code>{FISH=[DIET, NORMAL], MEAT=[DIET, NORMAL, FAT], OTHER=[DIET, NORMAL]}</code>。</p><h2 id="分区"><a href="#分区" class="headerlink" title="分区"></a>分区</h2><p>分区类似于分组，只不过分区最多两种结果。<code>Collectors.partitioningBy</code>方法用于分区操作，接收一个<code>Predicate&lt;T&gt;</code>类型的Lambda表达式作为参数。比如将食材按照素食与否分类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Map&lt;Boolean, List&lt;Dish&gt;&gt; map = list.stream().collect(partitioningBy(Dish::isVegetarian));</div><div class="line">System.out.println(map);</div></pre></td></tr></table></figure><p></p><p>输出结果：<code>{false=[pork, beef, chicken, prawns, salmon], true=[french fries, rice, season fruit, pizza]}</code>。</p><p><code>Collectors.partitioningBy</code>方法还支持传入分组函数或者其他规约操作，比如将食材按照素食与否分类，然后按照食材类型进行分类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Map&lt;Boolean, Map&lt;Dish.Type, List&lt;Dish&gt;&gt;&gt; map = list.stream().collect(</div><div class="line">        partitioningBy(Dish::isVegetarian, groupingBy(Dish::getType)));</div><div class="line">System.out.println(map);</div></pre></td></tr></table></figure><p></p><p>输出结果：<code>{false={MEAT=[pork, beef, chicken], FISH=[prawns, salmon]}, true={OTHER=[french fries, rice, season fruit, pizza]}}</code>。</p><p>再如将食材按照素食与否分类，然后筛选出各自类型中卡路里含量最低的食材：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Map&lt;Boolean, Dish&gt; map = list.stream().collect(</div><div class="line">        partitioningBy(Dish::isVegetarian, collectingAndThen(</div><div class="line">                minBy(Comparator.comparing(Dish::getCalories)), Optional::get</div><div class="line">        )));</div><div class="line">System.out.println(map);</div></pre></td></tr></table></figure><p></p><p>输出结果：<code>{false=prawns, true=season fruit}</code>。</p><blockquote><p><a href="https://book.douban.com/subject/26772632/" target="_blank" rel="external">《Java 8实战》</a>读书笔记</p></blockquote><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Tue Aug 21 2018 16:24:26 GMT+0800 (中国标准时间) --&gt;&lt;p&gt;在上一节中，我们了解到终端操作&lt;code&gt;collect&lt;/code&gt;方法用于收集流中的元素，并放到不同类型的结果中，比如&lt;code&gt;List&lt;/code&gt;、&lt;code&gt;Set&lt;/code&gt;或者&lt;code&gt;Map&lt;/code&gt;。其实&lt;code&gt;collect&lt;/code&gt;方法可以接受各种Collectors接口的静态方法作为参数来实现更为强大的规约操作，比如查找最大值最小值，汇总，分区和分组等等。
    
    </summary>
    
    
      <category term="Java" scheme="http://mrbird.cc/tags/Java/"/>
    
      <category term="Java 8" scheme="http://mrbird.cc/tags/Java-8/"/>
    
  </entry>
  
  <entry>
    <title>【Java8实战】开始使用流</title>
    <link href="http://mrbird.cc/java8stream1.html"/>
    <id>http://mrbird.cc/java8stream1.html</id>
    <published>2018-04-12T07:53:30.000Z</published>
    <updated>2018-06-20T08:07:43.782Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Tue Aug 21 2018 16:24:26 GMT+0800 (中国标准时间) --><p>Java 8 中的 Stream 俗称为流，它与 java.io 包里的 InputStream 和 OutputStream 是完全不同的概念。Stream 用于对集合对象进行各种非常便利、高效的聚合操作，或者大批量数据操作。Stream API 借助于Lambda 表达式，极大的提高编程效率和程序可读性。同时它提供串行和并行两种模式进行汇聚操作，并发模式能够充分利用多核处理器的优势。通过下面的例子我们可以初步体会到使用 Stream 处理集合的便利性。<a id="more"></a></p><h2 id="初探Stream"><a href="#初探Stream" class="headerlink" title="初探Stream"></a>初探Stream</h2><p>有如下一个List，现要从中筛选出以<code>J</code>开头的元素，然后转换为大写，最后输出结果。Java 8之前我们是这样做的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">List&lt;String&gt; list = Arrays.asList(<span class="string">"Java"</span>, <span class="string">"JavaScript"</span>, <span class="string">"python"</span>, <span class="string">"PHP"</span>, <span class="string">"C#"</span>, <span class="string">"Golang"</span>, <span class="string">"Swift"</span>);</div><div class="line">List&lt;String&gt; filterList = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line"><span class="keyword">for</span> (String str : list) &#123;</div><div class="line">    <span class="keyword">if</span> (str.startsWith(<span class="string">"J"</span>)) &#123;</div><div class="line">        filterList.add(str.toUpperCase());</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">for</span> (String str : filterList) &#123;</div><div class="line">    System.out.println(str);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p></p><p>为了筛选集合我们进行了两次外部迭代，并且还创建了一个用来临时存放筛选元素的集合对象。借助Java 8中的Stream我们可以极大的简化这个处理过程：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">List&lt;String&gt; list = Arrays.asList(<span class="string">"Java"</span>, <span class="string">"JavaScript"</span>, <span class="string">"python"</span>, <span class="string">"PHP"</span>, <span class="string">"C#"</span>, <span class="string">"Golang"</span>, <span class="string">"Swift"</span>);</div><div class="line">list.stream()</div><div class="line">    .filter(s -&gt; s.startsWith(<span class="string">"J"</span>))</div><div class="line">    .map(String::toUpperCase)</div><div class="line">    .forEach(System.out::println);</div></pre></td></tr></table></figure><p></p><p>是不是很方便？上面的例子中，集合使用<code>stream</code>方法创建了一个流，然后使用<code>filter</code>和<code>map</code>方法来处理这个集合，它们统称为<strong>中间操作</strong>。中间操作都会返回另一个流，以便于将各种对集合的操作连接起来形成一条流水线。最后我们使用了<code>forEach</code>方法迭代筛选结果，这种位于流的末端，对流进行处理并且生成结果的方法称为<strong>终端操作</strong>。</p><p>总而言之，流的使用一般包括三件事情：</p><ol><li><p>一个<strong>数据源</strong>（如集合）来执行一个查询；</p></li><li><p>一个<strong>中间操作</strong>链，形成一条流的流水线；</p></li><li><p>一个<strong>终端操作</strong>，执行流水线，并能生成结果。</p></li></ol><p>下表列出了流中常见的中间操作和终端操作：</p><p><table><tr><th>操作</th><th>类型</th><th>返回类型</th><th>使用的类型/函数式接口</th><th>函数描述符</th></tr><tr><td>filter</td><td>中间</td><td><code>Stream&lt;T&gt;</code></td><td><code>Predicate&lt;T&gt;</code></td><td><code>T -&gt; boolean</code></td></tr><tr><td>distinct</td><td>中间</td><td><code>Stream&lt;T&gt;</code></td><td></td><td></td></tr><tr><td>skip</td><td>中间</td><td><code>Stream&lt;T&gt;</code></td><td><code>long</code></td><td></td></tr><tr><td>limit</td><td>中间</td><td><code>Stream&lt;T&gt;</code></td><td><code>long</code></td><td></td></tr><tr><td>map</td><td>中间</td><td><code>Stream&lt;R&gt;</code></td><td><code>Function&lt;T, R&gt;</code></td><td><code>T -&gt; R</code></td></tr><tr><td>flatMap</td><td>中间</td><td><code>Stream&lt;R&gt;</code></td><td><code>Function&lt;T, Stream&lt;R&gt;&gt;</code></td><td><code>T -&gt; Stream&lt;R&gt;</code></td></tr><tr><td>sorted</td><td>中间</td><td><code>Stream&lt;T&gt;</code></td><td><code>Comparator&lt;T&gt;</code></td><td><code>(T, T) -&gt; int</code></td></tr><tr><td>anyMatch</td><td>终端</td><td><code>boolean</code></td><td><code>Predicate&lt;T&gt;</code></td><td><code>T -&gt; boolean</code></td></tr><tr><td>noneMatch</td><td>终端</td><td><code>boolean</code></td><td><code>Predicate&lt;T&gt;</code></td><td><code>T -&gt; boolean</code></td></tr><tr><td>allMatch</td><td>终端</td><td><code>boolean</code></td><td><code>Predicate&lt;T&gt;</code></td><td><code>T -&gt; boolean</code></td></tr><tr><td>findAny</td><td>终端</td><td><code>Optional&lt;T&gt;</code></td><td></td><td></td></tr><tr><td>findFirst</td><td>终端</td><td><code>Optional&lt;T&gt;</code></td><td></td><td></td></tr><tr><td>forEach</td><td>终端</td><td><code>void</code></td><td><code>Consumer&lt;T&gt;</code></td><td><code>T -&gt; void</code></td></tr><tr><td>collect</td><td>终端</td><td><code>R</code></td><td><code>Collector&lt;T, A, R&gt;</code></td><td></td></tr><tr><td>reduce</td><td>终端</td><td><code>Optional&lt;T&gt;</code></td><td><code>BinaryOperator&lt;T&gt;</code></td><td><code>(T, T) -&gt; T</code></td></tr><tr><td>count</td><td>终端</td><td><code>long</code></td><td></td><td></td></tr></table>下面详细介绍这些操作的使用。除了特殊说明，默认使用下面这个集合作为演示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">List&lt;String&gt; list = Arrays.asList(<span class="string">"Java"</span>, <span class="string">"JavaScript"</span>, <span class="string">"python"</span>, <span class="string">"PHP"</span>, <span class="string">"C#"</span>, <span class="string">"Golang"</span>, <span class="string">"Swift"</span>, <span class="string">"C++"</span>, <span class="string">"Ruby"</span>);</div></pre></td></tr></table></figure><p></p><h2 id="中间操作"><a href="#中间操作" class="headerlink" title="中间操作"></a>中间操作</h2><h3 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h3><p>Streams接口支持·<code>filter</code>方法，该方法接收一个<code>Predicate&lt;T&gt;</code>，函数描述符为<code>T -&gt; boolean</code>，用于对集合进行筛选，返回所有满足的元素：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">list.stream()</div><div class="line">    .filter(s -&gt; s.contains(<span class="string">"#"</span>))</div><div class="line">    .forEach(System.out::println);</div></pre></td></tr></table></figure><p></p><p>结果输出<code>C#</code>。</p><h3 id="distinct"><a href="#distinct" class="headerlink" title="distinct"></a>distinct</h3><p><code>distinct</code>方法用于排除流中重复的元素，类似于SQL中的distinct操作。比如筛选中集合中所有的偶数，并排除重复的结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">List&lt;Integer&gt; numbers = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">4</span>);</div><div class="line">numbers.stream()</div><div class="line">       .filter(i -&gt; i % <span class="number">2</span> == <span class="number">0</span>)</div><div class="line">       .distinct()</div><div class="line">       .forEach(System.out::println);</div></pre></td></tr></table></figure><p></p><p>结果输出<code>2 4</code>。</p><h3 id="skip"><a href="#skip" class="headerlink" title="skip"></a>skip</h3><p><code>skip(n)</code>方法用于跳过流中的前n个元素，如果集合元素小于n，则返回空流。比如筛选出以<code>J</code>开头的元素，并排除第一个：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">list.stream()</div><div class="line">    .filter(s -&gt; s.startsWith(<span class="string">"J"</span>))</div><div class="line">    .skip(<span class="number">1</span>)</div><div class="line">    .forEach(System.out::println);</div></pre></td></tr></table></figure><p></p><p>结果输出<code>JavaScript</code>。</p><h3 id="limit"><a href="#limit" class="headerlink" title="limit"></a>limit</h3><p><code>limit(n)</code>方法返回一个长度不超过n的流，比如下面的例子将输出<code>Java JavaScript python</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">list.stream()</div><div class="line">    .limit(<span class="number">3</span>)</div><div class="line">    .forEach(System.out::println);</div></pre></td></tr></table></figure><p></p><h3 id="map"><a href="#map" class="headerlink" title="map"></a>map</h3><p><code>map</code>方法接收一个函数作为参数。这个函数会被应用到每个元素上，并将其映射成一个新的元素。如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">list.stream()</div><div class="line">    .map(String::length)</div><div class="line">    .forEach(System.out::println);</div></pre></td></tr></table></figure><p></p><p>结果输出<code>4 10 6 3 2 6 5 3 4</code>。</p><p><code>map</code>还支持将流特化为指定原始类型的流，如通过<code>mapToInt</code>，<code>mapToDouble</code>和<code>mapToLong</code>方法，可以将流转换为<code>IntStream</code>，<code>DoubleStream</code>和<code>LongStream</code>。特化后的流支持<code>sum</code>，<code>min</code>和<code>max</code>方法来对流中的元素进行计算。比如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">List&lt;Integer&gt; numbers = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">4</span>);</div><div class="line">IntStream intStream = numbers.stream().mapToInt(a -&gt; a);</div><div class="line">System.out.println(intStream.sum()); <span class="comment">// 16</span></div></pre></td></tr></table></figure><p></p><p>也可以通过下面的方法，将<code>IntStream</code>转换为<code>Stream</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Stream&lt;Integer&gt; s = intStream.boxed();</div></pre></td></tr></table></figure><p></p><h3 id="flatMap"><a href="#flatMap" class="headerlink" title="flatMap"></a>flatMap</h3><p><code>flatMap</code>用于将多个流合并成一个流，俗称流的扁平化。这么说有点抽象，举个例子，比如现在需要将list中的各个元素拆分为一个个字母，并过滤掉重复的结果，你可能会这样做：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">list.stream()</div><div class="line">   .map(s -&gt; s.split(<span class="string">""</span>))</div><div class="line">   .distinct()</div><div class="line">   .forEach(System.out::println);</div></pre></td></tr></table></figure><p></p><p>输出如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">[Ljava.lang.String;@e9e54c2</div><div class="line">[Ljava.lang.String;@65ab7765</div><div class="line">[Ljava.lang.String;@1b28cdfa</div><div class="line">[Ljava.lang.String;@eed1f14</div><div class="line">[Ljava.lang.String;@7229724f</div><div class="line">[Ljava.lang.String;@4c873330</div><div class="line">[Ljava.lang.String;@119d7047</div><div class="line">[Ljava.lang.String;@776ec8df</div><div class="line">[Ljava.lang.String;@4eec7777</div></pre></td></tr></table></figure><p></p><p>这明显不符合我们的预期。实际上在<code>map(s -&gt; s.split(&quot;&quot;))</code>操作后，返回了一个<code>Stream&lt;String[]&gt;</code>类型的流，所以输出结果为每个数组对象的句柄，而我们真正想要的结果是<code>Stream&lt;String&gt;</code>！</p><p>在Stream中，可以使用<code>Arrays.stream()</code>方法来将数组转换为流，改造上面的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">list.stream()</div><div class="line">    .map(s -&gt; s.split(<span class="string">""</span>))</div><div class="line">    .map(Arrays::stream)</div><div class="line">    .distinct()</div><div class="line">    .forEach(System.out::println);</div></pre></td></tr></table></figure><p></p><p>输出如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">java.util.stream.ReferencePipeline$Head@eed1f14</div><div class="line">java.util.stream.ReferencePipeline$Head@7229724f</div><div class="line">java.util.stream.ReferencePipeline$Head@4c873330</div><div class="line">java.util.stream.ReferencePipeline$Head@119d7047</div><div class="line">java.util.stream.ReferencePipeline$Head@776ec8df</div><div class="line">java.util.stream.ReferencePipeline$Head@4eec7777</div><div class="line">java.util.stream.ReferencePipeline$Head@3b07d329</div><div class="line">java.util.stream.ReferencePipeline$Head@41629346</div><div class="line">java.util.stream.ReferencePipeline$Head@404b9385</div></pre></td></tr></table></figure><p></p><p>因为上面的流经过<code>map(Arrays::stream)</code>处理后，将每个数组变成了一个新的流，返回结果为流的数组<code>Stream&lt;String&gt;[]</code>，所以输出是各个流的句柄。我们还需将这些新的流连接成一个流，使用<code>flatMap</code>来改写上面的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">list.stream()</div><div class="line">    .map(s -&gt; s.split(<span class="string">""</span>))</div><div class="line">    .flatMap(Arrays::stream)</div><div class="line">    .distinct()</div><div class="line">    .forEach(s -&gt; System.out.print(s + <span class="string">" "</span>));</div></pre></td></tr></table></figure><p></p><p>输出如下：</p><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">J a v S c r i p t y h o n P H C # G l g w f + R u b</div></pre></td></tr></table></figure><p></p><p>和<code>map</code>类似，<code>flatMap</code>方法也有相应的原始类型特化方法，如<code>flatMapToInt</code>等。</p><h2 id="终端操作"><a href="#终端操作" class="headerlink" title="终端操作"></a>终端操作</h2><h3 id="anyMatch"><a href="#anyMatch" class="headerlink" title="anyMatch"></a>anyMatch</h3><p><code>anyMatch</code>方法用于判断流中是否有符合判断条件的元素，返回值为boolean类型。比如判断list中是否含有<code>SQL</code>元素：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">list.stream()</div><div class="line">    .anyMatch(s -&gt; <span class="string">"SQL"</span>.equals(s)); <span class="comment">// false</span></div></pre></td></tr></table></figure><p></p><h3 id="allMatch"><a href="#allMatch" class="headerlink" title="allMatch"></a>allMatch</h3><p><code>allMatch</code>方法用于判断流中是否所有元素都满足给定的判断条件，返回值为boolean类型。比如判断list中是否所有元素长度都不大于10：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">list.stream()</div><div class="line">    .allMatch(s -&gt; s.length() &lt;= <span class="number">10</span>); <span class="comment">// true</span></div></pre></td></tr></table></figure><p></p><h3 id="noneMatch"><a href="#noneMatch" class="headerlink" title="noneMatch"></a>noneMatch</h3><p><code>noneMatch</code>方法用于判断流中是否所有元素都不满足给定的判断条件，返回值为boolean类型。比如判断list中不存在长度大于10的元素：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">list.stream()</div><div class="line">    .noneMatch(s -&gt; s.length() &gt; <span class="number">10</span>); <span class="comment">// true</span></div></pre></td></tr></table></figure><p></p><h3 id="findAny"><a href="#findAny" class="headerlink" title="findAny"></a>findAny</h3><p><code>findAny</code>方法用于返回流中的任意元素的Optional类型，例如筛选出list中任意一个以<code>J</code>开头的元素，如果存在，则输出它：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">list.stream()</div><div class="line">    .filter(s -&gt; s.startsWith(<span class="string">"J"</span>))</div><div class="line">    .findAny()</div><div class="line">    .ifPresent(System.out::println); <span class="comment">// Java</span></div></pre></td></tr></table></figure><p></p><h3 id="findFirst"><a href="#findFirst" class="headerlink" title="findFirst"></a>findFirst</h3><p><code>findFirst</code>方法用于返回流中的第一个元素的Optional类型，例如筛选出list中长度大于5的元素，如果存在，则输出第一个：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">list.stream()</div><div class="line">    .filter(s -&gt; s.length() &gt; <span class="number">5</span>)</div><div class="line">    .findFirst()</div><div class="line">    .ifPresent(System.out::println); <span class="comment">// JavaScript</span></div></pre></td></tr></table></figure><p></p><h3 id="reduce"><a href="#reduce" class="headerlink" title="reduce"></a>reduce</h3><p><code>reduce</code>函数从字面上来看就是压缩，缩减的意思，它可以用于数字类型的流的求和，求最大值和最小值。如对numbers中的元素求和：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">List&lt;Integer&gt; numbers = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">4</span>);</div><div class="line">numbers.stream()</div><div class="line">       .reduce(<span class="number">0</span>, Integer::sum); <span class="comment">// 16</span></div></pre></td></tr></table></figure><p></p><p><code>reduce</code>函数也可以不指定初始值，但这时候将返回一个Optional对象，比如求最大值和最小值：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">numbers.stream()</div><div class="line">       .reduce(Integer::max)</div><div class="line">       .ifPresent(System.out::println); <span class="comment">// 4</span></div><div class="line"></div><div class="line">numbers.stream()</div><div class="line">       .reduce(Integer::min)</div><div class="line">       .ifPresent(System.out::println); <span class="comment">// 1</span></div></pre></td></tr></table></figure><p></p><h3 id="forEach"><a href="#forEach" class="headerlink" title="forEach"></a>forEach</h3><p><code>forEach</code>用于迭代流中的每个元素，最为常见的就是迭代输出，如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">list.stream().forEach(System.out::println);</div></pre></td></tr></table></figure><p></p><h3 id="count"><a href="#count" class="headerlink" title="count"></a>count</h3><p><code>count</code>方法用于统计流中元素的个数，比如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">list.stream().count(); <span class="comment">// 9</span></div></pre></td></tr></table></figure><p></p><h3 id="collect"><a href="#collect" class="headerlink" title="collect"></a>collect</h3><p><code>collect</code>方法用于收集流中的元素，并放到不同类型的结果中，比如<code>List</code>、<code>Set</code>或者<code>Map</code>。举个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">List&lt;String&gt; filterList = list.stream()</div><div class="line">        .filter(s -&gt; s.startsWith(<span class="string">"J"</span>)).collect(Collectors.toList());</div></pre></td></tr></table></figure><p></p><p>如果需要以<code>Set</code>来替代<code>List</code>，只需要使用<code>Collectors.toSet()</code>就好了。</p><h2 id="流的构建"><a href="#流的构建" class="headerlink" title="流的构建"></a>流的构建</h2><p>除了使用集合对象的<code>stream</code>方法构建流之外，我们可以手动构建一些流。</p><h3 id="数值范围构建"><a href="#数值范围构建" class="headerlink" title="数值范围构建"></a>数值范围构建</h3><p><code>IntStream</code>和<code>LongStream</code>对象支持<code>range</code>和<code>rangeClosed</code>方法来构建数值流。这两个方法都是第一个参数接受起始值，第二个参数接受结束值。但range是不包含结束值的，而rangeClosed则包含结束值。比如对1到100的整数求和：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">IntStream.rangeClosed(<span class="number">1</span>, <span class="number">100</span>).sum(); <span class="comment">// 5050</span></div></pre></td></tr></table></figure><p></p><h3 id="由值构建"><a href="#由值构建" class="headerlink" title="由值构建"></a>由值构建</h3><p>静态方法<code>Stream.of</code>可以显式值创建一个流。它可以接受任意数量的参数。例如，以下代码直接使用<code>Stream.of</code>创建了一个字符串流:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Stream&lt;String&gt; s = Stream.of(<span class="string">"Java"</span>, <span class="string">"JavaScript"</span>, <span class="string">"C++"</span>, <span class="string">"Ruby"</span>);</div></pre></td></tr></table></figure><p></p><p>也可以使用<code>Stream.empty()</code>构建一个空流：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Stream&lt;Object&gt; emptyStream = Stream.empty();</div></pre></td></tr></table></figure><p></p><h3 id="由数组构建"><a href="#由数组构建" class="headerlink" title="由数组构建"></a>由数组构建</h3><p>静态方法<code>Arrays.stream</code>可以通过数组创建一个流。它接受一个数组作为参数。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span>[] arr = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</div><div class="line">IntStream intStream = Arrays.stream(arr);</div></pre></td></tr></table></figure><p></p><h3 id="由文件生成流"><a href="#由文件生成流" class="headerlink" title="由文件生成流"></a>由文件生成流</h3><p><code>java.nio.file.Files</code>中的很多静态方法都会返回一个流。例如<code>Files.lines</code>方法会返回一个由指定文件中的各行构成的字符串流。比如统计一个文件中共有多少个字：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">long</span> wordCout = <span class="number">0L</span>;</div><div class="line"><span class="keyword">try</span> (Stream&lt;String&gt; lines = Files.lines(Paths.get(<span class="string">"file.txt"</span>), Charset.defaultCharset())) &#123;</div><div class="line">    wordCout = lines.map(l -&gt; l.split(<span class="string">""</span>))</div><div class="line">                    .flatMap(Arrays::stream)</div><div class="line">                    .count();</div><div class="line">&#125; <span class="keyword">catch</span> (Exception ignore) &#123;&#125;</div></pre></td></tr></table></figure><p></p><h3 id="由函数构造"><a href="#由函数构造" class="headerlink" title="由函数构造"></a>由函数构造</h3><p>Stream API提供了两个静态方法来从函数生成流：<code>Stream.iterate</code>和<code>Stream.generate</code>。这两个操作可以创建所谓的无限流。比如下面的例子构建了10个偶数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Stream.iterate(<span class="number">0</span>, n -&gt; n + <span class="number">2</span>)</div><div class="line">      .limit(<span class="number">10</span>).forEach(System.out::println);</div></pre></td></tr></table></figure><p></p><p><code>iterate方</code>法接受一个初始值（在这里是0），还有一个依次应用在每个产生的新值上的Lambda（UnaryOperator<t>类型）。这里，我们使用Lambda <code>n -&gt; n + 2</code>，返回的是前一个元 素加上2。因此，<code>iterate</code>方法生成了一个所有正偶数的流：流的第一个元素是初始值0。然后加上2来生成新的值2，再加上2来得到新的值4，以此类推。</t></p><p>与<code>iterate</code>方法类似，<code>generate</code>方法也可让你按需生成一个无限流。但<code>generate</code>不是依次对每个新生成的值应用函数，比如下面的例子生成了5个0到1之间的随机双精度数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Stream.generate(Math::random)</div><div class="line">      .limit(<span class="number">5</span>)</div><div class="line">      .forEach(System.out::println);</div></pre></td></tr></table></figure><p></p><p>输出结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">0.6334646850587863</div><div class="line">0.4190147641834009</div><div class="line">0.4361968394515475</div><div class="line">0.6911796456838655</div><div class="line">0.08156838267267075</div></pre></td></tr></table></figure><p></p><blockquote><p><a href="https://book.douban.com/subject/26772632/" target="_blank" rel="external">《Java 8实战》</a>读书笔记</p></blockquote><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Tue Aug 21 2018 16:24:26 GMT+0800 (中国标准时间) --&gt;&lt;p&gt;Java 8 中的 Stream 俗称为流，它与 java.io 包里的 InputStream 和 OutputStream 是完全不同的概念。Stream 用于对集合对象进行各种非常便利、高效的聚合操作，或者大批量数据操作。Stream API 借助于Lambda 表达式，极大的提高编程效率和程序可读性。同时它提供串行和并行两种模式进行汇聚操作，并发模式能够充分利用多核处理器的优势。通过下面的例子我们可以初步体会到使用 Stream 处理集合的便利性。
    
    </summary>
    
    
      <category term="Java" scheme="http://mrbird.cc/tags/Java/"/>
    
      <category term="Java 8" scheme="http://mrbird.cc/tags/Java-8/"/>
    
  </entry>
  
  <entry>
    <title>RHEL离线安装Ruby和RubyGems</title>
    <link href="http://mrbird.cc/RHELinstallRuby&amp;RubyGems.html"/>
    <id>http://mrbird.cc/RHELinstallRuby&amp;RubyGems.html</id>
    <published>2018-04-11T09:15:06.000Z</published>
    <updated>2018-06-21T01:04:09.194Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Tue Aug 21 2018 16:24:25 GMT+0800 (中国标准时间) --><p>搭建Redis集群过程中需要安装Ruby环境，这里记录下在RHEL下离线安装Ruby和RubyGems的方法。Ruby的在线下载地址为<a href="https://www.ruby-lang.org/en/downloads/" target="_blank" rel="external">https://www.ruby-lang.org/en/downloads/</a>，下载好后上传到<code>/usr/loacl</code>目录下。如果之前已经安装过低版本的Ruby的话可以先使用下面的命令卸载:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo yum remove ruby ruby-devel</div></pre></td></tr></table></figure><p></p><a id="more"></a><p>这里我们下载的Ruby版本为2.5.1，解压ruby-2.5.1.tar.gz：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">tar -zxvf ruby-2.5.1.tar.gz</div></pre></td></tr></table></figure><p></p><p>接着使用以下命令安装：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">cd</span> /usr/<span class="built_in">local</span>/ruby-2.5.1</div><div class="line">./configure</div><div class="line">make</div><div class="line">sudo make install</div></pre></td></tr></table></figure><p></p><p>安装好后查看Ruby的版本：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ruby -v</div></pre></td></tr></table></figure><p></p><p>如果提示<span style="color:red">-bash: /usr/local/bin/ruby: 没有那个文件或目录</span>的话，可以将Ruby目录下的ruby文件拷贝到<code>/usr/local/bin</code>目录下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">cp /usr/<span class="built_in">local</span>/ruby-2.5.1/ruby /usr/<span class="built_in">local</span>/bin/</div><div class="line">ruby -v</div><div class="line">ruby 2.5.1p57 (2018-03-29 revision 63029) [x86_64-linux]</div></pre></td></tr></table></figure><p></p><p>安装好Ruby后，我们接着安装RubyGems。</p><p>RubyGems是Ruby的一个包管理器，它提供一个分发Ruby程序和库的标准格式，还提供一个管理程序包安装的工具。RubyGems旨在方便地管理gem安装的工具，以及用于分发gem的服务器。这类似于Ubuntu下的apt-get，Centos 的yum，Python的pip。</p><p>RubyGems的下载地址为：<a href="https://rubygems.org/pages/download" target="_blank" rel="external">https://rubygems.org/pages/download</a>，这里我们下载的版本为2.7.7。下载好后，上传到<code>/usr/local</code>目录下，然后解压：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">tar -zxvf rubygems-2.7.7.tgz</div></pre></td></tr></table></figure><p></p><p>接着切换到解压后的目录，执行以下命令安装：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ruby setup.rb</div></pre></td></tr></table></figure><p></p><p>安装好后，查看RubyGems版本：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">gem -v</div><div class="line">2.7.7</div></pre></td></tr></table></figure><p></p><p>安装结束。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Tue Aug 21 2018 16:24:25 GMT+0800 (中国标准时间) --&gt;&lt;p&gt;搭建Redis集群过程中需要安装Ruby环境，这里记录下在RHEL下离线安装Ruby和RubyGems的方法。Ruby的在线下载地址为&lt;a href=&quot;https://www.ruby-lang.org/en/downloads/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://www.ruby-lang.org/en/downloads/&lt;/a&gt;，下载好后上传到&lt;code&gt;/usr/loacl&lt;/code&gt;目录下。如果之前已经安装过低版本的Ruby的话可以先使用下面的命令卸载:&lt;/p&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;sudo yum remove ruby ruby-devel&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="http://mrbird.cc/tags/Linux/"/>
    
      <category term="Ruby" scheme="http://mrbird.cc/tags/Ruby/"/>
    
  </entry>
  
  <entry>
    <title>Linux下搭建Redis集群</title>
    <link href="http://mrbird.cc/linux-redis-cluster.html"/>
    <id>http://mrbird.cc/linux-redis-cluster.html</id>
    <published>2018-04-10T05:51:46.000Z</published>
    <updated>2018-06-14T02:55:12.054Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Tue Aug 21 2018 16:24:26 GMT+0800 (中国标准时间) --><p>通过Redis的集群，我们可以实现多个Redis节点之间的数据共享，并且支持自动分割数据到不同的节点上。在集群过程中通过主从的分配可以提高Redis的可用性，不会因为某个节点宕掉或者不可达而导致整个集群网络的不可用。Redis 3.0版本后支持使用Redis-Cluster来搭建集群，本文将介绍在Ubuntu 16.04下从零开始搭建Redis集群。因为Redis集群中至少应该有奇数个主节点，所以本文将创建6个Redis节点，其中3个为主节点，3个为从属节点，用于从主节点拉取数据进行备份。<a id="more"></a></p><h2 id="安装Redis"><a href="#安装Redis" class="headerlink" title="安装Redis"></a>安装Redis</h2><p>从<a href="https://redis.io/download" target="_blank" rel="external">https://redis.io/download</a>上获取最新的Stable版本Redis，下载到/usr/local/目录下并解压：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">wget http://download.redis.io/releases/redis-4.0.9.tar.gz</div><div class="line">tar -zxvf redis-4.0.9.tar.gz</div></pre></td></tr></table></figure><p></p><p>进行编译和安装：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">cd</span> redis-4.0.9/</div><div class="line">make &amp;&amp; make install</div></pre></td></tr></table></figure><p></p><p>安装成功后开始进行集群搭建。</p><h2 id="搭建集群"><a href="#搭建集群" class="headerlink" title="搭建集群"></a>搭建集群</h2><p>编译安装后，在Reids的src目录下有个redis-trib.rb文件，将其复制到/usr/local/bin/目录下，方便后期搭建集群使用： <img src="img/QQ截图20180613193219.png" alt="QQ截图20180613192953.png"></p><p>接下来开始创建节点。在redis目录下创建一个cluster目录：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mkdir cluster</div></pre></td></tr></table></figure><p></p><p>然后在该目录下创建六个目录，分别命名为7000、7001、7002、7003、7004和7005：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">cd cluster/</div><div class="line">mkdir 7000 7001 7002 7003 7004 7005</div></pre></td></tr></table></figure><p></p><p>在7000目录下创建一个Redis配置文件redis.conf，内容如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">port 7000</div><div class="line"><span class="built_in">bind</span> 172.16.0.4</div><div class="line">daemonize yes</div><div class="line">pidfile /var/run/redis_7000.pid</div><div class="line">cluster-enabled yes</div><div class="line">cluster-config-file nodes_7000.conf</div><div class="line">cluster-node-timeout 15000</div><div class="line">appendonly yes</div></pre></td></tr></table></figure><p></p><p>上述配置是开启Redis集群的最简配置，各项配置的含义如下：</p><ul><li><p>port 7000：Redis节点的端口号为7000；</p></li><li><p>bind 172.16.0.4：绑定本机的IP地址；</p></li><li><p>daemonize yes：以后台服务的形式开启Redis；</p></li><li><p>pidfile /var/run/redis_7000.pid：以该配置启动Redis后将在/var/run/目录下创建一个redis_port.pid文件；</p></li><li><p>cluster-enabled yes：是否开启集群，yes；</p></li><li><p>cluster-config-file nodes_7000.conf：集群配置文件，启动后自动生成，文件名称为nodes_7000.conf。该文件将保持集群配置信息，以保证重启该Redis节点后能够保持集群状态；</p></li><li><p>cluster-node-timeout 15000：请求超时时间，默认为15秒；</p></li><li><p>appendonly yes：是否开启aof日志，开启后每次写操作都记录一条日志。</p></li></ul><p>剩下的7001~7005的配置文件除了端口号改为相应的外，其他配置保持一致。配置好7000~7005端口的Redis配置文件后，启动这些节点：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">redis-server cluster/7000/redis.conf</div><div class="line">redis-server cluster/7001/redis.conf</div><div class="line">redis-server cluster/7002/redis.conf</div><div class="line">redis-server cluster/7003/redis.conf</div><div class="line">redis-server cluster/7004/redis.conf</div><div class="line">redis-server cluster/7005/redis.conf</div></pre></td></tr></table></figure><p></p><p>查看是否启动成功：</p><p><img src="img/QQ截图20180613162915.png" alt="QQ截图20180613162915.png"></p><p>现在我们已经有了6个正在运行中的Redis实例，接下来我们需要使用这些实例来创建集群。接着使用redis-trib.rb创建集群，该文件使用ruby编写，所以使用redis-trib.rb之前得先安装ruby：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">apt-get install ruby</div><div class="line">gem install redis</div></pre></td></tr></table></figure><p></p><p>安装好ruby后，输入以下命令开启集群：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">redis-trib.rb create --replicas 1 172.16.0.4:7000 172.16.0.4:7001 172.16.0.4:7002 172.16.0.4:7003 172.16.0.4:7004 172.16.0.4:7005</div></pre></td></tr></table></figure><p></p><p>选项<code>--replicas 1</code>表示我们希望为集群中的每个主节点创建一个从节点，之后跟着的其他参数则是这个集群实例的地址列表：3个主节点（Master，即7000~7002）3个从节点（Slave，即7003~7005）。输入该命令后，终端打印出如下配置：</p><p><img src="img/QQ截图20180613164244.png" alt="QQ截图20180613164244.png"></p><p>其中M开头的节点为主节点，S开头的为从节点。从从节点的replicates（复制的意思）信息可以看出7000的从节点为7004，7001的从节点为7005，7002的从节点为7003。确认无误后输入yes点击回车继续：</p><p><img src="img/QQ截图20180613194006.png" alt="QQ截图20180613165049.png"></p><p>可看到7000节点的拥有5461个哈希槽（<strong>0 - 6460 slots</strong>），7001节点拥有5462个哈希槽（<strong>5461 - 10922 slots</strong>），7002节点拥有5461个哈希槽（<strong>10923 - 16383 slots</strong>），而从属节点并没有分配哈希槽。</p><p>从最后一行的输出信息可以看出，Redis集群总共有<strong>16384</strong>个哈希槽（slots）。</p><p>此外，那些一大串的字符称为节点ID。</p><h2 id="集群测试"><a href="#集群测试" class="headerlink" title="集群测试"></a>集群测试</h2><p>通过上面的集群配置，这6个Redis节点之间的关系可以用下图表示：</p><p><img src="img/微信截图_20180613195940.png" alt="微信截图_20180613195940.png"></p><p>颜色深的节点为颜色浅的节点的主节点，所有节点彼此之间互联（ping-pong）。下面对这些集群节点进行一些测试。</p><h3 id="测试存取"><a href="#测试存取" class="headerlink" title="测试存取"></a>测试存取</h3><p>使用客户端连接集群后的Redis节点需要带上<code>-c</code>标识，比如现在我们连接端口为7003的从节点：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">redis-cli -h 172.16.0.4 -c -p 7003</div></pre></td></tr></table></figure><p></p><p>使用set命令往Redis存入一些key-vaue，结果如下图所示：</p><p><img src="img/QQ截图20180613200759.png" alt="QQ截图20180613170145.png"></p><p>可发现，存值的操作并不是在7003节点完成的，存值的过程只在主节点下完成，并且每次set操作Redis都会输出<code>Redirected to slot [xxxx] located at</code>的提示。Redis集群有16384个哈希槽，每次set key时，Redis内部通过CRC16校验后对16384取模来决定放置哪个哈希槽。正如上面所说的，集群的每个主节点负责一部分哈希槽。</p><p>比如第一条命令<code>set a 1</code>计算出来的哈希码为15495，介于11001到16384之间，所以便存储在了7002节点中。</p><p>上面我们提到7000节点的从节点为7004，下面来验证一下：</p><p><img src="img/QQ截图20180613202509.png" alt="QQ截图20180613172042.png"></p><p>可看到它们存储的key是相同的。尝试从7004节点删除key：</p><p><img src="img/QQ截图20180613202845.png" alt="QQ截图20180613202845.png"></p><p>发现7000节点的b也被删除。</p><p>接下来从7000节点获取a的值（a存储在7002节点中）：</p><p><img src="img/QQ截图20180613203106.png" alt="QQ截图20180613203106.png"></p><p>可看到Redis自己redirected到了7002节点获取a的值，这就是集群的特点，每个节点都是平等的，可以相互间取值。</p><h3 id="测试主从"><a href="#测试主从" class="headerlink" title="测试主从"></a>测试主从</h3><p>开头说过，在集群过程中可以通过主从的分配来提高Redis的可用性。比如这个例子，集群有7000、7001和7002 3个主节点，如果这3个节点都没有从节点，假设7001宕机了，那么整个集群就会因为缺少5501-11000这个范围的哈希槽而变得不可用。</p><p>所以我们在集群建立的时候，一定要为每个主节点都添加了从节点, 比如像上面的例子那样，集群包含主节点7000、7001和7002以及从节点7003、7004和7005, 那么即使7001宕系统也可以继续正常工作。</p><p>当7001这个主节点宕机后，Redis集群将会选择7001的从节点7005作为新的主节点以确保集群正常的工作。当重新启动7001后，其自动变为了7005的从节点，角色完成了转换。</p><p>为了验证这个理论，下面将7001节点杀死，然后观察：</p><p><img src="img/QQ截图20180613204834.png" alt="QQ截图20180613204834.png"></p><p>可看到7005已经晋升为了主节点。接着测试从7000节点获取c的值（c存储在7001节点中，7005之前为7001的从节点，所以也存有这个值）：</p><p><img src="img/QQ截图20180613205137.png" alt="QQ截图20180613205137.png"></p><p>Redis自动redirected到了7005，并成功获取到了c的值。</p><p>现在重新启动7001节点，然后观察：</p><p><img src="img/QQ截图20180613205426.png" alt="QQ截图20180613205426.png"></p><p>7001已经成为了7005的从节点了。</p><div class="note danger"><p>值得注意的是，假如7005和7001同时宕机，那么集群将不可用。</p></div><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Tue Aug 21 2018 16:24:26 GMT+0800 (中国标准时间) --&gt;&lt;p&gt;通过Redis的集群，我们可以实现多个Redis节点之间的数据共享，并且支持自动分割数据到不同的节点上。在集群过程中通过主从的分配可以提高Redis的可用性，不会因为某个节点宕掉或者不可达而导致整个集群网络的不可用。Redis 3.0版本后支持使用Redis-Cluster来搭建集群，本文将介绍在Ubuntu 16.04下从零开始搭建Redis集群。因为Redis集群中至少应该有奇数个主节点，所以本文将创建6个Redis节点，其中3个为主节点，3个为从属节点，用于从主节点拉取数据进行备份。
    
    </summary>
    
    
      <category term="Linux" scheme="http://mrbird.cc/tags/Linux/"/>
    
      <category term="Redis" scheme="http://mrbird.cc/tags/Redis/"/>
    
      <category term="集群" scheme="http://mrbird.cc/tags/%E9%9B%86%E7%BE%A4/"/>
    
  </entry>
  
  <entry>
    <title>【Java8实战】Lambda表达式（二）</title>
    <link href="http://mrbird.cc/java8lambda2.html"/>
    <id>http://mrbird.cc/java8lambda2.html</id>
    <published>2018-04-08T03:02:40.000Z</published>
    <updated>2018-06-12T00:52:16.544Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Tue Aug 21 2018 16:24:26 GMT+0800 (中国标准时间) --><p>在上一节中，我们为了使用Lambda表达式不得不创建了各种函数描述符的函数式接口，其实Java 8已经给我们提供了一套能够描述常见函数描述符的函数式接口。比如<code>Predicate&lt;T&gt;</code>、<code>Consumer&lt;T&gt;</code>、<code>Function&lt;T,R&gt;</code>、<code>Supplier&lt;T&gt;</code>等，这些函数式接口位于<code>java.util.function</code>包。这一节主要记录这些函数式接口的应用。<a id="more"></a></p><h2 id="Java8中的函数式接口"><a href="#Java8中的函数式接口" class="headerlink" title="Java8中的函数式接口"></a>Java8中的函数式接口</h2><p>下表列出了Java8中常见的函数式接口：</p><table><tr><th>函数式接口</th><th>函数描述符</th><th>原始类型特化</th></tr><tr><td>Predicate<t></t></td><td>T-&gt;boolean</td><td>IntPredicate,LongPredicate, DoublePredicate</td></tr><tr><td>Consumer<t></t></td><td>T-&gt;void</td><td>IntConsumer,LongConsumer, DoubleConsumer</td></tr><tr><td>Function<t ,r=""></t></td><td>T-&gt;R</td><td>IntFunction<r>, IntToDoubleFunction, IntToLongFunction,<br>LongFunction<r>, LongToDoubleFunction, LongToIntFunction,<br>DoubleFunction<r>, ToIntFunction<t>, ToDoubleFunction<t>, ToLongFunction<t></t></t></t></r></r></r></td></tr><tr><td>Supplier<t></t></td><td>()-&gt;T</td><td>BooleanSupplier,IntSupplier, LongSupplier,<br>DoubleSupplier</td></tr><tr><td>UnaryOperator<t></t></td><td>T-&gt;T</td><td>IntUnaryOperator, LongUnaryOperator, DoubleUnaryOperator</td></tr><tr><td>BinaryOperator<t></t></td><td>(T,T)-&gt;T</td><td>IntBinaryOperator, LongBinaryOperator, DoubleBinaryOperator</td></tr><tr><td>BiPredicate<l ,r=""></l></td><td>(L,R)-&gt;boolean</td><td></td></tr><tr><td>BiConsumer<t ,u=""></t></td><td>(T,U)-&gt;void</td><td>ObjIntConsumer<t>, ObjLongConsumer<t>, ObjDoubleConsumer<t></t></t></t></td></tr><tr><td>BiFunction<t ,u,r=""></t></td><td>(T,U)-&gt;R</td><td>ToIntBiFunction<t ,u="">, ToLongBiFunction<t ,u="">, ToDoubleBiFunction<t ,u=""></t></t></t></td></tr></table><h3 id="Predicate"><a href="#Predicate" class="headerlink" title="Predicate"></a>Predicate</h3><p>predicate: 英 [ˈpredɪkət] 美 [ˈpredɪkət] 断言，断定的意思。从接口的名称就可以推断出这个函数式接口的主要作用就是用于判断作用，Predicate源码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@FunctionalInterface</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Predicate</span>&lt;<span class="title">T</span>&gt; </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">test</span><span class="params">(T t)</span></span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">default</span> Predicate&lt;T&gt; <span class="title">and</span><span class="params">(Predicate&lt;? <span class="keyword">super</span> T&gt; other)</span> </span>&#123;</div><div class="line">        Objects.requireNonNull(other);</div><div class="line">        <span class="keyword">return</span> (t) -&gt; test(t) &amp;&amp; other.test(t);</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">default</span> Predicate&lt;T&gt; <span class="title">negate</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> (t) -&gt; !test(t);</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">default</span> Predicate&lt;T&gt; <span class="title">or</span><span class="params">(Predicate&lt;? <span class="keyword">super</span> T&gt; other)</span> </span>&#123;</div><div class="line">        Objects.requireNonNull(other);</div><div class="line">        <span class="keyword">return</span> (t) -&gt; test(t) || other.test(t);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">static</span> &lt;T&gt; <span class="function">Predicate&lt;T&gt; <span class="title">isEqual</span><span class="params">(Object targetRef)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> (<span class="keyword">null</span> == targetRef)</div><div class="line">                ? Objects::isNull</div><div class="line">                : object -&gt; targetRef.equals(object);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p></p><p>可看到<code>java.util.function.Predicate&lt;T&gt;</code>接口定义了一个名叫<code>test</code>的抽象方法，它接受泛型<code>T</code>对象，并返回一个<code>boolean</code>，函数描述符为<code>(T) -&gt; boolean</code>举几个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 偶数判断</span></div><div class="line">Predicate&lt;Integer&gt; isEven = (in) -&gt; in % <span class="number">2</span> == <span class="number">0</span>;</div><div class="line">isEven.test(<span class="number">17</span>); <span class="comment">// false</span></div><div class="line"></div><div class="line"><span class="comment">// 判断字符串的长度是否为0</span></div><div class="line">Predicate&lt;String&gt; isEmptyString = String::isEmpty;</div><div class="line">isEmptyString.test(<span class="string">""</span>); <span class="comment">// true</span></div></pre></td></tr></table></figure><p></p><p>除了抽象方法外，<code>java.util.function.Predicate&lt;T&gt;</code>接口还定义了三个默认方法：<code>and</code>，<code>negate</code>和<code>or</code>，对应“与”，“非”和“或”操作，这样我们便可以复合Lambda表达式了，比如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 判断是偶数，并且大于30</span></div><div class="line">Predicate&lt;Integer&gt; isEven = (in) -&gt; in % <span class="number">2</span> == <span class="number">0</span>;</div><div class="line">isEven.and((in) -&gt; in &gt; <span class="number">30</span>).test(<span class="number">40</span>); <span class="comment">// true</span></div><div class="line"></div><div class="line"><span class="comment">// 奇数判断</span></div><div class="line">Predicate&lt;Integer&gt; isEven = (in) -&gt; in % <span class="number">2</span> == <span class="number">0</span>;</div><div class="line">Predicate&lt;Integer&gt; isOdd = isEven.negate();</div><div class="line">isOdd.test(<span class="number">17</span>); <span class="comment">// true</span></div></pre></td></tr></table></figure><p></p><h3 id="Consumer"><a href="#Consumer" class="headerlink" title="Consumer"></a>Consumer</h3><p>英 [kənˈsju:mə(r)] 美 [kənˈsu:mə(r)] n.消费者。该函数式接口用于消费一个对象，即接收一个对象，对其执行某些操作，然后没有返回值。Consumer源码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@FunctionalInterface</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Consumer</span>&lt;<span class="title">T</span>&gt; </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">accept</span><span class="params">(T t)</span></span>;</div><div class="line">    <span class="function"><span class="keyword">default</span> Consumer&lt;T&gt; <span class="title">andThen</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> T&gt; after)</span> </span>&#123;</div><div class="line">        Objects.requireNonNull(after);</div><div class="line">        <span class="keyword">return</span> (T t) -&gt; &#123; accept(t); after.accept(t); &#125;;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p></p><p>可看到<code>java.util.function.Consumer&lt;T&gt;</code>定义了一个名叫<code>accept</code>的抽象方法，它接受泛型<code>T</code>的对象，没有返回(<code>void</code>)，函数描述符为<code>(T) -&gt; void</code>。其还提供了一个默认方法<code>andThen</code>。举个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Consumer&lt;Apple&gt; printAppleColor = (a)-&gt; System.out.println(a.getColor());</div><div class="line">printAppleColor.accept(<span class="keyword">new</span> Apple(<span class="string">"red"</span>,<span class="number">17</span>)); <span class="comment">// red</span></div><div class="line"></div><div class="line">printAppleColor.andThen((a) -&gt; System.out.println(a.getWeight())).accept(<span class="keyword">new</span> Apple(<span class="string">"red"</span>, <span class="number">17</span>)); <span class="comment">// red 17.0</span></div></pre></td></tr></table></figure><p></p><h3 id="Supplier"><a href="#Supplier" class="headerlink" title="Supplier"></a>Supplier</h3><p>supplier 英 [səˈplaɪə(r)] 美 [səˈplaɪər] n.供应商;供应者;供给者。其源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@FunctionalInterface</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Supplier</span>&lt;<span class="title">T</span>&gt; </span>&#123;</div><div class="line">    <span class="function">T <span class="title">get</span><span class="params">()</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p></p><p>可看到<code>java.util.function.Supplier&lt;T&gt;</code>定义了一个名叫<code>get</code>的抽象方法，它不接收参数，返回泛型<code>T</code>的对象，函数描述符为<code>() -&gt; T</code>。举个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Supplier&lt;Person&gt; personSupplier = Person::<span class="keyword">new</span>;</div><div class="line">personSupplier.get();   <span class="comment">// new Person</span></div></pre></td></tr></table></figure><p></p><h3 id="Functions"><a href="#Functions" class="headerlink" title="Functions"></a>Functions</h3><p>Functions源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@FunctionalInterface</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Function</span>&lt;<span class="title">T</span>, <span class="title">R</span>&gt; </span>&#123;</div><div class="line">    <span class="function">R <span class="title">apply</span><span class="params">(T t)</span></span>;</div><div class="line"></div><div class="line">    <span class="keyword">default</span> &lt;V&gt; <span class="function">Function&lt;V, R&gt; <span class="title">compose</span><span class="params">(Function&lt;? <span class="keyword">super</span> V, ? extends T&gt; before)</span> </span>&#123;</div><div class="line">        Objects.requireNonNull(before);</div><div class="line">        <span class="keyword">return</span> (V v) -&gt; apply(before.apply(v));</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">default</span> &lt;V&gt; <span class="function">Function&lt;T, V&gt; <span class="title">andThen</span><span class="params">(Function&lt;? <span class="keyword">super</span> R, ? extends V&gt; after)</span> </span>&#123;</div><div class="line">        Objects.requireNonNull(after);</div><div class="line">        <span class="keyword">return</span> (T t) -&gt; after.apply(apply(t));</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">static</span> &lt;T&gt; <span class="function">Function&lt;T, T&gt; <span class="title">identity</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> t -&gt; t;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p></p><p><code>java.util.function.Function&lt;T, R&gt;</code>接口定义了一个叫作<code>apply</code>的方法，它接受一个泛型<code>T</code>的对象，并返回一个泛型<code>R</code>的对象，函数描述符为<code>(T) -&gt; R</code>。举个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Function&lt;Apple, Double&gt; getAppleWeight = (a) -&gt; &#123;</div><div class="line">    <span class="keyword">return</span> a.getWeight();</div><div class="line">&#125;;</div><div class="line">getAppleWeight.apply(<span class="keyword">new</span> Apple(<span class="number">17</span>)); <span class="comment">// 17.0</span></div></pre></td></tr></table></figure><p></p><p>Functions接口还提供了两个抽象方法<code>compose</code>和<code>andThen</code>，从源码可以看出两者的根本区别。举个<code>compose</code>例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Function&lt;Integer, Integer&gt; f = (x) -&gt; x + <span class="number">1</span>;</div><div class="line">Function&lt;Integer, Integer&gt; g = (x) -&gt; x * <span class="number">2</span>;</div><div class="line">f.compose(g).apply(<span class="number">2</span>); <span class="comment">// 5</span></div></pre></td></tr></table></figure><p></p><p>过程为：<code>f(g(2))</code>，也就是<code>1+(2*2)</code>。</p><p>举个andThen的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Function&lt;Integer, Integer&gt; f = (x) -&gt; x + <span class="number">1</span>;</div><div class="line">Function&lt;Integer, Integer&gt; g = (x) -&gt; x * <span class="number">2</span>;</div><div class="line">f.andThen(g).apply(<span class="number">2</span>); <span class="comment">// 6</span></div></pre></td></tr></table></figure><p></p><p>过程为：<code>g(f(2))</code>，也就是<code>(2+1)*2</code>。</p><h3 id="原始类型特化"><a href="#原始类型特化" class="headerlink" title="原始类型特化"></a>原始类型特化</h3><p>在学习Function接口的时候，我们定义了<code>f</code>函数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Function&lt;Integer, Integer&gt; f = (x) -&gt; x + <span class="number">1</span>;</div></pre></td></tr></table></figure><p></p><p>x的类型为Integer类型，1为int类型，返回值为Integer类型，整个过程实际上为<code>Integer.valueOf(x.intValue() + 1)</code>。虽然编译器可以自动帮我们完成拆装箱，但这会造成不必要的性能消耗。考虑到了这一点，Java8为我们提供了int类型的Function接口：IntFunction:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@FunctionalInterface</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IntFunction</span>&lt;<span class="title">R</span>&gt; </span>&#123;</div><div class="line">    <span class="function">R <span class="title">apply</span><span class="params">(<span class="keyword">int</span> value)</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p></p><p>所以<code>f</code>最好重构为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">IntFunction&lt;Integer&gt; f = (x) -&gt; x + <span class="number">1</span>;</div></pre></td></tr></table></figure><p></p><p>剩余的原始类型特化函数式接口可参考上面的表格。</p><h2 id="Java8中增强的Comparator"><a href="#Java8中增强的Comparator" class="headerlink" title="Java8中增强的Comparator"></a>Java8中增强的Comparator</h2><p>在Java8之前，Comparator接口用于实现简单的比较排序算法。比如有如下List：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">List&lt;Double&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">list.add(<span class="number">12.3</span>);</div><div class="line">list.add(<span class="number">100.2</span>);</div><div class="line">list.add(<span class="number">3.14</span>);</div><div class="line">list.add(<span class="number">27.7</span>);</div><div class="line">list.add(-<span class="number">9.8</span>);</div></pre></td></tr></table></figure><p></p><p>使用Comparator接口对其从小到大排序：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Collections.sort(list, <span class="keyword">new</span> Comparator&lt;Double&gt;() &#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Double o1, Double o2)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> o1.compareTo(o2);</div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure><p></p><p>Comparator接口也是一个函数式接口，函数描述符为<code>(T,T) -&gt; int</code>，Java8中可以使用Lambda改造上面的排序方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Collections.sort(list, (o1, o2) -&gt; o1.compareTo(o2));</div></pre></td></tr></table></figure><p></p><p>Java8对List提供了<code>sort</code>方法，可以替代<code>Collections.sort</code>，所以上面的代码可以简化为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">list.sort((o1, o2) -&gt; o1.compareTo(o2));</div></pre></td></tr></table></figure><p></p><p>使用方法的引用来进一步简化：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">list.sort(Double::compareTo);</div></pre></td></tr></table></figure><p></p><p>Java8对Comparator进行了增强，加入了一些实用的默认方法，比如对排序结果反转：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Comparator&lt;Double&gt; comparator = Double::compareTo;</div><div class="line">list.sort(comparator.reversed());</div></pre></td></tr></table></figure><p></p><p>更多方法可以参考Comparator接口的JavaDoc。</p><div class="note danger"><p>查看Comparator的时候发现其虽然是函数式接口，但是却包含了<code>compare</code>和<code>equals</code>这两个抽象方法，顿时有点懵逼，函数式接口不是只能有一个抽象方法么？查找资料后发现：函数式接口中可以额外定义多个抽象方法，但这些抽象方法签名必须和Object的public方法一样，接口最终有确定的类实现，而类的最终父类是Object。因此函数式接口可以定义Object的public方法。</p></div><p></p><blockquote><p><a href="https://book.douban.com/subject/26772632/" target="_blank" rel="external">《Java 8实战》</a>读书笔记</p></blockquote><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Tue Aug 21 2018 16:24:26 GMT+0800 (中国标准时间) --&gt;&lt;p&gt;在上一节中，我们为了使用Lambda表达式不得不创建了各种函数描述符的函数式接口，其实Java 8已经给我们提供了一套能够描述常见函数描述符的函数式接口。比如&lt;code&gt;Predicate&amp;lt;T&amp;gt;&lt;/code&gt;、&lt;code&gt;Consumer&amp;lt;T&amp;gt;&lt;/code&gt;、&lt;code&gt;Function&amp;lt;T,R&amp;gt;&lt;/code&gt;、&lt;code&gt;Supplier&amp;lt;T&amp;gt;&lt;/code&gt;等，这些函数式接口位于&lt;code&gt;java.util.function&lt;/code&gt;包。这一节主要记录这些函数式接口的应用。
    
    </summary>
    
    
      <category term="Java" scheme="http://mrbird.cc/tags/Java/"/>
    
      <category term="Java 8" scheme="http://mrbird.cc/tags/Java-8/"/>
    
  </entry>
  
  <entry>
    <title>【Java8实战】Lambda表达式（一）</title>
    <link href="http://mrbird.cc/java8lambda1.html"/>
    <id>http://mrbird.cc/java8lambda1.html</id>
    <published>2018-04-05T11:15:35.000Z</published>
    <updated>2018-06-08T03:23:18.705Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Tue Aug 21 2018 16:24:26 GMT+0800 (中国标准时间) --><p>Java 8的Lambda表达式借鉴了C#和Scala等语言中的类似特性，简化了匿名函数的表达方式。Lambda表达式可以直接以内联的形式为<strong>函数式接口</strong>的抽象方法提供实现，并把整个表达式作为函数式接口的实例。什么是函数式接口？简单来说就是只包含一个抽象方法的接口，允许有默认的实现（使用default关键字描述方法）。函数式接口建议使用<code>@FunctionalInterface</code>注解标注，虽然这不是必须的，但是这样做更符合规范。</p><a id="more"></a><p>在Java 8之前，实现Runnable常用方式是编写一个匿名类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">Thread thread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"hello"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;);</div><div class="line">thread.start();</div></pre></td></tr></table></figure><p></p><p>使用Lambda表达式后，上面的代码可以改造为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Thread thread = <span class="keyword">new</span> Thread(() -&gt; System.out.println(<span class="string">"hello"</span>));</div><div class="line">thread.start();</div></pre></td></tr></table></figure><p></p><p>是不是很神奇？！很简洁？！</p><h2 id="Lambda表达式解析"><a href="#Lambda表达式解析" class="headerlink" title="Lambda表达式解析"></a>Lambda表达式解析</h2><p>Lambda表达式的基本语法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">(parameters) -&gt; <span class="function">expression </span></div><div class="line"><span class="title">or</span></div><div class="line"><span class="params">(parameters)</span> -&gt; &#123; statements; &#125;</div></pre></td></tr></table></figure><p></p><p>由语法可以看到，Lambda表达式包含了三个部分：</p><ul><li><p>参数列表；</p></li><li><p>箭头<code>-&gt;</code>把参数列表与Lambda主体分隔开；</p></li><li><p>Lambda主体，只有一行代码的时候可以省略大括号和<code>return</code>关键字。</p></li></ul><p>比如下面这些Lambda表达式都是合法的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">(String str) -&gt; str.length()</div><div class="line">(String str) -&gt; &#123; <span class="keyword">return</span> str.length(); &#125;</div><div class="line"></div><div class="line">() -&gt; System.out.println(<span class="string">"hello"</span>)</div><div class="line"></div><div class="line">() -&gt; &#123;&#125;</div><div class="line">() -&gt; <span class="number">17</span></div><div class="line"></div><div class="line">(<span class="keyword">int</span> x, <span class="keyword">int</span> y) -&gt; &#123;</div><div class="line">    System.out.println(x);</div><div class="line">    System.out.println(y);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p></p><h2 id="Lambda的使用场合"><a href="#Lambda的使用场合" class="headerlink" title="Lambda的使用场合"></a>Lambda的使用场合</h2><p>什么时候可以使用Lambda表达式？使用Lambda必须满足以下两个条件：</p><ol><li><p>实现的对象是函数式接口的抽象方法；</p></li><li><p>函数式接口的抽象方法的函数描述符和Lambda表达式的函数描述符一致。</p></li></ol><h3 id="函数式接口"><a href="#函数式接口" class="headerlink" title="函数式接口"></a>函数式接口</h3><p>函数式接口的定义开头已经说了，这里就不再赘述。在Java 8之前，常见的函数式接口有<code>java.util.Comparator</code>，<code>java.lang.Runnable</code>等。拿<code>java.util.Runnable</code>来说，查看其源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@FunctionalInterface</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Runnable</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p></p><p>这个接口只有一个抽象方法，并且使用<code>@FunctionalInterface</code>注解标注。</p><p>接口现在还可以拥有默认方法（即在类没有对方法进行实现时，其主体为方法提供默认实现的方法）。哪怕有很多默认方法，只要接口只定义了一个抽象方法，它就仍然是一个函数式接口。</p><h3 id="函数描述符"><a href="#函数描述符" class="headerlink" title="函数描述符"></a>函数描述符</h3><p><strong>函数描述符</strong>其实也可以理解为方法的签名。比如上述的Runnable抽象方法不接受参数，并且返回void，所以其函数描述符为<code>() -&gt; void</code>。而<code>() -&gt; System.out.println(&quot;hello&quot;)</code>Lambda表达式也是不接受参数，并且返回void，即其函数描述符也是<code>() -&gt; void</code>。所以代码<code>Runnable r = () -&gt; System.out.println(&quot;hello&quot;);</code>是合法的。</p><div class="note danger"><p><strong>特殊的void兼容规则</strong></p><p>如果一个Lambda的主体是一个语句表达式， 它就和一个返回void的函数描述符兼容（当然需要参数列表也兼容）。例如，以下Lambda是合法的，尽管List的add方法返回了一个 boolean，而不是Runnable抽象方法函数描述符<code>() -&gt; void</code>所要求的void：</p></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">List&lt;String&gt; list = new ArrayList&lt;&gt;();</div><div class="line">Runnable r = () -&gt; list.add(&quot;hello&quot;);</div></pre></td></tr></table></figure><h2 id="更简洁的Lambda"><a href="#更简洁的Lambda" class="headerlink" title="更简洁的Lambda"></a>更简洁的Lambda</h2><p>编写一个类型转换的函数式接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@FunctionalInterface</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">TransForm</span>&lt;<span class="title">T</span>, <span class="title">R</span>&gt; </span>&#123;</div><div class="line">    <span class="function">R <span class="title">transForm</span><span class="params">(T t)</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p></p><p>编写一个Lambda表达式实现该函数式接口，用于实现String转换为Integer，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">TransForm&lt;String, Integer&gt; t = (String str) -&gt; Integer.valueOf(str);</div><div class="line">System.out.println(t.transForm(<span class="string">"123"</span>));</div></pre></td></tr></table></figure><p></p><p>上面的Lambda表达式可以进一步简化为如下方式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">TransForm&lt;String, Integer&gt; t = (str) -&gt; Integer.valueOf(str);</div><div class="line">System.out.println(t.transForm(<span class="string">"123"</span>));</div></pre></td></tr></table></figure><p></p><p>因为Java编译器会从上下文（目标类型）推断出用什么函数式接口来配合Lambda表达式，这意味着它也可以推断出适合Lambda的签名。就拿这个例子来说，TransForm的抽象方法transForm在本例中的函数描述符为<code>(String) -&gt; Integer</code>，所以对应的Lambda的签名也是如此，即Lambda的参数即使不声名类型，Java编译器可以知道其参数实际上为String类型。</p><p>其实，上面的Labmda表达式还不是最简洁的，其还可以更进一步地简化为如下写法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">TransForm&lt;String, Integer&gt; t = Integer::valueOf;</div><div class="line">System.out.println(t.transForm(<span class="string">"123"</span>));</div></pre></td></tr></table></figure><p></p><p>你肯定很困惑，这还是Lambda表达式吗，箭头去哪里了？双冒号又是什么鬼？其实这种写法有一个新的名称，叫做<strong>方法的引用</strong>。</p><p>方法引用可以被看作仅仅调用特定方法的Lambda的一种快捷写法。它的基本思想是，如果一个Lambda代表的只是“直接调用这个方法”，那最好还是用名称来调用它，而不是去描述如何调用它，这样代码可读性更好。基本写法就是目标引用放在分隔符<code>::</code>前，方法的名称放在后面。</p><p>举几个Lambda及其等效方法引用的例子：</p><table style="margin-top:-1rem"><tr><th>Lambda表达式</th><th>等效方法引用</th></tr><br><tr><td>(String s) -&gt; System.out.println(s)</td><td>System.out::println</td></tr><tr><td>(str, i) -&gt; str.substring(i)</td><td>String::substring</td></tr><tr><td>() -&gt; Thread.currentThread().dumpStack()</td><td>Thread.currentThread()::dumpStack</td></tr></table><p>符号<code>::</code>除了出现在方法的引用外，它还常见于<strong>构造函数的引用</strong>中。为了演示什么是构造函数的引用，我们创建一个新的函数式接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@FunctionalInterface</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Generator</span>&lt;<span class="title">T</span>, <span class="title">R</span>&gt; </span>&#123;</div><div class="line">    <span class="function">R <span class="title">create</span><span class="params">(T t)</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p></p><p>创建一个Apple类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Apple</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Apple</span><span class="params">(String color)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.color = color;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">private</span> String color;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getColor</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> color;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setColor</span><span class="params">(String color)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.color = color;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p></p><p>现在我们可以使用如下方式来创造一个Apple实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Generator&lt;String, Apple&gt; g = Apple::<span class="keyword">new</span>;</div><div class="line">Apple apple = g.create(<span class="string">"red"</span>);</div></pre></td></tr></table></figure><p></p><p>这种通过<code>ClassName::new</code>的写法就是构造函数的引用。在这里Generator的抽象方法接收一个String类型参数，返回值类型为Apple，这和Apple类的构造函数相符合，所以这里编译可以通过。它等价于下面的写法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Generator&lt;String, Apple&gt; g = (color) -&gt; <span class="keyword">new</span> Apple(color);</div><div class="line">Apple apple = g.create(<span class="string">"red"</span>);</div></pre></td></tr></table></figure><p></p><h2 id="Lambda表达式访问变量"><a href="#Lambda表达式访问变量" class="headerlink" title="Lambda表达式访问变量"></a>Lambda表达式访问变量</h2><p>Lambda表达式可以访问局部final变量，成员变量和静态变量。</p><p>这里主要说下局部final变量。有无final关键字不重要，重要的是确保该变量的值不会被改变就行了。比如下面的例子可以编译通过：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">String hello = <span class="string">"hello lambda"</span>;</div><div class="line">Runnable r = () -&gt; System.out.println(hello);</div></pre></td></tr></table></figure><p></p><p>而下面的这个就会编译出错，因为变量hello的值被改变了：</p><p><img src="img/QQ截图20180606151220.png" alt="QQ截图20180606151220.png"></p><h2 id="Lambda表达式实战"><a href="#Lambda表达式实战" class="headerlink" title="Lambda表达式实战"></a>Lambda表达式实战</h2><p>假如现在有如下需求：现有一个包含了各种颜色不同重量的苹果的List，编写一个方法，从中筛选出满足要求的苹果。比如筛选出红色的苹果、红色并且重量大于1kg的苹果、绿色重量小于0.5kg的苹果或者红色大于0.5kg的苹果等等。</p><h3 id="不使用Lambda"><a href="#不使用Lambda" class="headerlink" title="不使用Lambda"></a>不使用Lambda</h3><p>在没有接触Lambda之前，我们一般会这样做：</p><p>定义一个筛选的接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> cc.mrbird.java8.domain.Apple;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AppleFilter</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">test</span><span class="params">(Apple apple)</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>然后根据筛选的条件来编写各个不同的实现类：</p><p>筛选出红色苹果的实现方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> cc.mrbird.java8.domain.Apple;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedApple</span> <span class="keyword">implements</span> <span class="title">AppleFilter</span> </span>&#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">test</span><span class="params">(Apple apple)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="string">"red"</span>.equalsIgnoreCase(apple.getColor());</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>筛选出红色并且重量大于1kg的苹果的实现方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> cc.mrbird.java8.domain.Apple;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedAndMoreThan1kgApple</span> <span class="keyword">implements</span> <span class="title">AppleFilter</span> </span>&#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">test</span><span class="params">(Apple apple)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="string">"red"</span>.equalsIgnoreCase(apple.getColor()) &amp;&amp; apple.getWeight() &gt; <span class="number">1.0</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p></p><p>筛选出绿色重量小于0.5kg的苹果或者红色大于0.5kg的苹果的实现方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> cc.mrbird.java8.domain.Apple;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GreenAndLessThan05OrRedAndMoreThan05Apple</span> <span class="keyword">implements</span> <span class="title">AppleFilter</span> </span>&#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">test</span><span class="params">(Apple apple)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> (<span class="string">"green"</span>.equalsIgnoreCase(apple.getColor()) &amp;&amp; apple.getWeight() &lt; <span class="number">0.5</span>)</div><div class="line">                || (<span class="string">"red"</span>.equalsIgnoreCase(apple.getColor()) &amp;&amp; apple.getWeight() &gt; <span class="number">0.5</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p></p><p>筛选苹果的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> cc.mrbird.java8.domain.Apple;</div><div class="line"><span class="keyword">import</span> java.util.ArrayList;</div><div class="line"><span class="keyword">import</span> java.util.List;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppleFilterMethod</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;Apple&gt; <span class="title">filterApple</span><span class="params">(List&lt;Apple&gt; list, AppleFilter filter)</span> </span>&#123;</div><div class="line">        List&lt;Apple&gt; filterList = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">        <span class="keyword">for</span> (Apple apple : list) &#123;</div><div class="line">            <span class="keyword">if</span> (filter.test(apple)) &#123;</div><div class="line">                filterList.add(apple);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> filterList;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p></p><p>开始筛选苹果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">List&lt;Apple&gt; appleList = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">appleList.add(<span class="keyword">new</span> Apple(<span class="string">"red"</span>, <span class="number">0.4</span>));</div><div class="line">appleList.add(<span class="keyword">new</span> Apple(<span class="string">"red"</span>, <span class="number">0.6</span>));</div><div class="line">appleList.add(<span class="keyword">new</span> Apple(<span class="string">"red"</span>, <span class="number">1.3</span>));</div><div class="line">appleList.add(<span class="keyword">new</span> Apple(<span class="string">"green"</span>, <span class="number">0.2</span>));</div><div class="line">appleList.add(<span class="keyword">new</span> Apple(<span class="string">"green"</span>, <span class="number">0.35</span>));</div><div class="line">appleList.add(<span class="keyword">new</span> Apple(<span class="string">"green"</span>, <span class="number">1.1</span>));</div><div class="line"></div><div class="line">List&lt;Apple&gt; appleFilterList = AppleFilterMethod.filterApple(appleList, <span class="keyword">new</span> RedApple());</div><div class="line"><span class="keyword">for</span> (Apple apple : appleFilterList) &#123;</div><div class="line">    System.out.println(apple.getColor() + <span class="string">" apple,weight:"</span> + apple.getWeight());</div><div class="line">&#125;</div></pre></td></tr></table></figure><p></p><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">red apple,weight:0.4</div><div class="line">red apple,weight:0.6</div><div class="line">red apple,weight:1.3</div></pre></td></tr></table></figure><p></p><p>剩下的略。</p><p>可以看到，我们为了满足各种筛选条件创造了各种筛选接口的实现类，真正起作用的只有筛选方法中return那一行代码，剩下的都是一些重复的模板代码。使用Java 8中的Lambda可以很好的消除这些模板代码。</p><h3 id="使用Lambda"><a href="#使用Lambda" class="headerlink" title="使用Lambda"></a>使用Lambda</h3><p>AppleFilter接口实际上就是一个函数式接口，所以它的各种实现可以用Lambda表达式来替代，而无需真正的去写实现方法。</p><p>定义筛选接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> cc.mrbird.java8.domain.Apple;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AppleFilter</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">test</span><span class="params">(Apple apple)</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p></p><p>筛选苹果的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> cc.mrbird.java8.domain.Apple;</div><div class="line"><span class="keyword">import</span> java.util.ArrayList;</div><div class="line"><span class="keyword">import</span> java.util.List;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppleFilterMethod</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;Apple&gt; <span class="title">filterApple</span><span class="params">(List&lt;Apple&gt; list, AppleFilter filter)</span> </span>&#123;</div><div class="line">        List&lt;Apple&gt; filterList = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">        <span class="keyword">for</span> (Apple apple : list) &#123;</div><div class="line">            <span class="keyword">if</span> (filter.test(apple)) &#123;</div><div class="line">                filterList.add(apple);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> filterList;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p></p><p>接下来便可以开始筛选了：</p><p>筛选红色的苹果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">List&lt;Apple&gt; appleFilterList = AppleFilterMethod.filterApple(appleList,</div><div class="line">        (apple) -&gt; <span class="string">"red"</span>.equalsIgnoreCase(apple.getColor()));</div><div class="line"><span class="keyword">for</span> (Apple apple : appleFilterList) &#123;</div><div class="line">    System.out.println(apple.getColor() + <span class="string">" apple,weight:"</span> + apple.getWeight());</div><div class="line">&#125;</div></pre></td></tr></table></figure><p></p><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">red apple,weight:0.4</div><div class="line">red apple,weight:0.6</div><div class="line">red apple,weight:1.3</div></pre></td></tr></table></figure><p></p><p>筛选出红色并且重量大于1kg的苹果:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"> List&lt;Apple&gt; appleFilterList = AppleFilterMethod.filterApple(appleList,</div><div class="line">                (apple) -&gt; <span class="string">"red"</span>.equalsIgnoreCase(apple.getColor()) &amp;&amp; apple.getWeight() &gt; <span class="number">1.0</span>);</div><div class="line"><span class="keyword">for</span> (Apple apple : appleFilterList) &#123;</div><div class="line">    System.out.println(apple.getColor() + <span class="string">" apple,weight:"</span> + apple.getWeight());</div><div class="line">&#125;</div></pre></td></tr></table></figure><p></p><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">red apple,weight:1.3</div></pre></td></tr></table></figure><p></p><p>筛选出绿色重量小于0.5kg的苹果或者红色大于0.5kg的苹果:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">List&lt;Apple&gt; appleFilterList = AppleFilterMethod.filterApple(appleList,</div><div class="line">        (apple) -&gt; (<span class="string">"green"</span>.equalsIgnoreCase(apple.getColor()) &amp;&amp; apple.getWeight() &lt; <span class="number">0.5</span>) ||</div><div class="line">                   (<span class="string">"red"</span>.equalsIgnoreCase(apple.getColor()) &amp;&amp; apple.getWeight() &gt; <span class="number">0.5</span>));</div><div class="line"><span class="keyword">for</span> (Apple apple : appleFilterList) &#123;</div><div class="line">    System.out.println(apple.getColor() + <span class="string">" apple,weight:"</span> + apple.getWeight());</div><div class="line">&#125;</div></pre></td></tr></table></figure><p></p><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">red apple,weight:0.6</div><div class="line">red apple,weight:1.3</div><div class="line">green apple,weight:0.2</div><div class="line">green apple,weight:0.35</div></pre></td></tr></table></figure><p></p><p>使用Lambda表达式消除了大量的样板代码，并且可以灵活的构造筛选条件！</p><blockquote><p><a href="https://book.douban.com/subject/26772632/" target="_blank" rel="external">《Java 8实战》</a>读书笔记</p></blockquote><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Tue Aug 21 2018 16:24:26 GMT+0800 (中国标准时间) --&gt;&lt;p&gt;Java 8的Lambda表达式借鉴了C#和Scala等语言中的类似特性，简化了匿名函数的表达方式。Lambda表达式可以直接以内联的形式为&lt;strong&gt;函数式接口&lt;/strong&gt;的抽象方法提供实现，并把整个表达式作为函数式接口的实例。什么是函数式接口？简单来说就是只包含一个抽象方法的接口，允许有默认的实现（使用default关键字描述方法）。函数式接口建议使用&lt;code&gt;@FunctionalInterface&lt;/code&gt;注解标注，虽然这不是必须的，但是这样做更符合规范。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java" scheme="http://mrbird.cc/tags/Java/"/>
    
      <category term="Java 8" scheme="http://mrbird.cc/tags/Java-8/"/>
    
  </entry>
  
  <entry>
    <title>初识Spring Cloud与微服务</title>
    <link href="http://mrbird.cc/Spring-Cloud%20and%20MicroService.html"/>
    <id>http://mrbird.cc/Spring-Cloud and MicroService.html</id>
    <published>2018-04-02T02:04:16.000Z</published>
    <updated>2018-07-02T00:25:21.563Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Tue Aug 21 2018 16:24:25 GMT+0800 (中国标准时间) --><p>在传统的软件架构中，我们通常采用的是单体应用来构建一个系统，一个单体应用糅合了各种业务模块。起初在业务规模不是很大的情况下，对于单体应用的开发维护也相对容易。但随着企业的发展，业务规模与日递增，单体应用变得愈发臃肿。由于单体应用将各种业务模块聚合在一起，并且部署在一个进程内，所以通常我们对其中一个业务模块的修改也必须将整个应用重新打包上线。为了解决单体应用变得庞大脯肿之后产生的难以维护的问题，微服务架构便出现在了大家的视线里。</p><a id="more"></a><h2 id="什么是微服务"><a href="#什么是微服务" class="headerlink" title="什么是微服务"></a>什么是微服务</h2><p>微服务 (Microservices) 是一种软件架构风格，起源于Peter Rodgers博士于 2005 年度云端运算博览会提出的微 Web 服务 (Micro-Web-Service) 。微服务主旨是将一个原本独立的系统 拆分成多个小型服务，这些小型服务都在各自独立的进程中运行，服务之间通过基于HTTP的RESTful API进行通信协作。下图展示了单体应用和微服务之间的区别：</p><p><img src="img/micro-deployment.png" alt="micro-deployment.png"></p><p>在微服务的架构下，单体应用的各个业务模块被拆分为一个个单独的服务并部署在单独的进程里，每个服务都可以单独的部署和升级。这种去中心化的模式使得后期维护和开发变得更加灵活和方便。由于各个服务单独部署，所以可以使用不同的语句来开发各个业务服务模块。</p><h2 id="什么是Spring-Cloud"><a href="#什么是Spring-Cloud" class="headerlink" title="什么是Spring Cloud"></a>什么是Spring Cloud</h2><p><a href="https://projects.spring.io/spring-cloud/" target="_blank" rel="external">Spring Cloud</a>是一个基千Spring Boot实现的微服务架构开发工具。它为微服务架构中涉及的配置管理、服务治理、断路器、智能路由、微代理、控制总线、全局锁、决策竞选、分布式会话和集群状态管理等操作提供了一种简单的开发方式。Spring Cloud的诞生并不是为了解决微服务中的某一个问题，而是提供了一套解决微服务架构实施的综合性解决方案。</p><p>Spring Cloud是一个由各个独立项目组成的综合项目，每个独立项目有着不同的发布节奏，为了管理每个版本的子项目清单，避免Spring Cloud的版本号与其子项目的版本号相混淆，没有采用版本号的方式，而是通过命名的方式。这些版本的名字采用了伦敦地铁站的名字，根据字母表的顺序来对应版本时间顺序。比如”Angel”是Spring Cloud的第一个发行版名称, “Brixton”是Spring Cloud的第二个发行版名称。当一个版本的Spring Cloud项目的发布内容积累到临界点或者一个严重bug解决可用后，就会发布一个”service releases”版本，简称SRX版本，其中X是一个递增的数字，所以Brixton.SR5就是Brixton的第5个Release版本。</p><p>截至2018年4月02日，Spring Cloud已经发布了代号为Finchley的快照版本，采用的Spring Boot版本为2.0.1.RELEASE。Spring Cloud的版本和Spring Boot的版本关系可以查看官网给的例子。</p><p>以下是Spring Cloud版本与各个独立项目版本对应关系表：</p><table><thead><tr><th>Component</th><th>Edgware.SR3</th><th>Finchley.RC1</th><th>Finchley.BUILD-SNAPSHOT</th></tr></thead><tbody><tr><td>spring-cloud-aws</td><td>1.2.2.RELEASE</td><td>2.0.0.RC1</td><td>2.0.0.BUILD-SNAPSHOT</td></tr><tr><td>spring-cloud-bus</td><td>1.3.2.RELEASE</td><td>2.0.0.RC1</td><td>2.0.0.BUILD-SNAPSHOT</td></tr><tr><td>spring-cloud-cli</td><td>1.4.1.RELEASE</td><td>2.0.0.RC1</td><td>2.0.0.BUILD-SNAPSHOT</td></tr><tr><td>spring-cloud-commons</td><td>1.3.3.RELEASE</td><td>2.0.0.RC1</td><td>2.0.0.BUILD-SNAPSHOT</td></tr><tr><td>spring-cloud-contract</td><td>1.2.4.RELEASE</td><td>2.0.0.RC1</td><td>2.0.0.BUILD-SNAPSHOT</td></tr><tr><td>spring-cloud-config</td><td>1.4.3.RELEASE</td><td>2.0.0.RC1</td><td>2.0.0.BUILD-SNAPSHOT</td></tr><tr><td>spring-cloud-netflix</td><td>1.4.4.RELEASE</td><td>2.0.0.RC1</td><td>2.0.0.BUILD-SNAPSHOT</td></tr><tr><td>spring-cloud-security</td><td>1.2.2.RELEASE</td><td>2.0.0.RC1</td><td>2.0.0.BUILD-SNAPSHOT</td></tr><tr><td>spring-cloud-cloudfoundry</td><td>1.1.1.RELEASE</td><td>2.0.0.RC1</td><td>2.0.0.BUILD-SNAPSHOT</td></tr><tr><td>spring-cloud-consul</td><td>1.3.3.RELEASE</td><td>2.0.0.RC1</td><td>2.0.0.BUILD-SNAPSHOT</td></tr><tr><td>spring-cloud-sleuth</td><td>1.3.3.RELEASE</td><td>2.0.0.RC1</td><td>2.0.0.BUILD-SNAPSHOT</td></tr><tr><td>spring-cloud-stream</td><td>Ditmars.SR3</td><td>Elmhurst.RELEASE</td><td>Elmhurst.BUILD-SNAPSHOT</td></tr><tr><td>spring-cloud-zookeeper</td><td>1.2.1.RELEASE</td><td>2.0.0.RC1</td><td>2.0.0.BUILD-SNAPSHOT</td></tr><tr><td>spring-boot</td><td>1.5.10.RELEASE</td><td>2.0.1.RELEASE</td><td>2.0.0.BUILD-SNAPSHOT</td></tr><tr><td>spring-cloud-task</td><td>1.2.2.RELEASE</td><td>2.0.0.RC1</td><td>2.0.0.RELEASE</td></tr><tr><td>spring-cloud-vault</td><td>1.1.0.RELEASE</td><td>2.0.0.RC1</td><td>2.0.0.BUILD-SNAPSHOT</td></tr><tr><td>spring-cloud-gateway</td><td>1.0.1.RELEASE</td><td>2.0.0.RC1</td><td>2.0.0.BUILD-SNAPSHOT</td></tr><tr><td>spring-cloud-openfeign</td><td>&nbsp;</td><td>2.0.0.RC1</td><td>2.0.0.BUILD-SNAPSHOT</td></tr></tbody></table><p>Finchley使用Spring Boot 2.0.x构建，不建议与Spring Boot 1.5.x一起使用。</p><p>Dalston和Edgware发行版建立在Spring Boot 1.5.x之上，不建议与Spring Boot 2.0.x一起使用。</p><p>之后博文的例子将采用<a href="http://cloud.spring.io/spring-cloud-static/Edgware.SR3/multi/multi_spring-cloud.html" target="_blank" rel="external">Spring Cloud Edgware SR3</a>版本，对应的Spring Boot版本为1.5.13.RELEASE。</p><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ol><li><p><a href="http://blog.cuicc.com/blog/2015/07/22/microservices/" target="_blank" rel="external">http://blog.cuicc.com/blog/2015/07/22/microservices/</a></p></li><li><p><a href="https://www.ibm.com/developerworks/community/blogs/3302cc3b-074e-44da-90b1-5055f1dc0d9c/entry/%E8%A7%A3%E6%9E%90%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84_%E4%B8%80_%E4%BB%80%E4%B9%88%E6%98%AF%E5%BE%AE%E6%9C%8D%E5%8A%A1?lang=en_us" target="_blank" rel="external">https://www.ibm.com/developerworks/community/blogs/</a></p></li><li><p><a href="https://projects.spring.io/spring-cloud/" target="_blank" rel="external">https://projects.spring.io/spring-cloud/</a></p></li><li><p><a href="https://book.douban.com/subject/27025912/" target="_blank" rel="external">《Spring Cloud微服务实战》</a></p></li></ol><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Tue Aug 21 2018 16:24:25 GMT+0800 (中国标准时间) --&gt;&lt;p&gt;在传统的软件架构中，我们通常采用的是单体应用来构建一个系统，一个单体应用糅合了各种业务模块。起初在业务规模不是很大的情况下，对于单体应用的开发维护也相对容易。但随着企业的发展，业务规模与日递增，单体应用变得愈发臃肿。由于单体应用将各种业务模块聚合在一起，并且部署在一个进程内，所以通常我们对其中一个业务模块的修改也必须将整个应用重新打包上线。为了解决单体应用变得庞大脯肿之后产生的难以维护的问题，微服务架构便出现在了大家的视线里。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Spring Cloud" scheme="http://mrbird.cc/tags/Spring-Cloud/"/>
    
  </entry>
  
  <entry>
    <title>Spring Boot Devtools热部署</title>
    <link href="http://mrbird.cc/Spring-Boot-Devtools.html"/>
    <id>http://mrbird.cc/Spring-Boot-Devtools.html</id>
    <published>2018-03-31T01:25:49.000Z</published>
    <updated>2018-05-23T03:31:39.786Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Tue Aug 21 2018 16:24:25 GMT+0800 (中国标准时间) --><p>平日里开发项目中，修改了Java代码或者配置文件的时候，必须手动重启项目才能生效。所谓的热部署就是在你修改了后端代码后不需要手动重启，工具会帮你快速的自动重启是修改生效。其深层原理是使用了两个<code>ClassLoader</code>，一个<code>Classloader</code>加载那些不会改变的类（第三方Jar包），另一个<code>ClassLoader</code>加载会更改的类，称为<code>restart ClassLoader</code>，这样在有代码更改的时候，原来的<code>restart ClassLoader</code> 被丢弃，重新创建一个<code>restart ClassLoader</code>，由于需要加载的类相比较少，所以实现了较快的重启时间。</p><a id="more"></a><p>本文将介绍如何通过使用<code>Spring-Boot-devtools</code>来实现Spring Boot项目的热部署。IDE使用的是Eclipse Oxygen，并且使用Maven构建。</p><h2 id="引入Devtools"><a href="#引入Devtools" class="headerlink" title="引入Devtools"></a>引入Devtools</h2><p>搭建一个简单的Spring Boot项目，然后引入Spring-Boot-devtools：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-devtools<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div></pre></td></tr></table></figure><p></p><p>devtools会监听classpath下的文件变动，并且会立即重启应用（发生在保存时机），因为其采用的虚拟机机制，该项重启是很快的。</p><p>在Eclipse中生效还需要修改<code>spring-boot-maven-plugin</code>插件：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></div><div class="line">                <span class="tag">&lt;<span class="name">fork</span>&gt;</span>true<span class="tag">&lt;/<span class="name">fork</span>&gt;</span></div><div class="line">            <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></div></pre></td></tr></table></figure><p></p><p>并且开启Build Automatically：</p><p><img src="img/QQ截图20180523094924.png" alt="QQ截图20180523094924.png"></p><h2 id="测试热部署"><a href="#测试热部署" class="headerlink" title="测试热部署"></a>测试热部署</h2><p>在入口类中添加一个方法，用于热部署测试：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</div><div class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</div><div class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</div><div class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</div><div class="line"></div><div class="line"><span class="meta">@RestController</span></div><div class="line"><span class="meta">@SpringBootApplication</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoApplication</span> </span>&#123;</div><div class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/"</span>)</div><div class="line">    <span class="function">String <span class="title">index</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="string">"hello spring boot"</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        SpringApplication.run(DemoApplication.class, args);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p></p><p>启动项目访问<a href="http://localhost:8080/" target="_blank" rel="external">http://localhost:8080/</a>，页面输出hello spring boot。</p><p>将方法的返回值修改为hello world并在保存的瞬间，应用便重启好了，刷新页面，内容也将得到更改。</p><h2 id="所有配置"><a href="#所有配置" class="headerlink" title="所有配置"></a>所有配置</h2><p>下面是所有Devtools在Spring Boot中的可选配置:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"># Whether to enable a livereload.com-compatible server.</div><div class="line">spring.devtools.livereload.enabled=true </div><div class="line"></div><div class="line"># Server port.</div><div class="line">spring.devtools.livereload.port=35729 </div><div class="line"></div><div class="line"># Additional patterns that should be excluded from triggering a full restart.</div><div class="line">spring.devtools.restart.additional-exclude= </div><div class="line"></div><div class="line"># Additional paths to watch for changes.</div><div class="line">spring.devtools.restart.additional-paths= </div><div class="line"></div><div class="line"># Whether to enable automatic restart.</div><div class="line">spring.devtools.restart.enabled=true</div><div class="line"></div><div class="line"># Patterns that should be excluded from triggering a full restart.</div><div class="line">spring.devtools.restart.exclude=META-INF/maven/**,META-INF/resources/**,resources/**,static/**,public/**,templates/**,**/*Test.class,**/*Tests.class,git.properties,META-INF/build-info.properties</div><div class="line"></div><div class="line"># Whether to log the condition evaluation delta upon restart.</div><div class="line">spring.devtools.restart.log-condition-evaluation-delta=true </div><div class="line"></div><div class="line"># Amount of time to wait between polling for classpath changes.</div><div class="line">spring.devtools.restart.poll-interval=1s </div><div class="line"></div><div class="line"># Amount of quiet time required without any classpath changes before a restart is triggered.</div><div class="line">spring.devtools.restart.quiet-period=400ms </div><div class="line"></div><div class="line"># Name of a specific file that, when changed, triggers the restart check. If not specified, any classpath file change triggers the restart.</div><div class="line">spring.devtools.restart.trigger-file=</div></pre></td></tr></table></figure><p></p><p>源码链接：<a href="https://github.com/wuyouzhuguli/Spring-Boot-Demos/tree/master/24.Spring-Boot-Devtools" target="_blank" rel="external">https://github.com/wuyouzhuguli/Spring-Boot-Demos/tree/master/24.Spring-Boot-Devtools</a></p><blockquote><p>参考自： <a href="http://412887952-qq-com.iteye.com/blog/2300313" target="_blank" rel="external">http://412887952-qq-com.iteye.com/blog/2300313</a></p></blockquote><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Tue Aug 21 2018 16:24:25 GMT+0800 (中国标准时间) --&gt;&lt;p&gt;平日里开发项目中，修改了Java代码或者配置文件的时候，必须手动重启项目才能生效。所谓的热部署就是在你修改了后端代码后不需要手动重启，工具会帮你快速的自动重启是修改生效。其深层原理是使用了两个&lt;code&gt;ClassLoader&lt;/code&gt;，一个&lt;code&gt;Classloader&lt;/code&gt;加载那些不会改变的类（第三方Jar包），另一个&lt;code&gt;ClassLoader&lt;/code&gt;加载会更改的类，称为&lt;code&gt;restart ClassLoader&lt;/code&gt;，这样在有代码更改的时候，原来的&lt;code&gt;restart ClassLoader&lt;/code&gt; 被丢弃，重新创建一个&lt;code&gt;restart ClassLoader&lt;/code&gt;，由于需要加载的类相比较少，所以实现了较快的重启时间。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Spring Boot" scheme="http://mrbird.cc/tags/Spring-Boot/"/>
    
  </entry>
  
</feed>
