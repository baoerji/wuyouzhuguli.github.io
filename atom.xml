<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>MrBird</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://mrbird.cc/"/>
  <updated>2019-04-04T03:49:46.096Z</updated>
  <id>http://mrbird.cc/</id>
  
  <author>
    <name>MrBird</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Spring Boot WebFlux增删改查样例</title>
    <link href="http://mrbird.cc/Spring-Boot-WebFlux-CRUD.html"/>
    <id>http://mrbird.cc/Spring-Boot-WebFlux-CRUD.html</id>
    <published>2018-12-02T08:00:36.000Z</published>
    <updated>2019-04-04T03:49:46.096Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Apr 04 2019 14:23:35 GMT+0800 (GMT+08:00) --><p>在<a href="/Spring-Boot-2-0-WebFlux.html]"> Spring Boot 2.0 WebFlux编程 </a>一节我们大致了解了WebFlux的用法，这节我们将结合Mongo DB在WebFlux的架构下实现增删改查样例。和<a href="/Spring-Boot-Mongo-DB-CRUD.html"> Spring Boot整合Mongo DB </a>不同的是，我们使用的是Reactive Mongo DB依赖，所有增删改查方法返回值类型为Flux或者Mono。</p><a id="more"></a><h2 id="项目准备"><a href="#项目准备" class="headerlink" title="项目准备"></a>项目准备</h2><p>新建一个Spring Boot项目，版本为2.1.3.RELEASE，并引入<code>webflux</code>和<code>reactive mongodb</code>依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-webflux<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-mongodb-reactive<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p></p><p>要开启<code>Reactive Mongo DB</code>的相关配置，需要在Spring Boot启动类上添加<code>@EnableReactiveMongoRepositories</code>注解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableReactiveMongoRepositories</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebfluxApplication</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(WebfluxApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>接着在配置文件application.yml里配置Mongo DB连接：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  data:</span></span><br><span class="line"><span class="attr">    mongodb:</span></span><br><span class="line"><span class="attr">      host:</span> <span class="string">localhost</span></span><br><span class="line"><span class="attr">      port:</span> <span class="number">27017</span></span><br><span class="line"><span class="attr">      database:</span> <span class="string">webflux</span></span><br></pre></td></tr></table></figure><p></p><p>使用的是<code>webflux</code>数据库，所以需要在Mongo DB里新建一个<code>webflux</code>数据库（并创建user文档/表，以供待会使用）：</p><p><img src="img/QQ截图20190404105640.png" alt="QQ截图20190404105640.png"></p><p>创建<code>User</code>实体类:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Document</span>(collection = <span class="string">"user"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="keyword">private</span> String id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    <span class="keyword">private</span> String description;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// get set 略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h2 id="简单增删改查"><a href="#简单增删改查" class="headerlink" title="简单增删改查"></a>简单增删改查</h2><p>创建<code>UserDao</code>接口，继承自<code>ReactiveMongoRepository</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserDao</span> <span class="keyword">extends</span> <span class="title">ReactiveMongoRepository</span>&lt;<span class="title">User</span>, <span class="title">String</span>&gt; </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>和<a href="/Spring-Boot-Mongo-DB-CRUD.html"> Spring Boot整合Mongo DB </a>不同的是，我们继承的是<code>ReactiveMongoRepository</code>而非<code>MongoRepository</code>，它所提供的方法都是响应式的：</p><p><img src="img/QQ截图20190404110050.png" alt="QQ截图20190404110050.png"></p><p>在<code>UserService</code>里通过<code>UserDao</code>定义简单增删改查方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserDao userDao;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Flux&lt;User&gt; <span class="title">getUsers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> userDao.findAll();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Mono&lt;User&gt; <span class="title">getUser</span><span class="params">(String id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.userDao.findById(id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Mono&lt;User&gt; <span class="title">createUser</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> userDao.save(user);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Mono&lt;Void&gt; <span class="title">deleteUser</span><span class="params">(String id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.userDao.findById(id)</span><br><span class="line">                .flatMap(user -&gt; <span class="keyword">this</span>.userDao.delete(user));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Mono&lt;User&gt; <span class="title">updateUser</span><span class="params">(String id, User user)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.userDao.findById(id)</span><br><span class="line">            .flatMap(u -&gt; &#123;</span><br><span class="line">                u.setName(user.getName());</span><br><span class="line">                u.setAge(user.getAge());</span><br><span class="line">                u.setDescription(user.getDescription());</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">this</span>.userDao.save(u);</span><br><span class="line">            &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>大致上和<a href="/Spring-Boot-Mongo-DB-CRUD.html"> Spring Boot整合Mongo DB </a>中的<code>UserService</code>差不多，不同的是返回值类型为Flux或者Mono，即它们是响应式非阻塞的方法。</p><p>编写RESTful<code>UserController</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"user"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserService userService;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 以数组的形式一次性返回所有数据</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@GetMapping</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Flux&lt;User&gt; <span class="title">getUsers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> userService.getUsers();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 以 Server sent events形式多次返回数据</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@GetMapping</span>(value = <span class="string">"/stream"</span>, produces = MediaType.TEXT_EVENT_STREAM_VALUE)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Flux&lt;User&gt; <span class="title">getUsersStream</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> userService.getUsers();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Mono&lt;User&gt; <span class="title">createUser</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> userService.createUser(user);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 存在返回 200，不存在返回 404</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@DeleteMapping</span>(<span class="string">"/&#123;id&#125;"</span>)</span><br><span class="line">    <span class="keyword">public</span> Mono&lt;ResponseEntity&lt;Void&gt;&gt; deleteUser(<span class="meta">@PathVariable</span> String id) &#123;</span><br><span class="line">        <span class="keyword">return</span> userService.deleteUser(id)</span><br><span class="line">                .then(Mono.just(<span class="keyword">new</span> ResponseEntity&lt;Void&gt;(HttpStatus.OK)))</span><br><span class="line">                .defaultIfEmpty(<span class="keyword">new</span> ResponseEntity&lt;&gt;(HttpStatus.NOT_FOUND));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 存在返回修改后的 User</span></span><br><span class="line"><span class="comment">     * 不存在返回 404</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@PutMapping</span>(<span class="string">"/&#123;id&#125;"</span>)</span><br><span class="line">    <span class="keyword">public</span> Mono&lt;ResponseEntity&lt;User&gt;&gt; updateUser(<span class="meta">@PathVariable</span> String id, User user) &#123;</span><br><span class="line">        <span class="keyword">return</span> userService.updateUser(id, user)</span><br><span class="line">                .map(u -&gt; <span class="keyword">new</span> ResponseEntity&lt;&gt;(u, HttpStatus.OK))</span><br><span class="line">                .defaultIfEmpty(<span class="keyword">new</span> ResponseEntity&lt;&gt;(HttpStatus.NOT_FOUND));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据用户 id查找</span></span><br><span class="line"><span class="comment">     * 存在返回，不存在返回 404</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/&#123;id&#125;"</span>)</span><br><span class="line">    <span class="keyword">public</span> Mono&lt;ResponseEntity&lt;User&gt;&gt; getUser(<span class="meta">@PathVariable</span> String id) &#123;</span><br><span class="line">        <span class="keyword">return</span> userService.getUser(id)</span><br><span class="line">                .map(user -&gt; <span class="keyword">new</span> ResponseEntity&lt;&gt;(user, HttpStatus.OK))</span><br><span class="line">                .defaultIfEmpty(<span class="keyword">new</span> ResponseEntity&lt;&gt;(HttpStatus.NOT_FOUND));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>对于返回值为<code>Flux&lt;T&gt;</code>类型的方法，推荐定义两个一样的方法，一个以普通形式返回，一个以Server Sent Event的形式返回。对于修改和删除，如果需要修改和删除的用户不存在，我们返回404。</p><p>对于Flux和Mono的操作，在<a href="/Spring-Boot-2-0-WebFlux.html]"> Spring Boot 2.0 WebFlux编程 </a>一节中已经介绍过了，这里就不再赘述了。</p><h2 id="排序与分页"><a href="#排序与分页" class="headerlink" title="排序与分页"></a>排序与分页</h2><p>在<a href="/Spring-Boot-Mongo-DB-CRUD.html"> Spring Boot整合Mongo DB </a>一节中，我们通过<code>MongoTemplate</code>实现了排序与分页。与<code>MongoTemplate</code>对于的响应式的对象为<code>ReactiveMongoTemplate</code>，所以我们照葫芦画瓢，仿照<code>MongoTemplate</code>的写法来实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 分页查询，只返回分页后的数据，count值需要通过 getUserByConditionCount</span></span><br><span class="line"><span class="comment"> * 方法获取</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Flux&lt;User&gt; <span class="title">getUserByCondition</span><span class="params">(<span class="keyword">int</span> size, <span class="keyword">int</span> page, User user)</span> </span>&#123;</span><br><span class="line">    Query query = getQuery(user);</span><br><span class="line">    Sort sort = <span class="keyword">new</span> Sort(Sort.Direction.DESC, <span class="string">"age"</span>);</span><br><span class="line">    Pageable pageable = PageRequest.of(page, size, sort);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> template.find(query.with(pageable), User.class);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回 count，配合 getUserByCondition使用</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Mono&lt;Long&gt; <span class="title">getUserByConditionCount</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">    Query query = getQuery(user);</span><br><span class="line">    <span class="keyword">return</span> template.count(query, User.class);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> Query <span class="title">getQuery</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">    Query query = <span class="keyword">new</span> Query();</span><br><span class="line">    Criteria criteria = <span class="keyword">new</span> Criteria();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!StringUtils.isEmpty(user.getName())) &#123;</span><br><span class="line">        criteria.and(<span class="string">"name"</span>).is(user.getName());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!StringUtils.isEmpty(user.getDescription())) &#123;</span><br><span class="line">        criteria.and(<span class="string">"description"</span>).regex(user.getDescription());</span><br><span class="line">    &#125;</span><br><span class="line">    query.addCriteria(criteria);</span><br><span class="line">    <span class="keyword">return</span> query;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>之所以拆分是因为没找到与<code>PageableExecutionUtils</code>类的<code>getPage</code>方法类似的方法，如果是响应式的话，返回值类型应该是<code>Mono&lt;Page&lt;User&gt;&gt;</code>，不懂大家有没别的更好的实现方法？</p><p>源码和PostMan测试样例链接：<a href="https://github.com/wuyouzhuguli/SpringAll/tree/master/58.Spring-Boot-WebFlux-crud" target="_blank" rel="noopener">https://github.com/wuyouzhuguli/SpringAll/tree/master/58.Spring-Boot-WebFlux-crud</a></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Thu Apr 04 2019 14:23:35 GMT+0800 (GMT+08:00) --&gt;&lt;p&gt;在&lt;a href=&quot;/Spring-Boot-2-0-WebFlux.html]&quot;&gt; Spring Boot 2.0 WebFlux编程 &lt;/a&gt;一节我们大致了解了WebFlux的用法，这节我们将结合Mongo DB在WebFlux的架构下实现增删改查样例。和&lt;a href=&quot;/Spring-Boot-Mongo-DB-CRUD.html&quot;&gt; Spring Boot整合Mongo DB &lt;/a&gt;不同的是，我们使用的是Reactive Mongo DB依赖，所有增删改查方法返回值类型为Flux或者Mono。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Spring" scheme="http://mrbird.cc/tags/Spring/"/>
    
      <category term="Spring Boot" scheme="http://mrbird.cc/tags/Spring-Boot/"/>
    
      <category term="MongoDB" scheme="http://mrbird.cc/tags/MongoDB/"/>
    
      <category term="WebFlux" scheme="http://mrbird.cc/tags/WebFlux/"/>
    
  </entry>
  
  <entry>
    <title>Spring Cloud Consul服务治理</title>
    <link href="http://mrbird.cc/Spring-Cloud-Consul.html"/>
    <id>http://mrbird.cc/Spring-Cloud-Consul.html</id>
    <published>2018-11-29T08:00:31.000Z</published>
    <updated>2019-03-28T06:44:59.912Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Apr 04 2019 14:23:35 GMT+0800 (GMT+08:00) --><p>Consul是一款由<a href="https://www.hashicorp.com/" target="_blank" rel="noopener">HashiCorp</a>公司开源的，用于服务治理的软件，<a href="https://spring.io/projects/spring-cloud-consul" target="_blank" rel="noopener">Spring Cloud Consul</a>对其进行了封装。Consul具有如下特点:</p><ol><li><p>服务注册 - 自动注册和取消注册服务实例的网络位置</p></li><li><p>运行状况检查 - 检测服务实例何时启动并运行</p></li><li><p>分布式配置 - 确保所有服务实例使用相同的配置</p></li></ol><a id="more"></a><p>Consul agent有两种运行模式：Server和Client。这里的Server和Client只是Consul集群层面的区分，与搭建在Cluster之上 的应用服务无关。 以Server模式运行的Consul agent节点用于维护Consul集群的状态，官方建议每个Consul Cluster至少有3个或以上的运行在Server mode的Agent，Client节点不限。</p><h2 id="安装Consul"><a href="#安装Consul" class="headerlink" title="安装Consul"></a>安装Consul</h2><p>Consul下载地址：<a href="https://www.consul.io/downloads.html" target="_blank" rel="noopener">https://www.consul.io/downloads.html</a>，本文选择Linux 64bit 版本进行演示。</p><p>下载后解压，然后在解压目录下运行<code>./consul</code>命令：</p><p><img src="img/QQ截图20190328094517.png" alt="QQ截图20190328094517.png"></p><p>可以看到Consul所包含的命令，使用<code>consul [命令] --help</code>可以查看某个命令的具体用法。</p><p>执行下面这条命令来启动一个Consul agent：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./consul agent -dev -client 192.168.140.215</span><br></pre></td></tr></table></figure><p></p><p><code>-dev</code>表示创建一个开发环境下的server节点，不该模式下会有任何持久化操作，即不会有任何数据写入到磁盘，所以这个模式适合用于开发过程，而不适用于生产环境。<code>-client 192.168.140.215</code>表示运行客户端使用ip地址<code>192.168.140.215</code>（本文Linux环境IP地址）去访问。</p><p>启动后，默认的端口号为8500，访问<a href="http://192.168.140.215:8500" target="_blank" rel="noopener">http://192.168.140.215:8500</a></p><p><img src="img/QQ截图20190328100116.png" alt="QQ截图20190328100116.png"></p><p>当前就一个consul服务。接下来我们开始创建服务提供者和服务消费者。</p><h2 id="Server-Provider"><a href="#Server-Provider" class="headerlink" title="Server-Provider"></a>Server-Provider</h2><p>创建一个Spring Boot项目，版本为2.0.2.RELEASE，<code>artifactId</code>为server-provider，Spring Cloud版本为Finchley.RELEASE：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">java.version</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">spring-cloud.version</span>&gt;</span>Finchley.RELEASE<span class="tag">&lt;/<span class="name">spring-cloud.version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-consul-discovery<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring-cloud.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br></pre></td></tr></table></figure><p></p><p>然后在配置文件里添加如下配置：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line"><span class="attr">  port:</span> <span class="number">9000</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  application:</span></span><br><span class="line"><span class="attr">    name:</span> <span class="string">server-provider</span></span><br><span class="line"><span class="attr">  cloud:</span></span><br><span class="line"><span class="attr">    consul:</span></span><br><span class="line"><span class="attr">      host:</span> <span class="number">192.168</span><span class="number">.140</span><span class="number">.215</span></span><br><span class="line"><span class="attr">      port:</span> <span class="number">8500</span></span><br><span class="line"><span class="attr">      discovery:</span></span><br><span class="line"><span class="attr">        health-check-interval:</span> <span class="number">10</span><span class="string">s</span></span><br><span class="line"><span class="attr">        service-name:</span> <span class="string">$&#123;spring.application.name&#125;</span></span><br><span class="line"><span class="attr">        register-health-check:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">        health-check-path:</span> <span class="string">/check</span></span><br></pre></td></tr></table></figure><p></p><p><code>spring.cloud.consul.host</code>和<code>spring.cloud.consul.port</code>配置了consul的ip和端口；<code>spring.cloud.consul.discovery.service-name</code>配置了该服务在consul里注册的服务名称；<code>spring.cloud.consul.discovery.register-health-check</code>用于开启健康检查，<code>spring.cloud.consul.discovery.health-check-interval</code>配置了健康检查的周期为10秒，<code>spring.cloud.consul.discovery.health-check-path</code>配置了健康检查路径。</p><p>接着新建TestController：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestController</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Logger logger = LoggerFactory.getLogger(<span class="keyword">this</span>.getClass());</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"check"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">check</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        logger.info(<span class="string">"health check"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"ok"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"hello"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        logger.info(<span class="string">"hello"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"hello from server provider"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p><code>check</code>方法用于监控检查，TestController还提供了一个<code>hello</code>方法，以供后续服务消费者调用。</p><p><code>spring.cloud.consul.discovery.health-check-path</code>的默认值为<code>/actuator/health</code>，如果采用该默认值的话，还需要导入<code>spring-boot-starter-actuator</code>依赖。</p><p>最后，要开启服务注册与发行，需要在Spring Boot入口类上添加<code>@EnableDiscoveryClient</code>注解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableDiscoveryClient</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServerProviderApplication</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(ServerProviderApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>准备完毕后，打包项目，然后启动两个实例，端口号分别为9000和9001，启动后，再次访问consul管理界面：</p><p><img src="img/QQ截图20190328104441.png" alt="QQ截图20190328104441.png"></p><p><img src="img/QQ截图20190328104520.png" alt="QQ截图20190328104520.png"></p><p>服务提供者注册成功，接下来开始搭建服务消费者。</p><h2 id="Server-Consumer"><a href="#Server-Consumer" class="headerlink" title="Server-Consumer"></a>Server-Consumer</h2><p>创建一个Spring Boot项目，版本为2.0.2.RELEASE，artifactId为server-provider，Spring Cloud版本为Finchley.RELEASE：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">java.version</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">spring-cloud.version</span>&gt;</span>Finchley.RELEASE<span class="tag">&lt;/<span class="name">spring-cloud.version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-consul-discovery<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring-cloud.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br></pre></td></tr></table></figure><p></p><p>引入<code>spring-boot-starter-actuator</code>用于默认的健康检查。</p><p>配置application.yml：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line"><span class="attr">  port:</span> <span class="number">9002</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  application:</span></span><br><span class="line"><span class="attr">    name:</span> <span class="string">server-consumer</span></span><br><span class="line"></span><br><span class="line"><span class="attr">  cloud:</span></span><br><span class="line"><span class="attr">    consul:</span></span><br><span class="line"><span class="attr">      host:</span> <span class="number">192.168</span><span class="number">.140</span><span class="number">.215</span></span><br><span class="line"><span class="attr">      port:</span> <span class="number">8500</span></span><br><span class="line"><span class="attr">      discovery:</span></span><br><span class="line"><span class="attr">        service-name:</span> <span class="string">$&#123;spring.application.name&#125;</span></span><br></pre></td></tr></table></figure><p></p><p>同样的，需要开启服务注册与发现需要在入口类上添加<code>@EnableDiscoveryClient</code>注解。</p><p>接着创建TestController来消费Server-Provider提供的<code>hello</code>服务：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Logger loggr = LoggerFactory.getLogger(<span class="keyword">this</span>.getClass());</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> DiscoveryClient discoveryClient;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> LoadBalancerClient loadBalancerClient;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> RestTemplate restTemplate = <span class="keyword">new</span> RestTemplate();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String SERVER_ID = <span class="string">"server-provider"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"uri"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;URI&gt; <span class="title">getServerUris</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.discoveryClient.getInstances(SERVER_ID)</span><br><span class="line">                .stream()</span><br><span class="line">                .map(ServiceInstance::getUri).collect(Collectors.toList());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"hello"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ServiceInstance instance = loadBalancerClient.choose(SERVER_ID);</span><br><span class="line">        String url = instance.getUri().toString() + <span class="string">"/hello"</span>;</span><br><span class="line">        loggr.info(<span class="string">"remote server url：&#123;&#125;"</span>, url);</span><br><span class="line">        <span class="keyword">return</span> restTemplate.getForObject(url, String.class);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p><strong>SERVER_ID</strong>的值为服务提供者在consul注册中心的实例名称，即<code>server-provider</code>。通过<code>DiscoveryClient</code>我们可以获取到所有名称为<code>server-provider</code>的服务实例信息。通过<code>LoadBalancerClient</code>我们可以实现负载均衡地去获取服务实例，并通过<code>RestTemplate</code>去调用服务。</p><p>打包部署项目，然后查看consul控制台：</p><p><img src="img/QQ截图20190328110004.png" alt="QQ截图20190328110004.png"></p><p>访问：<a href="http://192.168.140.215:9002/uri" target="_blank" rel="noopener">http://192.168.140.215:9002/uri</a>：</p><p><img src="img/QQ截图20190328110116.png" alt="QQ截图20190328110116.png"></p><p>可以看到我们成功获取到了服务名称为<code>server-provider</code>的两个具体实例。</p><p>多次调用<a href="http://192.168.140.215:9002/hello" target="_blank" rel="noopener">http://192.168.140.215:9002/hello</a>：</p><p><img src="img/QQ截图20190328110243.png" alt="QQ截图20190328110243.png"></p><p>控制台输出如下：</p><p><img src="img/QQ截图20190328110406.png" alt="QQ截图20190328110406.png"></p><p>服务调用是均衡的。</p><p>除此之外，consul内置了Ribbon，所以我们还可以通过<code>@LoadBalanced</code>标注的<code>RestTemplate</code>来实现负载均衡服务调用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> RestTemplate restTemplate;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String SERVER_ID = <span class="string">"server-provider"</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@LoadBalanced</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> RestTemplate <span class="title">restTemplate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> RestTemplate();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"hello"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    String url = <span class="string">"http://"</span> + SERVER_ID + <span class="string">"/hello"</span>;</span><br><span class="line">    <span class="keyword">return</span> restTemplate.getForObject(url, String.class);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>效果是一样的。</p><h2 id="consul集群"><a href="#consul集群" class="headerlink" title="consul集群"></a>consul集群</h2><p>上面我们只是以<code>-dev</code>模式开启了一个单节点consul agent，生产环境下需要搭建consul集群来确保高可用。</p><p>搭建consul集群时常用的命令有:</p><table><thead><tr><th>命令</th><th>解释</th><th>示例</th></tr></thead><tbody><tr><td>agent</td><td>运行一个consul agent</td><td>consul agent -dev</td></tr><tr><td>join</td><td>将agent加入到consul集群</td><td>consul join IP</td></tr><tr><td>members</td><td>列出consul cluster集群中的members</td><td>consul members</td></tr><tr><td>leave</td><td>将节点移除所在集群</td><td>consul leave</td></tr></tbody></table><p>准备了三台Linux服务器，配置如下：</p><table><tbody><tr><th width="27px"><p>序号</p></th><th><p>节点ip</p></th><th><p>节点名称</p></th><th><p>角色</p></th></tr><tr><td><p>1</p></td><td><p>192.168.140.215</p></td><td><p>consul-server-215</p></td><td><p>server</p></td></tr><tr><td><p>2</p></td><td><p>192.168.140.213</p></td><td><p>consul-server-213</p></td><td><p>server</p></td></tr><tr><td><p>3</p></td><td><p>192.168.140.216</p></td><td><p>consul-server-216</p></td><td><p>server &amp; web ui</p></td></tr></tbody></table><p>在这三台服务器上下载并解压consul，然后在解压的根目录上创建一个data目录。</p><p>由于我们之前已经在215上启动了consul，所以先执行<code>killall consul</code>来杀掉进程，然后执行下面这条命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nohup ./consul agent -server -<span class="built_in">bind</span> 192.168.140.215 -client=0.0.0.0 -bootstrap-expect=3 -data-dir=data -node=consul-server-215 &amp;</span><br></pre></td></tr></table></figure><p></p><p>解释一下上面这条命令的含义:</p><ul><li><p><code>-server</code>表示以服务的形式启动agent</p></li><li><p><code>-bind</code>表示绑定到当前Linux的ip（有些服务器会绑定多块网卡，可以通过bind参数强制指定绑定的ip）</p></li><li><p><code>-client</code>指定客户端访问的ip（consul有丰富的api接口，这里的客户端指浏览器或调用方），0.0.0.0表示不限客户端ip</p></li><li><p><code>-bootstrap-expect=3</code>表示server集群最低节点数为3，低于这个值将工作不正常(注：类似zookeeper一样，通常集群数为奇数，方便选举，consul采用的是raft算法)</p></li><li><p><code>-data-dir</code>表示指定数据的存放目录（该目录必须存在）</p></li><li><p><code>-node</code>表示节点的名称</p></li></ul><p>接着在213服务器上执行下面这条命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nohup ./consul agent -server -<span class="built_in">bind</span> 192.168.140.213 -client=0.0.0.0 -bootstrap-expect=3 -data-dir=data -node=consul-server-213 &amp;</span><br></pre></td></tr></table></figure><p></p><p>最后在216上执行下面这条命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nohup ./consul agent -server -<span class="built_in">bind</span> 192.168.140.216 -client=0.0.0.0 -bootstrap-expect=3 -data-dir=data -node=consul-server-216 -ui &amp;</span><br></pre></td></tr></table></figure><p></p><p>和前两条命令相比，这条命令多了<code>-ui</code>选项，表示开启管理界面UI。</p><p>然后分别在213和215下执行下面这条命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./consul join 192.168.140.216</span><br></pre></td></tr></table></figure><p></p><p>这样213和215成功加入到了216构成了一个三节点集群，运行<code>./consul members</code>查看：</p><p><img src="img/QQ截图20190328143323.png" alt="QQ截图20190328143323.png"></p><p>访问<a href="http://192.168.140.216:8500" target="_blank" rel="noopener">http://192.168.140.216:8500</a>：</p><p><img src="img/QQ截图20190328143504.png" alt="QQ截图20190328143504.png"></p><p>访问<a href="http://192.168.140.215:9002/hello" target="_blank" rel="noopener">http://192.168.140.215:9002/hello</a>：</p><p><img src="img/QQ截图20190328143922.png" alt="QQ截图20190328143922.png"></p><p>这时候在215执行<code>killall consul</code>命令，杀死consul服务，然后在216上执行<code>./consul members</code>：</p><p><img src="img/QQ截图20190328143837.png" alt="QQ截图20190328143837.png"></p><p><img src="img/QQ截图20190328144326.png" alt="QQ截图20190328144326.png"></p><p>可以看到215节点已经挂了，再次访问<a href="http://192.168.140.215:9002/hello" target="_blank" rel="noopener">http://192.168.140.215:9002/hello</a>：</p><p><img src="img/QQ截图20190328143922.png" alt="QQ截图20190328143922.png"></p><p>服务依旧获取成功。</p><p>可见，虽然我们在application.yml中配置consul的地址是192.168.140.215:8500，但由于我们构建的是consul集群，所以微服务启动时会获取到整个集群信息，即使215这个节点挂了，微服务可以从别的consul节点上获取注册的服务信息。</p><p>参考文档：</p><ol><li><p><a href="https://learn.hashicorp.com/consul/getting-started/install.html" target="_blank" rel="noopener">https://learn.hashicorp.com/consul/getting-started/install.html</a></p></li><li><p><a href="https://cloud.spring.io/spring-cloud-consul/spring-cloud-consul.html#spring-cloud-consul-hystrix" target="_blank" rel="noopener">https://cloud.spring.io/spring-cloud-consul/spring-cloud-consul.html#spring-cloud-consul-hystrix</a></p></li></ol><blockquote><p>源码链接：<a href="https://github.com/wuyouzhuguli/SpringAll/tree/master/55.Spring-Cloud-Consul" target="_blank" rel="noopener">https://github.com/wuyouzhuguli/SpringAll/tree/master/55.Spring-Cloud-Consul</a></p></blockquote><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Thu Apr 04 2019 14:23:35 GMT+0800 (GMT+08:00) --&gt;&lt;p&gt;Consul是一款由&lt;a href=&quot;https://www.hashicorp.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;HashiCorp&lt;/a&gt;公司开源的，用于服务治理的软件，&lt;a href=&quot;https://spring.io/projects/spring-cloud-consul&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Spring Cloud Consul&lt;/a&gt;对其进行了封装。Consul具有如下特点:&lt;/p&gt;&lt;ol&gt;&lt;li&gt;&lt;p&gt;服务注册 - 自动注册和取消注册服务实例的网络位置&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;运行状况检查 - 检测服务实例何时启动并运行&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;分布式配置 - 确保所有服务实例使用相同的配置&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;
    
    </summary>
    
    
      <category term="Spring Cloud" scheme="http://mrbird.cc/tags/Spring-Cloud/"/>
    
      <category term="Consul" scheme="http://mrbird.cc/tags/Consul/"/>
    
  </entry>
  
  <entry>
    <title>Spring Boot整合Kafka</title>
    <link href="http://mrbird.cc/Spring-Boot-Kafka.html"/>
    <id>http://mrbird.cc/Spring-Boot-Kafka.html</id>
    <published>2018-11-21T08:26:17.000Z</published>
    <updated>2019-03-27T02:20:01.126Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Apr 04 2019 14:23:37 GMT+0800 (GMT+08:00) --><p>Kafka是一个分布式的、可分区的、可复制的消息系统，下面是Kafka的几个基本术语：</p><ol><li><p>Kafka将消息以<strong>topic</strong>为单位进行归纳；</p></li><li><p>将向Kafka topic发布消息的程序成为<strong>producers</strong>；</p></li><li><p>将预订topics并消费消息的程序成为<strong>consumer</strong>；</p></li><li><p>Kafka以集群的方式运行，可以由一个或多个服务组成，每个服务叫做一个<strong>broker</strong>。</p></li></ol><a id="more"></a><p>producers通过网络将消息发送到Kafka集群，集群向消费者提供消息，如下图所示：</p><p><img src="img/140721072031172.png" alt="140721072031172.png"></p><p>创建一个topic时，可以指定<strong>partitions</strong>（分区）数目，partitions数越多，其吞吐量也越大，但是需要的资源也越多，同时也会导致更高的不可用性，kafka在接收到producers发送的消息之后，会根据均衡策略将消息存储到不同的partitions中：</p><p><img src="img/log_anatomy.png" alt="log_anatomy.png"></p><p>在每个partitions中，消息以顺序存储，最晚接收的的消息会最后被消费。</p><p>producers在向kafka集群发送消息的时候，可以通过指定partitions来发送到指定的partitions中。也可以通过指定均衡策略来将消息发送到不同的partitions中。如果不指定，就会采用默认的随机均衡策略，将消息随机的存储到不同的partitions中。</p><p>在consumer消费消息时，kafka使用offset来记录当前消费的位置：</p><p><img src="img/log_consumer.png" style="width:25rem"></p><p>在kafka的设计中，可以有多个不同的group来同时消费同一个topic下的消息，如图，我们有两个不同的group同时消费，他们的的消费的记录位置offset各不项目，不互相干扰。</p><p>对于一个group而言，consumer的数量不应该多于partitions的数量，因为在一个group中，每个partitions至多只能绑定到一个consumer上，即一个consumer可以消费多个partitions，一个partitions只能给一个consumer消费。因此，若一个group中的consumer数量大于partitions数量的话，多余的consumer将不会收到任何消息。</p><p><img src="img/consumer-groups.png" style="width:25rem"></p><h2 id="Kafka安装使用"><a href="#Kafka安装使用" class="headerlink" title="Kafka安装使用"></a>Kafka安装使用</h2><p>这里演示在Windows下Kafka安装与使用。Kafka下载地址：<a href="http://kafka.apache.org/downloads" target="_blank" rel="noopener">http://kafka.apache.org/downloads</a>，选择二进制文件下载（Binary downloads），然后解压即可。</p><p>Kafka的配置文件位于config目录下，因为Kafka集成了Zookeeper（Kafka存储消息的地方），所以config目录下除了有Kafka的配置文件server.properties外，还可以看到一个Zookeeper配置文件zookeeper.properties：</p><p><img src="img/QQ截图20190326103520.png" alt="QQ截图20190326103520.png"></p><p>打开server.properties，将<code>broker.id</code>的值修改为1，每个broker的id都必须设置为Integer类型，且不能重复。Zookeeper的配置保持默认即可。</p><p>接下来开始使用Kafka。</p><h3 id="启动Zookeeper"><a href="#启动Zookeeper" class="headerlink" title="启动Zookeeper"></a>启动Zookeeper</h3><p>在Windows下执行下面这些命令可能会出现<span style="color:red">找不到或无法加载主类</span>的问题，解决方案可参考：<a href="https://blog.csdn.net/cx2932350/article/details/78870135" target="_blank" rel="noopener">https://blog.csdn.net/cx2932350/article/details/78870135</a>。</p><p>在Kafka根目录下使用cmd执行下面这条命令，启动ZK：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bin\windows\zookeeper-server-start.bat config\zookeeper.properties</span><br></pre></td></tr></table></figure><p></p><p>在Linux下，可以使用后台进程的方式启动ZK：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bin/zookeeper-server-start.sh -daemon config/zookeeper.properties</span><br></pre></td></tr></table></figure><p></p><h3 id="启动Kafka"><a href="#启动Kafka" class="headerlink" title="启动Kafka"></a>启动Kafka</h3><p>执行下面这条命令启动Kafka：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bin\windows\kafka-server-start.bat config\server.properties</span><br></pre></td></tr></table></figure><p></p><p>Linux对应命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bin/kafka-server-start.sh config/server.properties</span><br></pre></td></tr></table></figure><p></p><p>当看到命令行打印如下信息，说明启动完毕:</p><p><img src="img/QQ截图20190326110506.png" alt="QQ截图20190326110506.png"></p><h3 id="创建Topic"><a href="#创建Topic" class="headerlink" title="创建Topic"></a>创建Topic</h3><p>执行下面这条命令创建一个Topic</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bin\windows\kafka-topics.bat --create --zookeeper localhost:2181 --replication-factor 1 --partitions 1 --topic <span class="built_in">test</span></span><br></pre></td></tr></table></figure><p></p><p>这条命令的意思是，创建一个Topic到ZK（指定ZK的地址），副本个数为1，分区数为1，Topic的名称为test。</p><p>Linux对应的命令为:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bin/kafka-topics.sh --create --zookeeper localhost:2181 --replication-factor 1 --partitions 1 --topic <span class="built_in">test</span></span><br></pre></td></tr></table></figure><p></p><p>创建好后我们可以查看Kafka里的Topic列表：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bin\windows\kafka-topics.bat --list --zookeeper localhost:2181</span><br></pre></td></tr></table></figure><p></p><p><img src="img/QQ截图20190326111559.png" alt="QQ截图20190326111559.png"></p><p>可看到目前只包含一个我们刚创建的test Topic。</p><p>Linux对应的命令为：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bin/kafka-topics.sh --list --zookeeper localhost:2181</span><br></pre></td></tr></table></figure><p></p><p>查看test Topic的具体信息：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bin\windows\kafka-topics.bat --describe --zookeeper localhost:2181 --topic <span class="built_in">test</span></span><br></pre></td></tr></table></figure><p></p><p><img src="img/QQ截图20190326111928.png" alt="QQ截图20190326111928.png"></p><p>Linux对应的命令为：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bin/kafka-topics.sh --describe --zookeeper localhost:2181 --topic <span class="built_in">test</span></span><br></pre></td></tr></table></figure><p></p><h3 id="生产消息和消费消息"><a href="#生产消息和消费消息" class="headerlink" title="生产消息和消费消息"></a>生产消息和消费消息</h3><p><strong>启动Producers</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bin\windows\kafka-console-producer.bat --broker-list localhost:9092 --topic <span class="built_in">test</span></span><br></pre></td></tr></table></figure><p></p><p>9092为生产者的默认端口号。这里启动了生产者，准备往test Topic里发送数据。</p><p>Linux下对应的命令为：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bin/kafka-console-producer.sh --broker-list localhost:9092 --topic <span class="built_in">test</span></span><br></pre></td></tr></table></figure><p></p><p><strong>启动Consumers</strong></p><p>接着启动一个消费者用于消费生产者生产的数据，新建一个cmd窗口，输入下面这条命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bin\windows\kafka-console-consumer.bat --bootstrap-server localhost:9092 --topic <span class="built_in">test</span> --from-beginning</span><br></pre></td></tr></table></figure><p></p><p><code>from-beginning</code>表示从头开始读取数据。</p><p>Linux下对应的命令为：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bin/kafka-console-consumer.sh --bootstrap-server localhost:9092 --topic <span class="built_in">test</span> --from-beginning</span><br></pre></td></tr></table></figure><p></p><p>启动好生产者和消费者后我们在生产者里生产几条数据:</p><p><img src="img/QQ截图20190326113911.png" alt="QQ截图20190326113911.png"></p><p>消费者成功接收到数据：</p><p><img src="img/QQ截图20190326113950.png" alt="QQ截图20190326113950.png"></p><h2 id="Spring-Boot整合Kafaka"><a href="#Spring-Boot整合Kafaka" class="headerlink" title="Spring Boot整合Kafaka"></a>Spring Boot整合Kafaka</h2><p>上面简单介绍了Kafka的使用，下面我们开始在Spring Boot里使用Kafka。</p><p>新建一个Spring Boot项目，版本为2.1.3.RELEASE，并引入如下依赖:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.kafka<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-kafka<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p></p><h3 id="生产者配置"><a href="#生产者配置" class="headerlink" title="生产者配置"></a>生产者配置</h3><p>新建一个Java配置类<code>KafkaProducerConfig</code>，用于配置生产者：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">KafkaProducerConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;spring.kafka.bootstrap-servers&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String bootstrapServers;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ProducerFactory&lt;String, String&gt; <span class="title">producerFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Map&lt;String, Object&gt; configProps = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        configProps.put(</span><br><span class="line">                ProducerConfig.BOOTSTRAP_SERVERS_CONFIG,</span><br><span class="line">                bootstrapServers);</span><br><span class="line">        configProps.put(</span><br><span class="line">                ProducerConfig.KEY_SERIALIZER_CLASS_CONFIG,</span><br><span class="line">                StringSerializer.class);</span><br><span class="line">        configProps.put(</span><br><span class="line">                ProducerConfig.VALUE_SERIALIZER_CLASS_CONFIG,</span><br><span class="line">                StringSerializer.class);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DefaultKafkaProducerFactory&lt;&gt;(configProps);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> KafkaTemplate&lt;String, String&gt; <span class="title">kafkaTemplate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> KafkaTemplate&lt;&gt;(producerFactory());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>首先我们配置了一个<code>producerFactory</code>，方法里配置了Kafka Producer实例的策略。<code>bootstrapServers</code>为Kafka生产者的地址，我们在配置文件application.yml里配置它：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  kafka:</span></span><br><span class="line"><span class="attr">    bootstrap-servers:</span> <span class="attr">localhost:9092</span></span><br></pre></td></tr></table></figure><p></p><p><code>ProducerConfig.KEY_SERIALIZER_CLASS_CONFIG</code>和<code>ProducerConfig.VALUE_SERIALIZER_CLASS_CONFIG</code>指定了key，value序列化策略，这里指定为Kafka提供的<code>StringSerializer</code>，因为我们暂时只发送简单的String类型的消息。</p><p>接着我们使用<code>producerFactory</code>配置了<code>kafkaTemplate</code>，其包含了发送消息的便捷方法，后面我们就用这个对象来发送消息。</p><h3 id="发布消息"><a href="#发布消息" class="headerlink" title="发布消息"></a>发布消息</h3><p>配置好生产者，我们就可以开始发布消息了。</p><p>新建一个<code>SendMessageController</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SendMessageController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> KafkaTemplate&lt;String, String&gt; kafkaTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"send/&#123;message&#125;"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">(@PathVariable String message)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.kafkaTemplate.send(<span class="string">"test"</span>, message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>我们注入了<code>kafkaTemplate</code>对象，key-value都为String类型，并通过它的<code>send</code>方法来发送消息。其中<code>test</code>为Topic的名称，上面我们已经使用命令创建过这个Topic了。</p><p><code>send</code>方法是一个异步方法，我们可以通过回调的方式来确定消息是否发送成功，我们改造<code>SendMessageController</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SendMessageController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Logger logger = LoggerFactory.getLogger(<span class="keyword">this</span>.getClass());</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> KafkaTemplate&lt;String, String&gt; kafkaTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"send/&#123;message&#125;"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">(@PathVariable String message)</span> </span>&#123;</span><br><span class="line">        ListenableFuture&lt;SendResult&lt;String, String&gt;&gt; future = <span class="keyword">this</span>.kafkaTemplate.send(<span class="string">"test"</span>, message);</span><br><span class="line">        future.addCallback(<span class="keyword">new</span> ListenableFutureCallback&lt;SendResult&lt;String, String&gt;&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSuccess</span><span class="params">(SendResult&lt;String, String&gt; result)</span> </span>&#123;</span><br><span class="line">                logger.info(<span class="string">"成功发送消息：&#123;&#125;，offset=[&#123;&#125;]"</span>, message, result.getRecordMetadata().offset());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onFailure</span><span class="params">(Throwable ex)</span> </span>&#123;</span><br><span class="line">                logger.error(<span class="string">"消息：&#123;&#125; 发送失败，原因：&#123;&#125;"</span>, message, ex.getMessage());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>消息发送成功后，会回调<code>onSuccess</code>方法，发送失败后回调<code>onFailure</code>方法。</p><h3 id="消费者配置"><a href="#消费者配置" class="headerlink" title="消费者配置"></a>消费者配置</h3><p>接着我们来配置消费者，新建一个Java配置类<code>KafkaConsumerConfig</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableKafka</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">KafkaConsumerConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;spring.kafka.bootstrap-servers&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String bootstrapServers;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;spring.kafka.consumer.group-id&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String consumerGroupId;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;spring.kafka.consumer.auto-offset-reset&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String autoOffsetReset;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ConsumerFactory&lt;String, String&gt; <span class="title">consumerFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Map&lt;String, Object&gt; props = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        props.put(</span><br><span class="line">                ConsumerConfig.BOOTSTRAP_SERVERS_CONFIG,</span><br><span class="line">                bootstrapServers);</span><br><span class="line">        props.put(</span><br><span class="line">                ConsumerConfig.GROUP_ID_CONFIG,</span><br><span class="line">                consumerGroupId);</span><br><span class="line">        props.put(</span><br><span class="line">                ConsumerConfig.AUTO_OFFSET_RESET_CONFIG,</span><br><span class="line">                autoOffsetReset);</span><br><span class="line">        props.put(</span><br><span class="line">                ConsumerConfig.KEY_DESERIALIZER_CLASS_CONFIG,</span><br><span class="line">                StringDeserializer.class);</span><br><span class="line">        props.put(</span><br><span class="line">                ConsumerConfig.VALUE_DESERIALIZER_CLASS_CONFIG,</span><br><span class="line">                StringDeserializer.class);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DefaultKafkaConsumerFactory&lt;&gt;(props);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ConcurrentKafkaListenerContainerFactory&lt;String, String&gt; <span class="title">kafkaListenerContainerFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ConcurrentKafkaListenerContainerFactory&lt;String, String&gt; factory</span><br><span class="line">                = <span class="keyword">new</span> ConcurrentKafkaListenerContainerFactory&lt;&gt;();</span><br><span class="line">        factory.setConsumerFactory(consumerFactory());</span><br><span class="line">        <span class="keyword">return</span> factory;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p><code>consumerGroupId</code>和<code>autoOffsetReset</code>需要在application.yml里配置：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  kafka:</span></span><br><span class="line"><span class="attr">    consumer:</span></span><br><span class="line"><span class="attr">      group-id:</span> <span class="string">test-consumer</span></span><br><span class="line"><span class="attr">      auto-offset-reset:</span> <span class="string">latest</span></span><br></pre></td></tr></table></figure><p></p><p>其中<code>group-id</code>将消费者进行分组（你也可以不进行分组），组名为<code>test-consumer</code>，并指定了消息读取策略，包含四个可选值：</p><p><img src="img/QQ截图20190326154735.png" alt="QQ截图20190326154735.png"></p><ul><li><p>earliest:当各分区下有已提交的offset时，从提交的offset开始消费；无提交的offset时，从头开始消费</p></li><li><p>latest:当各分区下有已提交的offset时，从提交的offset开始消费；无提交的offset时，消费新产生的该分区下的数据</p></li><li><p>none:topic各分区都存在已提交的offset时，从offset后开始消费；只要有一个分区不存在已提交的offset，则抛出异常</p></li><li><p>exception:直接抛出异常</p></li></ul><p>在<code>KafkaConsumerConfig</code>中我们配置了<code>ConsumerFactory</code>和<code>KafkaListenerContainerFactory</code>。当这两个Bean成功注册到Spring IOC容器中后，我们便可以使用<code>@KafkaListener</code>注解来监听消息了。</p><p>配置类上需要<code>@EnableKafka</code>注释才能在Spring托管Bean上检测<code>@KafkaListener</code>注解。</p><h3 id="消息消费"><a href="#消息消费" class="headerlink" title="消息消费"></a>消息消费</h3><p>配置好消费者，我们就可以开始消费消息了，新建<code>KafkaMessageListener</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">KafkaMessageListener</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Logger logger = LoggerFactory.getLogger(<span class="keyword">this</span>.getClass());</span><br><span class="line"></span><br><span class="line">    <span class="meta">@KafkaListener</span>(topics = <span class="string">"test"</span>, groupId = <span class="string">"test-consumer"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">listen</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        logger.info(<span class="string">"接收消息: &#123;&#125;"</span>, message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>我们通过<code>@KafkaListener</code>注解来监听名称为test的Topic，消费者分组的组名为<code>test-consumer</code>。</p><h3 id="演示"><a href="#演示" class="headerlink" title="演示"></a>演示</h3><p>启动Spring Boot项目，启动过程中，控制台会输出Kafka的配置，启动好后，访问<a href="http://localhost:8080/send/hello,mrbird" target="_blank" rel="noopener">http://localhost:8080/send/hello,mrbird</a>，控制台输出如下：</p><p><img src="img/QQ截图20190326155948.png" alt="QQ截图20190326155948.png"></p><h3 id="KafkaListener详解"><a href="#KafkaListener详解" class="headerlink" title="@KafkaListener详解"></a>@KafkaListener详解</h3><p><code>@KafkaListener</code>除了可以指定Topic名称和分组id外，我们还可以同时监听来自多个Topic的消息:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@KafkaListener</span>(topics = <span class="string">"topic1, topic2"</span>)</span><br></pre></td></tr></table></figure><p></p><p>我们还可以通过<code>@Header</code>注解来获取当前消息来自哪个分区（partitions）:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@KafkaListener</span>(topics = <span class="string">"test"</span>, groupId = <span class="string">"test-consumer"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">listen</span><span class="params">(@Payload String message,</span></span></span><br><span class="line"><span class="function"><span class="params">                   @Header(KafkaHeaders.RECEIVED_PARTITION_ID)</span> <span class="keyword">int</span> partition) </span>&#123;</span><br><span class="line">    logger.info(<span class="string">"接收消息: &#123;&#125;，partition：&#123;&#125;"</span>, message, partition);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>重启项目，再次访问<a href="http://localhost:8080/send/hello,mrbird" target="_blank" rel="noopener">http://localhost:8080/send/hello,mrbird</a>，控制台输出如下：</p><p><img src="img/QQ图片20190326162014.png" alt="QQ图片20190326162014.png"></p><p>因为我们没有进行分区，所以test Topic只有一个区，下标为0。</p><p>我们可以通过<code>@KafkaListener</code>来指定只接收来自特定分区的消息：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@KafkaListener</span>(groupId = <span class="string">"test-consumer"</span>,</span><br><span class="line">        topicPartitions = <span class="meta">@TopicPartition</span>(topic = <span class="string">"test"</span>,</span><br><span class="line">                partitionOffsets = &#123;</span><br><span class="line">                        <span class="meta">@PartitionOffset</span>(partition = <span class="string">"0"</span>, initialOffset = <span class="string">"0"</span>)</span><br><span class="line">            &#125;))</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">listen</span><span class="params">(@Payload String message,</span></span></span><br><span class="line"><span class="function"><span class="params">                   @Header(KafkaHeaders.RECEIVED_PARTITION_ID)</span> <span class="keyword">int</span> partition) </span>&#123;</span><br><span class="line">    logger.info(<span class="string">"接收消息: &#123;&#125;，partition：&#123;&#125;"</span>, message, partition);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>如果不需要指定<code>initialOffset</code>，上面代码可以简化为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@KafkaListener</span>(groupId = <span class="string">"test-consumer"</span>, </span><br><span class="line">	topicPartitions = <span class="meta">@TopicPartition</span>(topic = <span class="string">"test"</span>, partitions = &#123; <span class="string">"0"</span>, <span class="string">"1"</span> &#125;))</span><br></pre></td></tr></table></figure><h3 id="消息过滤器"><a href="#消息过滤器" class="headerlink" title="消息过滤器"></a>消息过滤器</h3><p>我们可以为消息监听添加过滤器来过滤一些特定的信息。我们在消费者配置类<code>KafkaConsumerConfig</code>的<code>kafkaListenerContainerFactory</code>方法里配置过滤规则：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ConcurrentKafkaListenerContainerFactory&lt;String, String&gt; <span class="title">kafkaListenerContainerFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ConcurrentKafkaListenerContainerFactory&lt;String, String&gt; factory</span><br><span class="line">            = <span class="keyword">new</span> ConcurrentKafkaListenerContainerFactory&lt;&gt;();</span><br><span class="line">    factory.setConsumerFactory(consumerFactory());</span><br><span class="line">    <span class="comment">// ------- 过滤配置 --------</span></span><br><span class="line">    factory.setRecordFilterStrategy(</span><br><span class="line">            r -&gt; r.value().contains(<span class="string">"fuck"</span>)</span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">return</span> factory;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p><code>setRecordFilterStrategy</code>接收<code>RecordFilterStrategy&lt;K, V&gt;</code>，他是一个函数式接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">RecordFilterStrategy</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">filter</span><span class="params">(ConsumerRecord&lt;K, V&gt; var1)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>所以我们用lambda表达式指定了上面这条规则，即如果消息内容包含<code>fuck</code>这个粗鄙之语的时候，则不接受消息。</p><p>配置好后我们重启项目，分别发送下面这两条请求：</p><ol><li><p><a href="http://localhost:8080/send/fuck,mrbird" target="_blank" rel="noopener">http://localhost:8080/send/fuck,mrbird</a></p></li><li><p><a href="http://localhost:8080/send/love,mrbird" target="_blank" rel="noopener">http://localhost:8080/send/love,mrbird</a></p></li></ol><p>观察控制台：</p><p><img src="img/QQ截图20190326163502.png" alt="QQ截图20190326163502.png"></p><p>可以看到，fuck,mrbird这条消息没有被接收。</p><h3 id="发送复杂的消息"><a href="#发送复杂的消息" class="headerlink" title="发送复杂的消息"></a>发送复杂的消息</h3><p>截至目前位置我们只发送了简单的字符串类型的消息，我们可以自定义消息转换器来发送复杂的消息。</p><p><strong>定义消息实体</strong></p><p>创建一个Message类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Message</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">6678420965611108427L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String from;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String message;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Message</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    	</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Message</span><span class="params">(String from, String message)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.from = from;</span><br><span class="line">        <span class="keyword">this</span>.message = message;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Message&#123;"</span> +</span><br><span class="line">                <span class="string">"from='"</span> + from + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">", message='"</span> + message + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// get set 略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p><strong>改造消息生产者配置</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">KafkaProducerConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;spring.kafka.bootstrap-servers&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String bootstrapServers;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ProducerFactory&lt;String, Message&gt; <span class="title">producerFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Map&lt;String, Object&gt; configProps = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        configProps.put(</span><br><span class="line">                ProducerConfig.BOOTSTRAP_SERVERS_CONFIG,</span><br><span class="line">                bootstrapServers);</span><br><span class="line">        configProps.put(</span><br><span class="line">                ProducerConfig.KEY_SERIALIZER_CLASS_CONFIG,</span><br><span class="line">                StringSerializer.class);</span><br><span class="line">        configProps.put(</span><br><span class="line">                ProducerConfig.VALUE_SERIALIZER_CLASS_CONFIG,</span><br><span class="line">                JsonSerializer.class);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DefaultKafkaProducerFactory&lt;&gt;(configProps);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> KafkaTemplate&lt;String, Message&gt; <span class="title">kafkaTemplate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> KafkaTemplate&lt;&gt;(producerFactory());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>我们将value序列化策略指定为了Kafka提供的<code>JsonSerializer</code>，并且kafkaTemplate返回类型为<code>KafkaTemplate&lt;String, Message&gt;</code>。</p><p><strong>发送新的消息</strong></p><p>在<code>SendMessageController</code>里发送复杂的消息:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> KafkaTemplate&lt;String, Message&gt; kafkaTemplate;</span><br><span class="line"></span><br><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"send/&#123;message&#125;"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendMessage</span><span class="params">(@PathVariable String message)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.kafkaTemplate.send(<span class="string">"test"</span>, <span class="keyword">new</span> Message(<span class="string">"mrbird"</span>, message));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p><strong>修改消费者配置</strong></p><p>修改消费者配置<code>KafkaConsumerConfig</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableKafka</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">KafkaConsumerConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;spring.kafka.bootstrap-servers&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String bootstrapServers;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;spring.kafka.consumer.group-id&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String consumerGroupId;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;spring.kafka.consumer.auto-offset-reset&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String autoOffsetReset;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ConsumerFactory&lt;String, Message&gt; <span class="title">consumerFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Map&lt;String, Object&gt; props = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        props.put(</span><br><span class="line">                ConsumerConfig.BOOTSTRAP_SERVERS_CONFIG,</span><br><span class="line">                bootstrapServers);</span><br><span class="line">        props.put(</span><br><span class="line">                ConsumerConfig.GROUP_ID_CONFIG,</span><br><span class="line">                consumerGroupId);</span><br><span class="line">        props.put(</span><br><span class="line">                ConsumerConfig.AUTO_OFFSET_RESET_CONFIG,</span><br><span class="line">                autoOffsetReset);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DefaultKafkaConsumerFactory&lt;&gt;(</span><br><span class="line">                props,</span><br><span class="line">                <span class="keyword">new</span> StringDeserializer(),</span><br><span class="line">                <span class="keyword">new</span> JsonDeserializer&lt;&gt;(Message.class));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ConcurrentKafkaListenerContainerFactory&lt;String, Message&gt; <span class="title">kafkaListenerContainerFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ConcurrentKafkaListenerContainerFactory&lt;String, Message&gt; factory</span><br><span class="line">                = <span class="keyword">new</span> ConcurrentKafkaListenerContainerFactory&lt;&gt;();</span><br><span class="line">        factory.setConsumerFactory(consumerFactory());</span><br><span class="line">        <span class="keyword">return</span> factory;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p><strong>修改消息监听</strong></p><p>修改<code>KafkaMessageListener</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@KafkaListener</span>(topics = <span class="string">"test"</span>, groupId = <span class="string">"test-consumer"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">listen</span><span class="params">(Message message)</span> </span>&#123;</span><br><span class="line">    logger.info(<span class="string">"接收消息: &#123;&#125;"</span>, message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>重启项目，访问<a href="http://localhost:8080/send/hello" target="_blank" rel="noopener">http://localhost:8080/send/hello</a>，控制台输出如下：</p><p><img src="img/QQ截图20190326171125.png" alt="QQ截图20190326171125.png"></p><h3 id="更多配置"><a href="#更多配置" class="headerlink" title="更多配置"></a>更多配置</h3><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">spring.kafka.admin.client-id=</span> <span class="comment"># ID to pass to the server when making requests. Used for server-side logging.</span></span><br><span class="line"><span class="string">spring.kafka.admin.fail-fast=false</span> <span class="comment"># Whether to fail fast if the broker is not available on startup.</span></span><br><span class="line"><span class="string">spring.kafka.admin.properties.*=</span> <span class="comment"># Additional admin-specific properties used to configure the client.</span></span><br><span class="line"><span class="string">spring.kafka.admin.ssl.key-password=</span> <span class="comment"># Password of the private key in the key store file.</span></span><br><span class="line"><span class="string">spring.kafka.admin.ssl.key-store-location=</span> <span class="comment"># Location of the key store file.</span></span><br><span class="line"><span class="string">spring.kafka.admin.ssl.key-store-password=</span> <span class="comment"># Store password for the key store file.</span></span><br><span class="line"><span class="string">spring.kafka.admin.ssl.key-store-type=</span> <span class="comment"># Type of the key store.</span></span><br><span class="line"><span class="string">spring.kafka.admin.ssl.protocol=</span> <span class="comment"># SSL protocol to use.</span></span><br><span class="line"><span class="string">spring.kafka.admin.ssl.trust-store-location=</span> <span class="comment"># Location of the trust store file.</span></span><br><span class="line"><span class="string">spring.kafka.admin.ssl.trust-store-password=</span> <span class="comment"># Store password for the trust store file.</span></span><br><span class="line"><span class="string">spring.kafka.admin.ssl.trust-store-type=</span> <span class="comment"># Type of the trust store.</span></span><br><span class="line"><span class="string">spring.kafka.bootstrap-servers=</span> <span class="comment"># Comma-delimited list of host:port pairs to use for establishing the initial connections to the Kafka cluster. Applies to all components unless overridden.</span></span><br><span class="line"><span class="string">spring.kafka.client-id=</span> <span class="comment"># ID to pass to the server when making requests. Used for server-side logging.</span></span><br><span class="line"><span class="string">spring.kafka.consumer.auto-commit-interval=</span> <span class="comment"># Frequency with which the consumer offsets are auto-committed to Kafka if 'enable.auto.commit' is set to true.</span></span><br><span class="line"><span class="string">spring.kafka.consumer.auto-offset-reset=</span> <span class="comment"># What to do when there is no initial offset in Kafka or if the current offset no longer exists on the server.</span></span><br><span class="line"><span class="string">spring.kafka.consumer.bootstrap-servers=</span> <span class="comment"># Comma-delimited list of host:port pairs to use for establishing the initial connections to the Kafka cluster. Overrides the global property, for consumers.</span></span><br><span class="line"><span class="string">spring.kafka.consumer.client-id=</span> <span class="comment"># ID to pass to the server when making requests. Used for server-side logging.</span></span><br><span class="line"><span class="string">spring.kafka.consumer.enable-auto-commit=</span> <span class="comment"># Whether the consumer's offset is periodically committed in the background.</span></span><br><span class="line"><span class="string">spring.kafka.consumer.fetch-max-wait=</span> <span class="comment"># Maximum amount of time the server blocks before answering the fetch request if there isn't sufficient data to immediately satisfy the requirement given by "fetch-min-size".</span></span><br><span class="line"><span class="string">spring.kafka.consumer.fetch-min-size=</span> <span class="comment"># Minimum amount of data the server should return for a fetch request.</span></span><br><span class="line"><span class="string">spring.kafka.consumer.group-id=</span> <span class="comment"># Unique string that identifies the consumer group to which this consumer belongs.</span></span><br><span class="line"><span class="string">spring.kafka.consumer.heartbeat-interval=</span> <span class="comment"># Expected time between heartbeats to the consumer coordinator.</span></span><br><span class="line"><span class="string">spring.kafka.consumer.key-deserializer=</span> <span class="comment"># Deserializer class for keys.</span></span><br><span class="line"><span class="string">spring.kafka.consumer.max-poll-records=</span> <span class="comment"># Maximum number of records returned in a single call to poll().</span></span><br><span class="line"><span class="string">spring.kafka.consumer.properties.*=</span> <span class="comment"># Additional consumer-specific properties used to configure the client.</span></span><br><span class="line"><span class="string">spring.kafka.consumer.ssl.key-password=</span> <span class="comment"># Password of the private key in the key store file.</span></span><br><span class="line"><span class="string">spring.kafka.consumer.ssl.key-store-location=</span> <span class="comment"># Location of the key store file.</span></span><br><span class="line"><span class="string">spring.kafka.consumer.ssl.key-store-password=</span> <span class="comment"># Store password for the key store file.</span></span><br><span class="line"><span class="string">spring.kafka.consumer.ssl.key-store-type=</span> <span class="comment"># Type of the key store.</span></span><br><span class="line"><span class="string">spring.kafka.consumer.ssl.protocol=</span> <span class="comment"># SSL protocol to use.</span></span><br><span class="line"><span class="string">spring.kafka.consumer.ssl.trust-store-location=</span> <span class="comment"># Location of the trust store file.</span></span><br><span class="line"><span class="string">spring.kafka.consumer.ssl.trust-store-password=</span> <span class="comment"># Store password for the trust store file.</span></span><br><span class="line"><span class="string">spring.kafka.consumer.ssl.trust-store-type=</span> <span class="comment"># Type of the trust store.</span></span><br><span class="line"><span class="string">spring.kafka.consumer.value-deserializer=</span> <span class="comment"># Deserializer class for values.</span></span><br><span class="line"><span class="string">spring.kafka.jaas.control-flag=required</span> <span class="comment"># Control flag for login configuration.</span></span><br><span class="line"><span class="string">spring.kafka.jaas.enabled=false</span> <span class="comment"># Whether to enable JAAS configuration.</span></span><br><span class="line"><span class="string">spring.kafka.jaas.login-module=com.sun.security.auth.module.Krb5LoginModule</span> <span class="comment"># Login module.</span></span><br><span class="line"><span class="string">spring.kafka.jaas.options=</span> <span class="comment"># Additional JAAS options.</span></span><br><span class="line"><span class="string">spring.kafka.listener.ack-count=</span> <span class="comment"># Number of records between offset commits when ackMode is "COUNT" or "COUNT_TIME".</span></span><br><span class="line"><span class="string">spring.kafka.listener.ack-mode=</span> <span class="comment"># Listener AckMode. See the spring-kafka documentation.</span></span><br><span class="line"><span class="string">spring.kafka.listener.ack-time=</span> <span class="comment"># Time between offset commits when ackMode is "TIME" or "COUNT_TIME".</span></span><br><span class="line"><span class="string">spring.kafka.listener.client-id=</span> <span class="comment"># Prefix for the listener's consumer client.id property.</span></span><br><span class="line"><span class="string">spring.kafka.listener.concurrency=</span> <span class="comment"># Number of threads to run in the listener containers.</span></span><br><span class="line"><span class="string">spring.kafka.listener.idle-event-interval=</span> <span class="comment"># Time between publishing idle consumer events (no data received).</span></span><br><span class="line"><span class="string">spring.kafka.listener.log-container-config=</span> <span class="comment"># Whether to log the container configuration during initialization (INFO level).</span></span><br><span class="line"><span class="string">spring.kafka.listener.monitor-interval=</span> <span class="comment"># Time between checks for non-responsive consumers. If a duration suffix is not specified, seconds will be used.</span></span><br><span class="line"><span class="string">spring.kafka.listener.no-poll-threshold=</span> <span class="comment"># Multiplier applied to "pollTimeout" to determine if a consumer is non-responsive.</span></span><br><span class="line"><span class="string">spring.kafka.listener.poll-timeout=</span> <span class="comment"># Timeout to use when polling the consumer.</span></span><br><span class="line"><span class="string">spring.kafka.listener.type=single</span> <span class="comment"># Listener type.</span></span><br><span class="line"><span class="string">spring.kafka.producer.acks=</span> <span class="comment"># Number of acknowledgments the producer requires the leader to have received before considering a request complete.</span></span><br><span class="line"><span class="string">spring.kafka.producer.batch-size=</span> <span class="comment"># Default batch size.</span></span><br><span class="line"><span class="string">spring.kafka.producer.bootstrap-servers=</span> <span class="comment"># Comma-delimited list of host:port pairs to use for establishing the initial connections to the Kafka cluster. Overrides the global property, for producers.</span></span><br><span class="line"><span class="string">spring.kafka.producer.buffer-memory=</span> <span class="comment"># Total memory size the producer can use to buffer records waiting to be sent to the server.</span></span><br><span class="line"><span class="string">spring.kafka.producer.client-id=</span> <span class="comment"># ID to pass to the server when making requests. Used for server-side logging.</span></span><br><span class="line"><span class="string">spring.kafka.producer.compression-type=</span> <span class="comment"># Compression type for all data generated by the producer.</span></span><br><span class="line"><span class="string">spring.kafka.producer.key-serializer=</span> <span class="comment"># Serializer class for keys.</span></span><br><span class="line"><span class="string">spring.kafka.producer.properties.*=</span> <span class="comment"># Additional producer-specific properties used to configure the client.</span></span><br><span class="line"><span class="string">spring.kafka.producer.retries=</span> <span class="comment"># When greater than zero, enables retrying of failed sends.</span></span><br><span class="line"><span class="string">spring.kafka.producer.ssl.key-password=</span> <span class="comment"># Password of the private key in the key store file.</span></span><br><span class="line"><span class="string">spring.kafka.producer.ssl.key-store-location=</span> <span class="comment"># Location of the key store file.</span></span><br><span class="line"><span class="string">spring.kafka.producer.ssl.key-store-password=</span> <span class="comment"># Store password for the key store file.</span></span><br><span class="line"><span class="string">spring.kafka.producer.ssl.key-store-type=</span> <span class="comment"># Type of the key store.</span></span><br><span class="line"><span class="string">spring.kafka.producer.ssl.protocol=</span> <span class="comment"># SSL protocol to use.</span></span><br><span class="line"><span class="string">spring.kafka.producer.ssl.trust-store-location=</span> <span class="comment"># Location of the trust store file.</span></span><br><span class="line"><span class="string">spring.kafka.producer.ssl.trust-store-password=</span> <span class="comment"># Store password for the trust store file.</span></span><br><span class="line"><span class="string">spring.kafka.producer.ssl.trust-store-type=</span> <span class="comment"># Type of the trust store.</span></span><br><span class="line"><span class="string">spring.kafka.producer.transaction-id-prefix=</span> <span class="comment"># When non empty, enables transaction support for producer.</span></span><br><span class="line"><span class="string">spring.kafka.producer.value-serializer=</span> <span class="comment"># Serializer class for values.</span></span><br><span class="line"><span class="string">spring.kafka.properties.*=</span> <span class="comment"># Additional properties, common to producers and consumers, used to configure the client.</span></span><br><span class="line"><span class="string">spring.kafka.ssl.key-password=</span> <span class="comment"># Password of the private key in the key store file.</span></span><br><span class="line"><span class="string">spring.kafka.ssl.key-store-location=</span> <span class="comment"># Location of the key store file.</span></span><br><span class="line"><span class="string">spring.kafka.ssl.key-store-password=</span> <span class="comment"># Store password for the key store file.</span></span><br><span class="line"><span class="string">spring.kafka.ssl.key-store-type=</span> <span class="comment"># Type of the key store.</span></span><br><span class="line"><span class="string">spring.kafka.ssl.protocol=</span> <span class="comment"># SSL protocol to use.</span></span><br><span class="line"><span class="string">spring.kafka.ssl.trust-store-location=</span> <span class="comment"># Location of the trust store file.</span></span><br><span class="line"><span class="string">spring.kafka.ssl.trust-store-password=</span> <span class="comment"># Store password for the trust store file.</span></span><br><span class="line"><span class="string">spring.kafka.ssl.trust-store-type=</span> <span class="comment"># Type of the trust store.</span></span><br><span class="line"><span class="string">spring.kafka.streams.application-id=</span> <span class="comment"># Kafka streams application.id property; default spring.application.name.</span></span><br><span class="line"><span class="string">spring.kafka.streams.auto-startup=true</span> <span class="comment"># Whether or not to auto-start the streams factory bean.</span></span><br><span class="line"><span class="string">spring.kafka.streams.bootstrap-servers=</span> <span class="comment"># Comma-delimited list of host:port pairs to use for establishing the initial connections to the Kafka cluster. Overrides the global property, for streams.</span></span><br><span class="line"><span class="string">spring.kafka.streams.cache-max-size-buffering=</span> <span class="comment"># Maximum memory size to be used for buffering across all threads.</span></span><br><span class="line"><span class="string">spring.kafka.streams.client-id=</span> <span class="comment"># ID to pass to the server when making requests. Used for server-side logging.</span></span><br><span class="line"><span class="string">spring.kafka.streams.properties.*=</span> <span class="comment"># Additional Kafka properties used to configure the streams.</span></span><br><span class="line"><span class="string">spring.kafka.streams.replication-factor=</span> <span class="comment"># The replication factor for change log topics and repartition topics created by the stream processing application.</span></span><br><span class="line"><span class="string">spring.kafka.streams.ssl.key-password=</span> <span class="comment"># Password of the private key in the key store file.</span></span><br><span class="line"><span class="string">spring.kafka.streams.ssl.key-store-location=</span> <span class="comment"># Location of the key store file.</span></span><br><span class="line"><span class="string">spring.kafka.streams.ssl.key-store-password=</span> <span class="comment"># Store password for the key store file.</span></span><br><span class="line"><span class="string">spring.kafka.streams.ssl.key-store-type=</span> <span class="comment"># Type of the key store.</span></span><br><span class="line"><span class="string">spring.kafka.streams.ssl.protocol=</span> <span class="comment"># SSL protocol to use.</span></span><br><span class="line"><span class="string">spring.kafka.streams.ssl.trust-store-location=</span> <span class="comment"># Location of the trust store file.</span></span><br><span class="line"><span class="string">spring.kafka.streams.ssl.trust-store-password=</span> <span class="comment"># Store password for the trust store file.</span></span><br><span class="line"><span class="string">spring.kafka.streams.ssl.trust-store-type=</span> <span class="comment"># Type of the trust store.</span></span><br><span class="line"><span class="string">spring.kafka.streams.state-dir=</span> <span class="comment"># Directory location for the state store.</span></span><br><span class="line"><span class="string">spring.kafka.template.default-topic=</span> <span class="comment"># Default topic to which messages are sent.</span></span><br></pre></td></tr></table></figure><p>源码链接：<a href="https://github.com/wuyouzhuguli/SpringAll/tree/master/54.Spring-Boot-Kafka" target="_blank" rel="noopener">https://github.com/wuyouzhuguli/SpringAll/tree/master/54.Spring-Boot-Kafka</a></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Thu Apr 04 2019 14:23:37 GMT+0800 (GMT+08:00) --&gt;&lt;p&gt;Kafka是一个分布式的、可分区的、可复制的消息系统，下面是Kafka的几个基本术语：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;&lt;p&gt;Kafka将消息以&lt;strong&gt;topic&lt;/strong&gt;为单位进行归纳；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;将向Kafka topic发布消息的程序成为&lt;strong&gt;producers&lt;/strong&gt;；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;将预订topics并消费消息的程序成为&lt;strong&gt;consumer&lt;/strong&gt;；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Kafka以集群的方式运行，可以由一个或多个服务组成，每个服务叫做一个&lt;strong&gt;broker&lt;/strong&gt;。&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;
    
    </summary>
    
    
      <category term="Spring Boot" scheme="http://mrbird.cc/tags/Spring-Boot/"/>
    
      <category term="Kafka" scheme="http://mrbird.cc/tags/Kafka/"/>
    
  </entry>
  
  <entry>
    <title>Spring Boot 2.0 WebFlux编程</title>
    <link href="http://mrbird.cc/Spring-Boot-2-0-WebFlux.html"/>
    <id>http://mrbird.cc/Spring-Boot-2-0-WebFlux.html</id>
    <published>2018-11-19T07:25:54.000Z</published>
    <updated>2019-04-04T02:43:35.816Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Apr 04 2019 14:23:36 GMT+0800 (GMT+08:00) --><p>Spring MVC Web架构是基于阻塞式Servlet API构建的。Servlet 3.1后提供了非阻塞API，Spring 5.0后基于这些API构建了一套全新的非阻塞Web框架 —— WebFlux。Spring Boot 2.0基于Spring 5.0构建，所以要在Spring Boot中使用WebFlux架构，版本必须大于2.0。</p><p>通过下面这张图了解下Spring MVC和Spring WebFlux的区别：<a id="more"></a></p><p><img src="img/diagram-boot-reactor.svg" style="width:35rem"> <a href="img/https://www.cnblogs.com/javabg/p/7976977.html">https://www.cnblogs.com/javabg/p/7976977.html</a></p><p>可以看到，Spring WebFlux是非阻塞式的，支持 Reactive Streams背压，并在Netty，Undertow和Servlet 3.1+容器等服务器上运行。其目前只支持非关系型数据库，如Mongo，Redis等。非阻塞式的编程模型可以提高程序的并发量，提升性能和吞吐量。</p><h2 id="异步Servlet"><a href="#异步Servlet" class="headerlink" title="异步Servlet"></a>异步Servlet</h2><p>既然WebFlux是基于异步Servelt API构建的，那么我们先来看看什么是异步Servlet。</p><p>使用IDEA创建一个传统的Java Web应用（可以参考<a href="https://www.cnblogs.com/javabg/p/7976977.html" target="_blank" rel="noopener">https://www.cnblogs.com/javabg/p/7976977.html</a>），然后创建一个<code>SyncServlet</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebServlet</span>(urlPatterns = <span class="string">"/sync"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SyncServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">7583536145022393360L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Logger log = Logger.getLogger(SyncServlet.class.getName());</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">this</span>.execute(request, response);</span><br><span class="line">        log.info(<span class="string">"总耗时："</span> + (System.currentTimeMillis() - start) + <span class="string">"ms"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            response.getWriter().append(<span class="string">"hello"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p><code>doGet</code>方法中线程阻塞2秒，然后打印hello。部署项目到Tomcat，context-path为/servlet，启动后访问<a href="http://localhost:8080/servlet/sync" target="_blank" rel="noopener">http://localhost:8080/servlet/sync</a>:</p><p><img src="img/QQ截图20190401110755.png" alt="QQ截图20190401110755.png"></p><p>传统的Servlet API是阻塞的，<code>log.info(&quot;总耗时：&quot; + (System.currentTimeMillis() - start) + &quot;ms&quot;)</code>这行代码必须等待<code>this.execute()</code>执行完毕后才开始执行。</p><p>接下来看看非阻塞Servlet API是怎么搞的。新建一个<code>AsyncServlet</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebServlet</span>(urlPatterns = <span class="string">"/async"</span>, asyncSupported = <span class="keyword">true</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AsyncServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">393375716683413545L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Logger log = Logger.getLogger(AsyncServlet.class.getName());</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">        AsyncContext asyncContext = request.startAsync();</span><br><span class="line"></span><br><span class="line">        CompletableFuture.runAsync(() -&gt; execute(</span><br><span class="line">            asyncContext, </span><br><span class="line">            asyncContext.getRequest(), </span><br><span class="line">            asyncContext.getResponse())</span><br><span class="line">        );</span><br><span class="line">        log.info(<span class="string">"总耗时："</span> + (System.currentTimeMillis() - start) + <span class="string">"ms"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(AsyncContext asyncContext, ServletRequest request, ServletResponse response)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            response.getWriter().append(<span class="string">"hello"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        asyncContext.complete();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>在类上使用<code>@WebServlet(asyncSupported = true)</code>开启异步支持，通过<code>AsyncContext asyncContext = request.startAsync();</code>获取异步上下文<code>AsyncContext</code>，<code>AsyncContext</code>的<code>complete</code>方法用于标识异步调用结束。<code>CompletableFuture</code>为Java 8提供的<code>Future</code>接口实现类，可以方便的处理异步调用。</p><p>启动项目，访问<a href="http://localhost:8080/servlet/async" target="_blank" rel="noopener">http://localhost:8080/servlet/async</a>，响应耗时也在2秒左右，但是这个过程是异步的，查看控制台日志就可以证明这点：</p><p><img src="img/QQ截图20190401113446.png" alt="QQ截图20190401113446.png"></p><p>所以，异步调用适用于那些对方法返回值没有影响的操作，比如异步记录用户操作日志等。如果方法的返回值依赖于异步调用的结果，那么方法耗时在同步和异步上是没有区别的。</p><h2 id="Mono和Flux"><a href="#Mono和Flux" class="headerlink" title="Mono和Flux"></a>Mono和Flux</h2><p>了解了异步Servlet后，我们回到WebFlux，新建一个SpringBoot程序，版本为2.1.3.RELEASE，并引入<code>spring-boot-starter-webflux</code>依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-webflux<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p></p><p><a href="https://github.com/reactor/reactor" target="_blank" rel="noopener">Reactor</a> 是Spring WebFlux所使用的响应式库，其提供了两个特殊的类Mono和Flux。</p><p>Mono和Flux在发布订阅模式中都属于发布者（不清楚的可以参考<a href="/Java-9-Flow-API-Learn.html">Java 9 Flow API学习</a>），查看源码会发现它们都实现了Publisher接口。</p><p>Mono表示0 ~ 1个元素的数据发布者，Flux表示 0 ~ N个元素的数据发布者。我们可以通过一个例子来了解Mono和Flux，创建<code>MonoFluxTest</code>类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MonoFluxTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Subscriber&lt;Integer&gt; subscriber = <span class="keyword">new</span> Subscriber&lt;Integer&gt;() &#123;</span><br><span class="line">            <span class="keyword">private</span> Subscription subscription;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSubscribe</span><span class="params">(Subscription subscription)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">this</span>.subscription = subscription;</span><br><span class="line">                <span class="keyword">this</span>.subscription.request(<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(Integer item)</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"接受到数据: "</span> + item);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    TimeUnit.SECONDS.sleep(<span class="number">3</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">this</span>.subscription.request(<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable throwable)</span> </span>&#123;</span><br><span class="line">                throwable.printStackTrace();</span><br><span class="line">                <span class="keyword">this</span>.subscription.cancel();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onComplete</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"处理完了!"</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;;</span><br><span class="line">        </span><br><span class="line">        String[] strs = &#123;<span class="string">"1"</span>, <span class="string">"2"</span>, <span class="string">"3"</span>&#125;;</span><br><span class="line">        Flux.fromArray(strs).map(Integer::parseInt).subscribe(subscriber);</span><br><span class="line">        Mono.fromSupplier(() -&gt; <span class="number">1</span>).map(s -&gt; s + <span class="number">1</span>).subscribe(subscriber);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序首先创建了一个订阅者（参考<a href="/Java-9-Flow-API-Learn.html">Java 9 Flow API学习</a>），然后分别使用<code>Flux.fromArray</code>和<code>Mono.fromSupplier</code>构造了<code>Flux</code>类型发布者和<code>Mono</code>类型发布者，并和订阅者保持订阅关系。</p><p>运行main方法，控制台输出：</p><p><img src="img/QQ截图20190401134616.png" alt="QQ截图20190401134616.png"></p><p>了解了Mono和Flux后，我们新建一个TestController：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestController</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Logger logger = LoggerFactory.getLogger(<span class="keyword">this</span>.getClass());</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"sync"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">sync</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        logger.info(<span class="string">"sync method start"</span>);</span><br><span class="line">        String result = <span class="keyword">this</span>.execute();</span><br><span class="line">        logger.info(<span class="string">"sync method end"</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"async/mono"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Mono&lt;String&gt; <span class="title">asyncMono</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        logger.info(<span class="string">"async method start"</span>);</span><br><span class="line">        Mono&lt;String&gt; result = Mono.fromSupplier(<span class="keyword">this</span>::execute);</span><br><span class="line">        logger.info(<span class="string">"async method end"</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"hello"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p><code>execute</code>方法返回一个值hello，所以可以使用Mono来处理返回值，使它成为一个异步方法。<code>asyncMono</code>方法返回<code>Mono&lt;String&gt;</code>类型，也就是一个String类型的数据发布者，我们不用去手动处理订阅关系，Spring会帮我们处理，我们直接返回即可。</p><p>启动项目，可以看到WebFlux默认使用的是Netty服务器：</p><p><img src="img/QQ截图20190401135918.png" alt="QQ截图20190401135918.png"></p><p>分别访问<a href="http://localhost:8080/sync" target="_blank" rel="noopener">http://localhost:8080/sync</a>和<a href="http://localhost:8080/async/mono" target="_blank" rel="noopener">http://localhost:8080/async/mono</a>，控制台输出如下：</p><p><img src="img/QQ截图20190401140024.png" alt="QQ截图20190401140024.png"></p><p><img src="img/QQ截图20190401140239.png" alt="QQ截图20190401140239.png"></p><p>可以看到<code>asyncMono</code>方法里的<code>Mono&lt;String&gt; result = Mono.fromSupplier(this::execute)</code>是异步非阻塞的，并且<a href="http://localhost:8080/async/mono" target="_blank" rel="noopener">http://localhost:8080/async/mono</a>返回的值为字符串hello。</p><p>下面我们来看一个返回类型为<code>Flux&lt;String&gt;</code>类型的例子。</p><h2 id="Server-Sent-Events"><a href="#Server-Sent-Events" class="headerlink" title="Server Sent Events"></a>Server Sent Events</h2><p>返回值类型为<code>Flux</code>的时候，它是一个数据流，不是一次性数据包，服务端会不断地（假如Flux数据长度大于1）往客户端发送数据。这时，客户端不会关闭连接，会一直等着服务器发过来的新的数据流。这种模式称为Server-Sent Events。</p><p>在TestController新增一个<code>asyncFlux</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping</span>(value = <span class="string">"async/flux"</span>, produces = MediaType.TEXT_EVENT_STREAM_VALUE)</span><br><span class="line"><span class="function"><span class="keyword">public</span> Flux&lt;String&gt; <span class="title">asyncFlux</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    logger.info(<span class="string">"async method start"</span>);</span><br><span class="line">    Flux&lt;String&gt; result = Flux.fromStream(IntStream.range(<span class="number">1</span>, <span class="number">5</span>).mapToObj(i -&gt; &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"int value："</span> + i;</span><br><span class="line">    &#125;));</span><br><span class="line">    logger.info(<span class="string">"async method end"</span>);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p><code>@GetMapping</code>必须通过<code>produces</code>指定数据类型为<code>text/event-stream</code>，重启项目，访问<a href="http://localhost:8080/async/flux" target="_blank" rel="noopener">http://localhost:8080/async/flux</a>：</p><p><img src="img/flux.gif" alt="flux.gif"></p><p>前端可以通过H5的<code>EventSource</code>来接收。</p><p>引入thymeleaf依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-thymeleaf<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p></p><p>然后在resources/templates下新建flux.html：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>test sse<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> es = <span class="keyword">new</span> EventSource(<span class="string">"async/flux"</span>);</span></span><br><span class="line"><span class="javascript">    es.onmessage = <span class="function"><span class="keyword">function</span> (<span class="params">evt</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(evt.data);</span></span><br><span class="line"><span class="javascript">        <span class="keyword">if</span> (evt.data === <span class="string">"int value：4"</span>) &#123;</span></span><br><span class="line"><span class="undefined">            es.close();</span></span><br><span class="line"><span class="undefined">        &#125;</span></span><br><span class="line"><span class="undefined">    &#125;;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p></p><p>需要调用<code>es.close()</code>来关闭事件流，不然<code>EventSource</code>会在数据传输完毕会自动重连，这样就会不间断的调用<code>localhost:8080/async/flux</code>请求了。</p><p>添加一个ViewController，用来访问flux.html：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ViewController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"flux"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">flux</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"flux"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>重启项目，访问<a href="http://localhost:8080/flux" target="_blank" rel="noopener">http://localhost:8080/flux</a>，浏览器控制台输出如下所示:</p><p><img src="img/asfasfdvvasd.gif" alt="asfasfdvvasd.gif"></p><h2 id="Mono-Flux常用方法"><a href="#Mono-Flux常用方法" class="headerlink" title="Mono,Flux常用方法"></a>Mono,Flux常用方法</h2><p>通过上面的例子，我们简单了解了Mono和Flux的用法和区别，下面我们列举一些它们的常用方法。</p><h3 id="源头操作"><a href="#源头操作" class="headerlink" title="源头操作"></a>源头操作</h3><p><strong>Flux</strong></p><p>可以通过Flux类的静态方法来生成：</p><ol><li><p><code>just()</code>：可以指定序列中包含的全部元素。创建出来的 Flux 序列在发布这些元素之后会自动结束。</p></li><li><p><code>fromArray()</code>，<code>fromIterable()</code>和 <code>fromStream()</code>：可以从一个数组、Iterable 对象或 Stream 对象中创建 Flux 对象。</p></li><li><p><code>empty()</code>：创建一个不包含任何元素，只发布结束消息的序列。</p></li><li><p><code>error(Throwable error)</code>：创建一个只包含错误消息的序列。</p></li><li><p><code>never()</code>：创建一个不包含任何消息通知的序列。</p></li><li><p><code>range(int start, int count)</code>：创建包含从 start 起始的 count 个数量的 Integer 对象的序列。</p></li><li><p><code>interval(Duration period)</code>和 <code>interval(Duration delay, Duration period)</code>：创建一个包含了从 0 开始递增的 Long 对象的序列。其中包含的元素按照指定的间隔来发布。除了间隔时间之外，还可以指定起始元素发布之前的延迟时间。</p></li></ol><p>举些例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    Flux.just(<span class="string">"Hello"</span>, <span class="string">"World"</span>).subscribe(System.out::println);</span><br><span class="line">    Flux.fromArray(<span class="keyword">new</span> Integer[] &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;).subscribe(System.out::println);</span><br><span class="line">    Flux.empty().subscribe(System.out::println);</span><br><span class="line">    Flux.range(<span class="number">1</span>, <span class="number">4</span>).subscribe(System.out::println);</span><br><span class="line">    Flux.interval(Duration.of(<span class="number">1</span>, ChronoUnit.SECONDS)).subscribe(System.out::println);</span><br><span class="line">    <span class="comment">// 线程延迟关闭，不然最后一个例子木有输出</span></span><br><span class="line">    Thread.currentThread().join(<span class="number">10000</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>输出如下所示： <img src="img/QQ截图20190401170048.png" alt="QQ截图20190401170048.png"></p><p>上面的这些静态方法适合于简单的Flux序列生成，当序列的生成需要复杂的逻辑时，则应该使用<code>generate()</code>或<code>create()</code>方法。</p><p><strong>generate()</strong></p><p>generate()方法通过同步和逐一的方式来产生 Flux 序列。序列的产生是通过调用所提供的 SynchronousSink 对象的 next()，complete()和 error(Throwable)方法来完成的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Flux.generate(sink -&gt; &#123;</span><br><span class="line">    sink.next(<span class="string">"Hello"</span>);</span><br><span class="line">    sink.complete();</span><br><span class="line">&#125;).subscribe(System.out::println);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> Random random = <span class="keyword">new</span> Random();</span><br><span class="line">Flux.generate(ArrayList::<span class="keyword">new</span>, (list, sink) -&gt; &#123;</span><br><span class="line">    <span class="keyword">int</span> value = random.nextInt(<span class="number">100</span>);</span><br><span class="line">    list.add(value);</span><br><span class="line">    sink.next(value);</span><br><span class="line">    <span class="keyword">if</span> (list.size() == <span class="number">10</span>) &#123;</span><br><span class="line">        sink.complete();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> list;</span><br><span class="line">&#125;).subscribe(System.out::println);</span><br></pre></td></tr></table></figure><p></p><p>输出如下所示:</p><p><img src="img/QQ截图20190401170950.png" alt="QQ截图20190401170950.png"></p><p>如果不调用 complete()方法，所产生的是一个无限序列。</p><p><strong>create()</strong></p><p>create()方法与 generate()方法的不同之处在于所使用的是 FluxSink 对象。FluxSink 支持同步和异步的消息产生，并且可以在一次调用中产生多个元素：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Flux.create(sink -&gt; &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        sink.next(i);</span><br><span class="line">    &#125;</span><br><span class="line">    sink.complete();</span><br><span class="line">&#125;).subscribe(System.out::println);</span><br></pre></td></tr></table></figure><p><strong>Mono</strong></p><p>Mono 的创建方式与之前介绍的 Flux 比较相似。Mono 类中也包含了一些与 Flux 类中相同的静态方法。这些方法包括 just()，empty()，error()和 never()等。除了这些方法之外，Mono 还有一些独有的静态方法：</p><ol><li><p><code>fromCallable()</code>、<code>fromCompletionStage()</code>、<code>fromFuture()</code>、<code>fromRunnable(</code>)和 <code>fromSupplier()</code>：分别从 Callable、CompletionStage、CompletableFuture、Runnable 和 Supplier 中创建 Mono。</p></li><li><p><code>delay(Duration duration)</code>：创建一个 Mono 序列，在指定的延迟时间之后，产生数字 0 作为唯一值。</p></li><li><p><code>ignoreElements(Publisher&lt;T&gt; source)</code>：创建一个 Mono 序列，忽略作为源的 Publisher 中的所有元素，只产生结束消息。</p></li><li><p><code>justOrEmpty(Optional&lt;? extends T&gt; data)</code>和 <code>justOrEmpty(T data)</code>：从一个 Optional 对象或可能为 null 的对象中创建 Mono。只有 Optional 对象中包含值或对象不为 null 时，Mono 序列才产生对应的元素。</p></li></ol><p>举些例子:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Mono.just(<span class="string">"are"</span>).subscribe(System.out::println);</span><br><span class="line">Mono.empty().subscribe(System.out::println);</span><br><span class="line">Mono.fromSupplier(() -&gt; <span class="string">"you"</span>).subscribe(System.out::println);</span><br><span class="line">Mono.justOrEmpty(Optional.of(<span class="string">"ok"</span>)).subscribe(System.out::println);</span><br></pre></td></tr></table></figure><p></p><p>输出:</p><p><img src="img/QQ截图20190401173002.png" alt="QQ截图20190401173002.png"></p><p>还可以通过 create()方法来使用 MonoSink 来创建 Mono：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Mono.create(sink -&gt; sink.success(<span class="string">"Hello"</span>)).subscribe(System.out::println);</span><br></pre></td></tr></table></figure><p></p><h3 id="中间操作"><a href="#中间操作" class="headerlink" title="中间操作"></a>中间操作</h3><p><strong>filter</strong></p><p>对流中包含的元素进行过滤，只留下满足 Predicate 指定条件的元素：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Flux.range(<span class="number">1</span>, <span class="number">10</span>).filter(i -&gt; i % <span class="number">2</span> == <span class="number">0</span>).subscribe(System.out::println);</span><br></pre></td></tr></table></figure><p></p><p>输出前10偶数。</p><p><strong>take</strong></p><p>take 系列操作符用来从当前流中提取元素。提取的方式可以有很多种。</p><ol><li><p><code>take(long n)</code>：按照指定的数量来提取。</p></li><li><p><code>takeLast(long n)</code>：提取流中的最后 N 个元素。</p></li><li><p><code>takeUntil(Predicate&lt;? super T&gt; predicate)</code>：提取元素直到 Predicate 返回 true。</p></li></ol><p>4 <code>takeWhile(Predicate&lt;? super T&gt; continuePredicate)</code>： 当 Predicate 返回 true 时才进行提取。</p><p>举些例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Flux.range(<span class="number">1</span>, <span class="number">20</span>).take(<span class="number">10</span>).subscribe(System.out::println);</span><br><span class="line">Flux.range(<span class="number">1</span>, <span class="number">20</span>).takeLast(<span class="number">10</span>).subscribe(System.out::println);</span><br><span class="line">Flux.range(<span class="number">1</span>, <span class="number">20</span>).takeWhile(i -&gt; i &lt; <span class="number">10</span>).subscribe(System.out::println);</span><br><span class="line">Flux.range(<span class="number">1</span>, <span class="number">20</span>).takeUntil(i -&gt; i == <span class="number">10</span>).subscribe(System.out::println);</span><br></pre></td></tr></table></figure><p></p><p><strong>reduce 和 reduceWith</strong></p><p>reduce 和 reduceWith 操作符对流中包含的所有元素进行累积操作，得到一个包含计算结果的 Mono 序列。累积操作是通过一个 BiFunction 来表示的。在操作时可以指定一个初始值。如果没有初始值，则序列的第一个元素作为初始值。</p><p>比如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Flux.range(<span class="number">1</span>, <span class="number">10</span>).reduce((x, y) -&gt; x + y).subscribe(System.out::println);</span><br><span class="line">Flux.range(<span class="number">1</span>, <span class="number">10</span>).reduceWith(() -&gt; <span class="number">10</span>, (x, y) -&gt; x + y).subscribe(System.out::println);</span><br></pre></td></tr></table></figure><p></p><p>第一行语句对流中的元素进行相加操作，结果为 55；第二行语句同样也是进行相加操作，不过通过一个 Supplier 给出了初始值为 10，所以结果为 65。</p><p><strong>merge</strong></p><p><code>merge</code>操作符用来把多个流合并成一个 Flux 序列：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Flux.merge(</span><br><span class="line">        Flux.interval(Duration.of(<span class="number">500</span>, ChronoUnit.MILLIS)).take(<span class="number">2</span>),</span><br><span class="line">        Flux.interval(Duration.of(<span class="number">500</span>, ChronoUnit.MILLIS)).take(<span class="number">2</span>)</span><br><span class="line">).toStream().forEach(System.out::println);</span><br></pre></td></tr></table></figure><p>输出 0 0 1 1。</p><p><strong>buffer</strong></p><p>直接看例子吧：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Flux.range(<span class="number">1</span>, <span class="number">100</span>).buffer(<span class="number">20</span>).subscribe(System.out::println);</span><br><span class="line">Flux.range(<span class="number">1</span>, <span class="number">10</span>).bufferUntil(i -&gt; i % <span class="number">2</span> == <span class="number">0</span>).subscribe(System.out::println);</span><br><span class="line">Flux.range(<span class="number">1</span>, <span class="number">10</span>).bufferWhile(i -&gt; i % <span class="number">2</span> == <span class="number">0</span>).subscribe(System.out::println);</span><br></pre></td></tr></table></figure><p></p><p>输出如下所示：</p><p><img src="img/QQ截图20190402090631.png" alt="QQ截图20190402090631.png"></p><p>类似于数据流分区。</p><p><strong>zipWith</strong></p><p>将两个流的元素安装元素位置一一组合：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Flux.just(<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>, <span class="string">"d"</span>)</span><br><span class="line">    .zipWith(Flux.just(<span class="string">"e"</span>, <span class="string">"f"</span>, <span class="string">"g"</span>, <span class="string">"h"</span>, <span class="string">"i"</span>))</span><br><span class="line">    .subscribe(System.out::println);</span><br></pre></td></tr></table></figure><p></p><p>输出：</p><p><img src="img/QQ截图20190402092516.png" alt="QQ截图20190402092516.png"></p><p>没有配对上的被丢弃。</p><p>另外一个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Flux.just(<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>, <span class="string">"d"</span>)</span><br><span class="line">    .zipWith(Flux.just(<span class="string">"e"</span>, <span class="string">"f"</span>, <span class="string">"g"</span>, <span class="string">"h"</span>, <span class="string">"i"</span>), (s1, s2) -&gt; String.format(<span class="string">"%s-%s"</span>, s1, s2))</span><br><span class="line">    .subscribe(System.out::println);</span><br></pre></td></tr></table></figure><p></p><p>输出如下:</p><p><img src="img/QQ截图20190402092833.png" alt="QQ截图20190402092833.png"></p><p><strong>flatMap</strong></p><p>把流中的每个元素转换成一个流，再把所有流中的元素进行合并。</p><p>比如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Flux.just(<span class="number">5</span>, <span class="number">10</span>).flatMap(</span><br><span class="line">            x -&gt; Flux.range(<span class="number">1</span>, x).take(x)</span><br><span class="line">    ).subscribe(System.out::println);</span><br></pre></td></tr></table></figure><p></p><h3 id="终端处理"><a href="#终端处理" class="headerlink" title="终端处理"></a>终端处理</h3><p>通过<code>subscribe()</code>方法处理正常和错误消息：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Flux.just(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">    .concatWith(Mono.error(<span class="keyword">new</span> IllegalStateException()))</span><br><span class="line">    .subscribe(System.out::println, System.err::println);</span><br></pre></td></tr></table></figure><p></p><p>输出:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">java.lang.IllegalStateException</span><br></pre></td></tr></table></figure><p></p><p>出现错误时返回默认值：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Flux.just(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">    .concatWith(Mono.error(<span class="keyword">new</span> IllegalStateException()))</span><br><span class="line">    .onErrorReturn(<span class="number">0</span>)</span><br><span class="line">    .subscribe(System.out::println);</span><br></pre></td></tr></table></figure><p></p><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">0</span><br></pre></td></tr></table></figure><p></p><p>出现错误时使用另外的流：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Flux.just(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">    .concatWith(Mono.error(<span class="keyword">new</span> IllegalArgumentException()))</span><br><span class="line">    .onErrorResume(e -&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (e <span class="keyword">instanceof</span> IllegalStateException) &#123;</span><br><span class="line">            <span class="keyword">return</span> Mono.just(<span class="number">0</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> IllegalArgumentException) &#123;</span><br><span class="line">            <span class="keyword">return</span> Mono.just(-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Mono.empty();</span><br><span class="line">    &#125;).subscribe(System.out::println);</span><br></pre></td></tr></table></figure><p></p><p>输出如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">-1</span><br></pre></td></tr></table></figure><p></p><p>源码链接：<a href="https://github.com/wuyouzhuguli/SpringAll/tree/master/57.Spring-Boot-WebFlux" target="_blank" rel="noopener">https://github.com/wuyouzhuguli/SpringAll/tree/master/57.Spring-Boot-WebFlux</a></p><p>参考链接:</p><ol><li><p><a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/web-reactive.html#spring-webflux" target="_blank" rel="noopener">https://docs.spring.io/spring/docs/current/spring-framework-reference/web-reactive.html#spring-webflux</a></p></li><li><p><a href="https://developer.mozilla.org/zh-CN/docs/Server-sent_events/Using_server-sent_events" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Server-sent_events/Using_server-sent_events</a></p></li><li><p><a href="http://www.ruanyifeng.com/blog/2017/05/server-sent_events.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2017/05/server-sent_events.html</a></p></li><li><p><a href="https://projectreactor.io/docs/core/release/reference/#flux" target="_blank" rel="noopener">https://projectreactor.io/docs/core/release/reference/#flux</a></p></li><li><p><a href="https://www.ibm.com/developerworks/cn/java/j-cn-with-reactor-response-encode/index.html" target="_blank" rel="noopener">https://www.ibm.com/developerworks/cn/java/j-cn-with-reactor-response-encode/index.html</a></p></li></ol><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Thu Apr 04 2019 14:23:36 GMT+0800 (GMT+08:00) --&gt;&lt;p&gt;Spring MVC Web架构是基于阻塞式Servlet API构建的。Servlet 3.1后提供了非阻塞API，Spring 5.0后基于这些API构建了一套全新的非阻塞Web框架 —— WebFlux。Spring Boot 2.0基于Spring 5.0构建，所以要在Spring Boot中使用WebFlux架构，版本必须大于2.0。&lt;/p&gt;&lt;p&gt;通过下面这张图了解下Spring MVC和Spring WebFlux的区别：
    
    </summary>
    
    
      <category term="Spring" scheme="http://mrbird.cc/tags/Spring/"/>
    
      <category term="Spring Boot" scheme="http://mrbird.cc/tags/Spring-Boot/"/>
    
      <category term="WebFlux" scheme="http://mrbird.cc/tags/WebFlux/"/>
    
  </entry>
  
  <entry>
    <title>Spring Boot整合Mongo DB</title>
    <link href="http://mrbird.cc/Spring-Boot-Mongo-DB-CRUD.html"/>
    <id>http://mrbird.cc/Spring-Boot-Mongo-DB-CRUD.html</id>
    <published>2018-11-15T02:41:51.000Z</published>
    <updated>2019-04-04T06:10:50.260Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Apr 04 2019 14:23:35 GMT+0800 (GMT+08:00) --><p>这节我们将整合Spring Boot与Mongo DB实现增删改查的功能，并且实现序列递增。Mongo DB下载地址：<a href="https://www.mongodb.com/download-center/community" target="_blank" rel="noopener">https://www.mongodb.com/download-center/community</a>。Mongo DB的基本介绍和增删改查的用法可以参考我之前的文章：<a href="https://mrbird.cc/MongoDB-shell.html"> MongoDB shell </a>、<a href="https://mrbird.cc/MongoDB%E6%96%87%E6%A1%A3CUD.html"> MongoDB文档CUD </a>和<a href="https://mrbird.cc/MongoDB-%E6%96%87%E6%A1%A3%E6%9F%A5%E8%AF%A2.html"> MongoDB 文档查询 </a>。</p><a id="more"></a><p>新建一个Spring Boot项目，版本为2.1.3.RELEASE，并引入如下依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-mongodb<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p></p><p>然后可以通过Mongo Shell或者Mongo Compass工具创建一个名称为testdb的数据库，并新增user文档（文档，类似与关系型数据库里的数据表）：</p><p><img src="img/QQ截图20190402141210.png" alt="QQ截图20190402141210.png"></p><p>在配置文件application.yml里配置Mongo DB：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  data:</span></span><br><span class="line"><span class="attr">    mongodb:</span></span><br><span class="line"><span class="attr">      host:</span> <span class="string">localhost</span></span><br><span class="line"><span class="attr">      port:</span> <span class="number">27017</span></span><br><span class="line"><span class="attr">      database:</span> <span class="string">testdb</span></span><br></pre></td></tr></table></figure><p></p><p>Mongo DB的默认端口为27017，使用的数据库为刚刚创建的testdb。</p><p>创建User实体类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Document</span>(collection = <span class="string">"user"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="keyword">private</span> String id;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String description;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// get set 略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>@Document(collection = &quot;user&quot;)</code>表明这是一个文档对象，名称为<code>user</code>，对应Mongo DB里的user表。<code>@Id</code>标注主键字段，String类型的主键值在插入的时候Mongo DB会帮我们自动生成。如果对象中的某个属性为非表字段，可以使用注解<code>@Transient</code>进行排除。</p><p>准备好这些后，我们开始编写一些简单的增删改查样例。</p><h2 id="简单增删改查"><a href="#简单增删改查" class="headerlink" title="简单增删改查"></a>简单增删改查</h2><p>创建一个UserDao接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserDao</span> <span class="keyword">extends</span> <span class="title">MongoRepository</span>&lt;<span class="title">User</span>, <span class="title">String</span>&gt; </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>接口继承自<code>MongoRepository</code>，泛型分别为实体对象和主键类型。通过继承<code>MongoRepository</code>，<code>UserDao</code>包含了一些增删改查的方法，如下图所示：</p><p><img src="img/QQ截图20190404094010.png" alt="QQ截图20190404094010.png"></p><p>接着编写UserService，为了方便这里不再编写接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserDao userDao;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;User&gt; <span class="title">getUsers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> userDao.findAll();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Optional&lt;User&gt; <span class="title">getUser</span><span class="params">(String id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.userDao.findById(id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 新增和修改都是 save方法，</span></span><br><span class="line"><span class="comment">     * id 存在为修改，id 不存在为新增</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">createUser</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">        user.setId(<span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">return</span> userDao.save(user);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteUser</span><span class="params">(String id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.userDao.findById(id)</span><br><span class="line">                .ifPresent(user -&gt; <span class="keyword">this</span>.userDao.delete(user));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateUser</span><span class="params">(String id, User user)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.userDao.findById(id)</span><br><span class="line">            .ifPresent(</span><br><span class="line">                u -&gt; &#123;</span><br><span class="line">                    u.setName(user.getName());</span><br><span class="line">                    u.setAge(user.getAge());</span><br><span class="line">                    u.setDescription(user.getDescription());</span><br><span class="line">                    <span class="keyword">this</span>.userDao.save(u);</span><br><span class="line">                &#125;</span><br><span class="line">            );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>上面我们编写了基本的增删改查样例，新增和修改都是通过<code>save</code>方法完成的，当主键存在时则为修改，主键不存在则为新增。</p><p>最后编写一个RESTful的UserController（为了方便，没有对参数进行校验）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"user"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserService userService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;User&gt; <span class="title">getUsers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> userService.getUsers();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">createUser</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> userService.createUser(user);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@DeleteMapping</span>(<span class="string">"/&#123;id&#125;"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteUser</span><span class="params">(@PathVariable String id)</span> </span>&#123;</span><br><span class="line">        userService.deleteUser(id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PutMapping</span>(<span class="string">"/&#123;id&#125;"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateUser</span><span class="params">(@PathVariable String id, User user)</span> </span>&#123;</span><br><span class="line">        userService.updateUser(id, user);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据用户 id查找</span></span><br><span class="line"><span class="comment">     * 存在返回，不存在返回 null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/&#123;id&#125;"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">getUser</span><span class="params">(@PathVariable String id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> userService.getUser(id).orElse(<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>启动项目，使用postman来测试接口的可用性。</p><p>测试新增用户：</p><p><img src="img/QQ截图20190404094900.png" alt="QQ截图20190402142923.png"></p><p>新增成功，查看数据库：</p><p><img src="img/QQ截图20190404094944.png" alt="QQ截图20190404094944.png"></p><p>测试查询用户：</p><p><img src="img/QQ截图20190404095026.png" alt="QQ截图20190402143028.png"></p><p>查询成功。</p><p>测试通过用ID查找用户：</p><p><img src="img/QQ截图20190404095104.png" alt="QQ截图20190402143107.png"></p><p>更新用户：</p><p><img src="img/QQ截图20190404095151.png" alt="QQ截图20190402143139.png"></p><p>查看数据库是否更新成功：</p><p><img src="img/QQ截图20190404095609.png" alt="QQ截图20190402143232.png"></p><p>更新成功。</p><p>最后测试通过用户ID删除用户：</p><p><img src="img/QQ截图20190404095646.png" alt="QQ截图20190402143320.png"></p><p>返回状态码200，删除成功。</p><p>查看数据库，删除成功：</p><p><img src="img/QQ截图20190404095710.png" alt="QQ截图20190404095710.png"></p><h2 id="多条件查询"><a href="#多条件查询" class="headerlink" title="多条件查询"></a>多条件查询</h2><p>其实<code>UserDao</code>通过继承<code>MongoRepository</code>已经具有了JPA的特性，我们可以通过方法名来构建多查询条件的SQL。比如通过用户的年龄段来查询：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserDao</span> <span class="keyword">extends</span> <span class="title">MongoRepository</span>&lt;<span class="title">User</span>, <span class="title">String</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据年龄段来查找</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> from from</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> to   to</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> List&lt;User&gt;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">List&lt;User&gt; <span class="title">findByAgeBetween</span><span class="params">(Integer from, Integer to)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>在输入<code>findBy</code>后，IDEA会根据实体对象的属性和SQL的各种关键字自动组合提示：</p><p><img src="img/fasdfasdf.png" alt="QQ截图20190404101118.png"></p><p>比如再在创建一个通过年龄段，用户名和描述（模糊查询）查询用户的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 通过年龄段，用户名，描述（模糊查询）</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> from        from</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> to          to</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> name        name</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> description description</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> List&lt;User&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">List&lt;User&gt; <span class="title">findByAgeBetweenAndNameEqualsAndDescriptionIsLike</span><span class="params">(Integer from, Integer to, String name, String description)</span></span>;</span><br></pre></td></tr></table></figure><p>方法参数个数需要和方法名中所需要的参数个数对应上。</p><h2 id="排序与分页"><a href="#排序与分页" class="headerlink" title="排序与分页"></a>排序与分页</h2><p>排序和分页需要使用<code>MongoTemplate</code>对象来完成，在<code>UserService</code>里新增一个<code>getUserByCondition</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> MongoTemplate template;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Page&lt;User&gt; <span class="title">getUserByCondition</span><span class="params">(<span class="keyword">int</span> size, <span class="keyword">int</span> page, User user)</span> </span>&#123;</span><br><span class="line">    Query query = <span class="keyword">new</span> Query();</span><br><span class="line">    Criteria criteria = <span class="keyword">new</span> Criteria();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!StringUtils.isEmpty(user.getName())) &#123;</span><br><span class="line">        criteria.and(<span class="string">"name"</span>).is(user.getName());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!StringUtils.isEmpty(user.getDescription())) &#123;</span><br><span class="line">        criteria.and(<span class="string">"description"</span>).regex(user.getDescription());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    query.addCriteria(criteria);</span><br><span class="line"></span><br><span class="line">    Sort sort = <span class="keyword">new</span> Sort(Sort.Direction.DESC, <span class="string">"age"</span>);</span><br><span class="line">    Pageable pageable = PageRequest.of(page, size, sort);</span><br><span class="line"></span><br><span class="line">    List&lt;User&gt; users = template.find(query.with(pageable), User.class);</span><br><span class="line">    <span class="keyword">return</span> PageableExecutionUtils.getPage(users, pageable, () -&gt; template.count(query, User.class));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p><code>size</code>表示每页显示的条数，<code>page</code>表示当前页码数，0表示第一页。上面的方法通过<code>name</code>和<code>description</code>（模糊查询）来查询用户分页信息，并且查询结果使用<code>age</code>字段降序排序。方法返回<code>Page</code>对象。</p><p>在<code>UserController</code>里添加：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"/condition"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> Page&lt;User&gt; <span class="title">getUserByCondition</span><span class="params">(<span class="keyword">int</span> size, <span class="keyword">int</span> page, User user)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> userService.getUserByCondition(size, page, user);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>重启项目，我们往数据库里多加几条数据：</p><p><img src="img/QQ截图20190404102609.png" alt="QQ截图20190404102609.png"></p><p>获取第1页数据，每页显示10条：</p><p><img src="img/QQ截图20190404102736.png" alt="QQ截图20190404102736.png"></p><p>返回数据：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"content"</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">"id"</span>: <span class="string">"5ca56ae2f08f0b6048fd470d"</span>,</span><br><span class="line">            <span class="attr">"name"</span>: <span class="string">"jane"</span>,</span><br><span class="line">            <span class="attr">"age"</span>: <span class="number">26</span>,</span><br><span class="line">            <span class="attr">"description"</span>: <span class="string">"web developer"</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">"id"</span>: <span class="string">"5ca56ad1f08f0b6048fd470c"</span>,</span><br><span class="line">            <span class="attr">"name"</span>: <span class="string">"scott"</span>,</span><br><span class="line">            <span class="attr">"age"</span>: <span class="number">23</span>,</span><br><span class="line">            <span class="attr">"description"</span>: <span class="string">"ui designer"</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">"id"</span>: <span class="string">"5ca56afaf08f0b6048fd470e"</span>,</span><br><span class="line">            <span class="attr">"name"</span>: <span class="string">"mike"</span>,</span><br><span class="line">            <span class="attr">"age"</span>: <span class="number">21</span>,</span><br><span class="line">            <span class="attr">"description"</span>: <span class="string">"python developer"</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">"id"</span>: <span class="string">"5ca56b38f08f0b6048fd470f"</span>,</span><br><span class="line">            <span class="attr">"name"</span>: <span class="string">"mrbird"</span>,</span><br><span class="line">            <span class="attr">"age"</span>: <span class="number">18</span>,</span><br><span class="line">            <span class="attr">"description"</span>: <span class="string">"java noob"</span></span><br><span class="line">        &#125;</span><br><span class="line">    ],</span><br><span class="line">    <span class="attr">"pageable"</span>: &#123;</span><br><span class="line">        <span class="attr">"sort"</span>: &#123;</span><br><span class="line">            <span class="attr">"sorted"</span>: <span class="literal">true</span>,</span><br><span class="line">            <span class="attr">"unsorted"</span>: <span class="literal">false</span>,</span><br><span class="line">            <span class="attr">"empty"</span>: <span class="literal">false</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">"offset"</span>: <span class="number">0</span>,</span><br><span class="line">        <span class="attr">"pageSize"</span>: <span class="number">10</span>,</span><br><span class="line">        <span class="attr">"pageNumber"</span>: <span class="number">0</span>,</span><br><span class="line">        <span class="attr">"unpaged"</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="attr">"paged"</span>: <span class="literal">true</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"last"</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">"totalPages"</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">"totalElements"</span>: <span class="number">4</span>,</span><br><span class="line">    <span class="attr">"number"</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="attr">"size"</span>: <span class="number">10</span>,</span><br><span class="line">    <span class="attr">"sort"</span>: &#123;</span><br><span class="line">        <span class="attr">"sorted"</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">"unsorted"</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="attr">"empty"</span>: <span class="literal">false</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"numberOfElements"</span>: <span class="number">4</span>,</span><br><span class="line">    <span class="attr">"first"</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">"empty"</span>: <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>剩下可以自己测试。</p><p>postman测试样例及源码链接：<a href="https://github.com/wuyouzhuguli/SpringAll/tree/master/56.Spring-Boot-MongoDB-crud" target="_blank" rel="noopener">https://github.com/wuyouzhuguli/SpringAll/tree/master/56.Spring-Boot-MongoDB-crud</a></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Thu Apr 04 2019 14:23:35 GMT+0800 (GMT+08:00) --&gt;&lt;p&gt;这节我们将整合Spring Boot与Mongo DB实现增删改查的功能，并且实现序列递增。Mongo DB下载地址：&lt;a href=&quot;https://www.mongodb.com/download-center/community&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.mongodb.com/download-center/community&lt;/a&gt;。Mongo DB的基本介绍和增删改查的用法可以参考我之前的文章：&lt;a href=&quot;https://mrbird.cc/MongoDB-shell.html&quot;&gt; MongoDB shell &lt;/a&gt;、&lt;a href=&quot;https://mrbird.cc/MongoDB%E6%96%87%E6%A1%A3CUD.html&quot;&gt; MongoDB文档CUD &lt;/a&gt;和&lt;a href=&quot;https://mrbird.cc/MongoDB-%E6%96%87%E6%A1%A3%E6%9F%A5%E8%AF%A2.html&quot;&gt; MongoDB 文档查询 &lt;/a&gt;。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Spring Boot" scheme="http://mrbird.cc/tags/Spring-Boot/"/>
    
      <category term="MongoDB" scheme="http://mrbird.cc/tags/MongoDB/"/>
    
  </entry>
  
  <entry>
    <title>Java 9 Flow API 学习</title>
    <link href="http://mrbird.cc/Java-9-Flow-API-Learn.html"/>
    <id>http://mrbird.cc/Java-9-Flow-API-Learn.html</id>
    <published>2018-11-10T02:46:14.000Z</published>
    <updated>2019-02-26T11:28:18.786Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Apr 04 2019 14:23:35 GMT+0800 (GMT+08:00) --><p>响应式编程（Reactive Programming）可以理解为一种处理数据项（Data Item）的异步流，即在数据项产生的时候，接收者就对其进行响应。在响应式编程中，会有一个数据发布者（Publisher）和数据订阅者（Subscriber），后者用于异步接收发布者发布的数据。在该模式中，还引入了一个更高级的特性：数据处理器（Processor），它用于将数据发布者发布的数据进行某些转换操作，然后再发布给数据订阅者。</p><p>总之，响应式编程是异步非阻塞编程，能够提升程序性能，可以解决传统编程模型遇到的困境。基于这个模型实现的有Java 9 Flow API、RxJava和Reactor等，这里主要介绍的是Java 9 Flow API的使用。</p><a id="more"></a><h2 id="Flow接口概览"><a href="#Flow接口概览" class="headerlink" title="Flow接口概览"></a>Flow接口概览</h2><p>Java 9 新增了一个<code>Flow</code>接口，位于<code>java.util.concurrent</code>路径下，构成如下图所示：</p><p><img src="img/QQ截图20190226141817.png" alt="QQ截图20190226141817.png"></p><p>其中<code>Publisher</code>为数据发布者，<code>Subscriber</code>为数据订阅者，<code>Subscription</code>为发布者和订阅者之间的订阅关系，<code>Processor</code>为数据处理器。</p><h3 id="Publisher"><a href="#Publisher" class="headerlink" title="Publisher"></a>Publisher</h3><p><code>Publisher</code>部分的源码如下所示:</p><p><img src="img/QQ截图20190226142214.png" alt="QQ截图20190226142214.png"></p><p>它是一个函数式接口，只包含一个<code>subscribe</code>方法，通过这个方法将数据发布出去。</p><h3 id="Subscriber"><a href="#Subscriber" class="headerlink" title="Subscriber"></a>Subscriber</h3><p><code>Subscriber</code>部分的源码如下所示: <img src="img/QQ截图20190226142519.png" alt="QQ截图20190226142519.png"></p><p>该接口包含了四个方法：</p><table><tr><th>方法</th><th>描述</th></tr><tr><td>onSubscribe</td><td>订阅成功的回调方法，用于初始化<code>Subscription</code>，并且表明可以开始接收订阅数据了</td></tr><tr><td>onNext</td><td>接收下一项订阅数据的回调方法</td></tr><tr><td>onError</td><td>在Publisher或Subcriber遇到不可恢复的错误时调用此方法，Subscriber不再接收订阅消息</td></tr><tr><td>onComplete</td><td>当接收完所有订阅数据，并且发布者已经关闭后会回调这个方法</td></tr></table><h3 id="Subscription"><a href="#Subscription" class="headerlink" title="Subscription"></a>Subscription</h3><p><code>Subscription</code>部分的源码如下所示：</p><p><img src="img/QQ截图20190226143424.png" alt="QQ截图20190226143424.png"></p><p>该接口包含了两个方法：</p><table><tr><th>方法</th><th>描述</th></tr><tr><td>request</td><td>用于向数据发布者请求n个数据项</td></tr><tr><td>cancel</td><td>取消消息订阅，订阅者将不再接收数据</td></tr></table><h3 id="Processor"><a href="#Processor" class="headerlink" title="Processor"></a>Processor</h3><p><code>Processor</code>部分的代码如下所示：</p><p><img src="img/QQ截图20190226143709.png" alt="QQ截图20190226143709.png"></p><p>它是一个空接口，但是它继承了<code>Publisher</code>和<code>Subscriber</code>，所以它既能发布数据也能订阅数据。基于这个特性，它可以充当数据转换的角色，先从数据发布者那接收数据项，然后经过处理后再发布给最终的数据订阅者。</p><h2 id="发布订阅示例"><a href="#发布订阅示例" class="headerlink" title="发布订阅示例"></a>发布订阅示例</h2><p>接下来我们举个数据发布和数据订阅的简单示例，以此了解Java 9 Flow API的使用。先入为主，直接贴出整个示例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FlowApiTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">// 1. 定义 String 类型的数据发布者，JDK 9自带的</span></span><br><span class="line">        <span class="comment">// SubmissionPublisher 实现了 Publisher</span></span><br><span class="line">        SubmissionPublisher&lt;String&gt; publisher = <span class="keyword">new</span> SubmissionPublisher&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 创建一个订阅者，用于接收发布者的消息</span></span><br><span class="line">        Subscriber&lt;String&gt; subscriber = <span class="keyword">new</span> Subscriber&lt;&gt;() &#123;</span><br><span class="line">            <span class="keyword">private</span> Subscription subscription;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSubscribe</span><span class="params">(Subscription subscription)</span> </span>&#123;</span><br><span class="line">                <span class="comment">// 通过 Subscription 和发布者保持订阅关系，并用它来给发布者反馈</span></span><br><span class="line">                <span class="keyword">this</span>.subscription = subscription;</span><br><span class="line">                <span class="comment">// 请求一个数据</span></span><br><span class="line">                <span class="keyword">this</span>.subscription.request(<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(String item)</span> </span>&#123;</span><br><span class="line">                <span class="comment">// 接收发布者发布的消息</span></span><br><span class="line">                System.out.println(<span class="string">"【订阅者】接收消息 &lt;------ "</span> + item);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 接收后再次请求一个数据</span></span><br><span class="line">                <span class="keyword">this</span>.subscription.request(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 如果不想再接收数据，也可以直接调用 cancel，表示不再接收了</span></span><br><span class="line">                <span class="comment">// this.subscription.cancel();</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable throwable)</span> </span>&#123;</span><br><span class="line">                <span class="comment">// 过程中出现异常会回调这个方法</span></span><br><span class="line">                System.out.println(<span class="string">"【订阅者】数据接收出现异常，"</span> + throwable);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 出现异常，取消订阅，告诉发布者我不再接收数据了</span></span><br><span class="line">                <span class="comment">// 实际测试发现，只要订阅者接收消息出现异常，进入了这个回调</span></span><br><span class="line">                <span class="comment">// 订阅者就不会再继续接收消息了</span></span><br><span class="line">                <span class="keyword">this</span>.subscription.cancel();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onComplete</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="comment">// 当发布者发出的数据都被接收了，</span></span><br><span class="line">                <span class="comment">// 并且发布者关闭后，会回调这个方法</span></span><br><span class="line">                System.out.println(<span class="string">"【订阅者】数据接收完毕"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 发布者和订阅者需要建立关系</span></span><br><span class="line">        publisher.subscribe(subscriber);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4. 发布者开始发布数据</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            String message = <span class="string">"hello flow api "</span> + i;</span><br><span class="line">            System.out.println(<span class="string">"【发布者】发布消息 ------&gt; "</span> + message);</span><br><span class="line">            publisher.submit(message);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5. 发布结束后，关闭发布者</span></span><br><span class="line">        publisher.close();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// main线程延迟关闭，不然订阅者还没接收完消息，线程就被关闭了</span></span><br><span class="line">        Thread.currentThread().join(<span class="number">2000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面使用JDK 自带的<code>Publisher</code>实现类<code>SubmissionPublisher</code>来发布 String类型的数据，然后用匿名实现类的方式创建了一个<code>Subscriber</code>实现类。接着使用<code>SubmissionPublisher</code>的<code>subscribe</code>方法来为发布者和订阅者建立关系。建立关系后，发布者就可以发布数据，接收者也开始接收数据。详细的说明注释里都写了，这里就不再赘述代码的逻辑了。</p><p>程序的输出如下所示：</p><p><img src="img/QQ截图20190226144617.png" alt="QQ截图20190226144617.png"></p><h2 id="模拟背压"><a href="#模拟背压" class="headerlink" title="模拟背压"></a>模拟背压</h2><p>所谓的<a href="https://en.wikipedia.org/wiki/Back_pressure" target="_blank" rel="noopener">背压</a>（Backpressure）通俗的讲就是数据接收者的压力，传统模式下，发布者只关心数据的创造与发布，而当数据发布速率远高于数据接收速率的时候，数据接收者缓冲区将被填满，无法再接收数据。发布者并不关心这些，依旧不断地发送数据，所以就造成了IO阻塞。</p><p>基于响应式模型实现的Flow API可以很好地解决这个问题。在Java 9的Flow API定义中，<code>Subscriber</code>会将<code>Publisher</code>发布的数据缓冲在<code>Subscription</code>中，其长度默认为256：</p><p><img src="img/QQ截图20190226150028.png" alt="QQ截图20190226150028.png"></p><p>假如当这个缓冲区都被填满后，<code>Publisher</code>将会停止发送数据，直到<code>Subscriber</code>接收了数据<code>Subscription</code>有空闲位置的时候，<code>Publisher</code>才会继续发布数据，而非一味地发个不停。</p><p>下面用代码来演示这个情况：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FlowApiTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">// 1. 定义String类型的数据发布者，JDK 9自带的</span></span><br><span class="line">        <span class="comment">// SubmissionPublisher实现了 Publisher</span></span><br><span class="line">        SubmissionPublisher&lt;String&gt; publisher = <span class="keyword">new</span> SubmissionPublisher&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 创建一个订阅者，用于接收发布者的消息</span></span><br><span class="line">        Subscriber&lt;String&gt; subscriber = <span class="keyword">new</span> Subscriber&lt;&gt;() &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">private</span> Subscription subscription;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSubscribe</span><span class="params">(Subscription subscription)</span> </span>&#123;</span><br><span class="line">                <span class="comment">// 通过 Subscription 和发布者保持订阅关系，并用它来给发布者反馈</span></span><br><span class="line">                <span class="keyword">this</span>.subscription = subscription;</span><br><span class="line">                <span class="comment">// 请求一个数据</span></span><br><span class="line">                <span class="keyword">this</span>.subscription.request(<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(String item)</span> </span>&#123;</span><br><span class="line">                <span class="comment">// 接收发布者发布的消息</span></span><br><span class="line">                System.out.println(<span class="string">"【订阅者】接收消息 &lt;------ "</span> + item);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 模拟接收数据缓慢，让缓冲池填满</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 接收后再次请求一个数据，表示我已经处理完了，你可以再发数据过来了</span></span><br><span class="line">                <span class="keyword">this</span>.subscription.request(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 如果不想再接收数据，也可以直接调用cancel，表示不再接收了</span></span><br><span class="line">                <span class="comment">// this.subscription.cancel();</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable throwable)</span> </span>&#123;</span><br><span class="line">                <span class="comment">// 过程中出现异常会回调这个方法</span></span><br><span class="line">                System.out.println(<span class="string">"【订阅者】数据接收出现异常，"</span> + throwable);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 出现异常，取消订阅，告诉发布者我不再接收数据了</span></span><br><span class="line">                <span class="comment">// 实际测试发现，只要订阅者接收消息出现异常，进入了这个回调</span></span><br><span class="line">                <span class="comment">// 订阅者就不会再继续接收消息了</span></span><br><span class="line">                <span class="keyword">this</span>.subscription.cancel();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onComplete</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="comment">// 当发布者发出的数据都被接收了，</span></span><br><span class="line">                <span class="comment">// 并且发布者关闭后，会回调这个方法</span></span><br><span class="line">                System.out.println(<span class="string">"【订阅者】数据接收完毕"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 发布者和订阅者需要建立关系</span></span><br><span class="line">        publisher.subscribe(subscriber);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4. 发布者开始发布数据</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">500</span>; i++) &#123;</span><br><span class="line">            String message = <span class="string">"hello flow api "</span> + i;</span><br><span class="line">            System.out.println(<span class="string">"【发布者】发布消息 ------&gt; "</span> + message);</span><br><span class="line">            publisher.submit(message);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5. 发布结束后，关闭发布者</span></span><br><span class="line">        publisher.close();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// main线程延迟关闭，不然订阅者还没接收完消息，线程就被关闭了</span></span><br><span class="line">        Thread.currentThread().join(<span class="number">20000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，我们在<code>Subscriber</code>的<code>onNext</code>方法中用下面的代码模拟延迟，让数据处理过程维持在2秒左右：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>然后数据发布量调整到了500，当程序启动的时候，由于数据发布的速度非常快（普通for循环），所以数据订阅者的数据缓冲区瞬间被填满，于是你会看到下面这个情况，只有当数据订阅者处理了一个数据的时候，数据发布者才会相应地再次发布一个新数据：</p><p><img src="img/testasdfasdf.gif" alt="testasdfasdf.gif"></p><h2 id="Processor示例"><a href="#Processor示例" class="headerlink" title="Processor示例"></a>Processor示例</h2><p><code>Processor</code>的使用也很简单，其实它就是<code>Publisher</code>和<code>Subscriber</code>的结合体，充当数据处理的角色，通常的做法是用它来接收发布者发布的消息，然后进行相应的处理，再将数据发布出去，供消息订阅者接收。</p><p>下面是一个<code>Processor</code>用法的简单示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FlowApiTest2</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyProcessor</span> <span class="keyword">extends</span> <span class="title">SubmissionPublisher</span>&lt;<span class="title">String</span>&gt;</span></span><br><span class="line"><span class="class">            <span class="keyword">implements</span> <span class="title">Processor</span>&lt;<span class="title">String</span>, <span class="title">String</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> Subscription subscription;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSubscribe</span><span class="params">(Subscription subscription)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 通过 Subscription 和发布者保持订阅关系，并用它来给发布者反馈</span></span><br><span class="line">            <span class="keyword">this</span>.subscription = subscription;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 请求一个数据</span></span><br><span class="line">            <span class="keyword">this</span>.subscription.request(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(String item)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 接收发布者发布的消息</span></span><br><span class="line">            System.out.println(<span class="string">"【处理器】接收消息 &lt;------ "</span> + item);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 处理器将消息进行转换</span></span><br><span class="line">            String newItem = <span class="string">"【处理器加工后的数据: "</span> + item + <span class="string">"】"</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">this</span>.submit(newItem);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 接收后再次请求一个数据，表示我已经处理完了，你可以再发数据过来了</span></span><br><span class="line">            <span class="keyword">this</span>.subscription.request(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果不想再接收数据，也可以直接调用cancel，表示不再接收了</span></span><br><span class="line">            <span class="comment">// this.subscription.cancel();</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable throwable)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 过程中出现异常会回调这个方法</span></span><br><span class="line">            System.out.println(<span class="string">"【处理器】数据接收出现异常，"</span> + throwable);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 出现异常，取消订阅，告诉发布者我不再接收数据了</span></span><br><span class="line">            <span class="keyword">this</span>.subscription.cancel();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onComplete</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"【处理器】数据处理完毕"</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 处理器处理完数据后关闭</span></span><br><span class="line">            <span class="keyword">this</span>.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">// 1. 定义String类型的数据发布者，JDK 9自带的</span></span><br><span class="line">        <span class="comment">// SubmissionPublisher实现了 Publisher</span></span><br><span class="line">        SubmissionPublisher&lt;String&gt; publisher = <span class="keyword">new</span> SubmissionPublisher&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 创建处理器，用于接收发布者发布的消息，</span></span><br><span class="line">        <span class="comment">// 转换后再发送给订阅者</span></span><br><span class="line">        MyProcessor processor = <span class="keyword">new</span> MyProcessor();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 发布者和处理器建立订阅的关系</span></span><br><span class="line">        publisher.subscribe(processor);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4.创建一个订阅者，用于接收处理器的消息</span></span><br><span class="line">        Subscriber&lt;String&gt; subscriber = <span class="keyword">new</span> Subscriber&lt;&gt;() &#123;</span><br><span class="line">            <span class="keyword">private</span> Subscription subscription;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSubscribe</span><span class="params">(Subscription subscription)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">this</span>.subscription = subscription;</span><br><span class="line">                <span class="keyword">this</span>.subscription.request(<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(String item)</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"【订阅者】接收消息 &lt;------ "</span> + item + <span class="string">""</span>);</span><br><span class="line">                <span class="keyword">this</span>.subscription.request(<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable throwable)</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"【订阅者】数据接收出现异常，"</span> + throwable);</span><br><span class="line">                <span class="keyword">this</span>.subscription.cancel();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onComplete</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"【订阅者】数据接收完毕"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5. 处理器和订阅者建立订阅关系</span></span><br><span class="line">        processor.subscribe(subscriber);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 6. 发布者开始发布数据</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            String message = <span class="string">"hello flow api "</span> + i;</span><br><span class="line">            System.out.println(<span class="string">"【发布者】发布消息 ------&gt; "</span> + message);</span><br><span class="line">            publisher.submit(message);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 7. 发布结束后，关闭发布者</span></span><br><span class="line">        publisher.close();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// main线程延迟关闭，不然订阅者还没接收完消息，线程就被关闭了</span></span><br><span class="line">        Thread.currentThread().join(<span class="number">2000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>程序运行结果如下所示：</p><p><img src="img/QQ截图20190226151701.png" alt="QQ截图20190226151701.png"></p><blockquote><p>参考文档：<a href="https://community.oracle.com/docs/DOC-1006738" target="_blank" rel="noopener">https://community.oracle.com/docs/DOC-1006738</a></p></blockquote><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Thu Apr 04 2019 14:23:35 GMT+0800 (GMT+08:00) --&gt;&lt;p&gt;响应式编程（Reactive Programming）可以理解为一种处理数据项（Data Item）的异步流，即在数据项产生的时候，接收者就对其进行响应。在响应式编程中，会有一个数据发布者（Publisher）和数据订阅者（Subscriber），后者用于异步接收发布者发布的数据。在该模式中，还引入了一个更高级的特性：数据处理器（Processor），它用于将数据发布者发布的数据进行某些转换操作，然后再发布给数据订阅者。&lt;/p&gt;&lt;p&gt;总之，响应式编程是异步非阻塞编程，能够提升程序性能，可以解决传统编程模型遇到的困境。基于这个模型实现的有Java 9 Flow API、RxJava和Reactor等，这里主要介绍的是Java 9 Flow API的使用。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java" scheme="http://mrbird.cc/tags/Java/"/>
    
      <category term="Java 9" scheme="http://mrbird.cc/tags/Java-9/"/>
    
  </entry>
  
  <entry>
    <title>Java 10 新特性之var</title>
    <link href="http://mrbird.cc/Java10-new-feature-var.html"/>
    <id>http://mrbird.cc/Java10-new-feature-var.html</id>
    <published>2018-11-05T07:16:50.000Z</published>
    <updated>2019-02-15T06:24:13.399Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Apr 04 2019 14:23:34 GMT+0800 (GMT+08:00) --><p>今年3月，Java 10 如期发布，Java 10 是采用新发布周期的第一个版本，提供了 109 项新特性，其中最备受关注的莫过于局部变量的类型推断。所以这里主要记录一下这个特性的用法。</p><a id="more"></a><p>看几个Java 10之前声明变量的例子:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">Stream&lt;String&gt; stream = list.stream();</span><br><span class="line"></span><br><span class="line">InputStreamReader reader = <span class="keyword">new</span> InputStreamReader(System.in);</span><br><span class="line">HttpClient httpClient = HttpClient.newHttpClient();</span><br></pre></td></tr></table></figure><p></p><p>在Java 10 中，只要是编译器能够通过对象类型来确定变量类型的情况下，变量类型声明可以使用<code>var</code>保留字代替：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="keyword">var</span> stream = list.stream();</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> reader = <span class="keyword">new</span> InputStreamReader(System.in);</span><br><span class="line"><span class="keyword">var</span> httpClient = HttpClient.newHttpClient();</span><br></pre></td></tr></table></figure><p></p><p>引入这个特性使得我们的Java 代码变得更加的简洁易读。除此之外我们也可以在增强<code>for</code>循环中使用<code>var</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">list.add(<span class="string">"hello"</span>);</span><br><span class="line">list.add(<span class="string">"java 10"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> s : list) System.out.println(s);</span><br></pre></td></tr></table></figure><p></p><p>当然，<code>var</code>并不是在何时何地都能使用，用于变量声明时，仅局限于具有构造器的变量或基本数据类型，比如下面这些例子编译是不通过的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a;</span><br><span class="line">a = <span class="string">"hello world"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> b = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br></pre></td></tr></table></figure><p>编译器将会告警：</p><p><img src="img/QQ截图20190214164317.png" alt="QQ截图20190214164317.png"></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Thu Apr 04 2019 14:23:34 GMT+0800 (GMT+08:00) --&gt;&lt;p&gt;今年3月，Java 10 如期发布，Java 10 是采用新发布周期的第一个版本，提供了 109 项新特性，其中最备受关注的莫过于局部变量的类型推断。所以这里主要记录一下这个特性的用法。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java" scheme="http://mrbird.cc/tags/Java/"/>
    
      <category term="Java 10" scheme="http://mrbird.cc/tags/Java-10/"/>
    
  </entry>
  
  <entry>
    <title>Java 9 新特性学习</title>
    <link href="http://mrbird.cc/Java-9-Feature.html"/>
    <id>http://mrbird.cc/Java-9-Feature.html</id>
    <published>2018-11-02T00:50:59.000Z</published>
    <updated>2019-02-14T07:12:22.428Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Apr 04 2019 14:23:35 GMT+0800 (GMT+08:00) --><p>在Java 8 发布3年多后，Java 9 终于在2017年9月21日正式发布。Java 9 提供了超过150项新功能特性，包括备受期待的模块化系统、 可交互的REPL工具jShell、JDK编译工具、Java公共API和私有代码，以及安全增强、扩展提升和性能管理改善等。在学习这些新特性之前，我们得先安装好JDK 9，JDK 9 下载地址：<a href="https://www.oracle.com/technetwork/cn/java/javase/downloads/jdk9-downloads-3848520-zhs.html" target="_blank" rel="noopener">https://www.oracle.com/technetwork/cn/java/javase/downloads/jdk9-downloads-3848520-zhs.html</a>。<a id="more"></a></p><h2 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h2><p>Java 9 中的模块化（Module）类似于ES6中的模块化，都是为了解决项目中减少内存的开销，提供可维护性和系统性能而提出的。通俗地说，Java 9 的模块化本质上就是在包（package）上再包裹一层（Module），默认模块里的内容都是隐藏的，只能通过（exports）关键字来暴露模块里的内容，而别的模块需要用到这些内容则需要使用（requires）关键字来导入。</p><p>下面我们用代码来演示这一个新特性。</p><p>新建一个Java 工程，然后在工程下面创建一个名为<strong>ModuleOne</strong>的模块：</p><p><img src="img/QQ截图20190213094527.png" alt="QQ截图20190213094527.png"></p><p>同样的，我们再创建一个<strong>ModuleTwo</strong>模块，创建完后项目目录如下所示：</p><p><img src="img/QQ截图20190213094722.png" alt="QQ截图20190213094722.png"></p><p>接着我们在ModuleOne的src目录下创建<code>cc.mrbird.domain</code>包，并创建一个名为Person的类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cc.mrbird.domain;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Person&#123;"</span> +</span><br><span class="line">                <span class="string">"name='"</span> + name + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">", age="</span> + age +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>然后在ModuleTwo的src目录下创建一个<code>cc.mrbid.test</code>包，并且创建一个Test类，用于待会测试。</p><p>至此，工程目录结构如下所示:</p><p><img src="img/QQ截图20190213095358.png" alt="QQ截图20190213095358.png"></p><p>我们在ModuleTwo的Test类下试图引入ModuleOne的Person类，会发现是行不通的：</p><p><img src="img/QQ截图20190213095624.png" alt="QQ截图20190213095624.png"></p><p>正如上面所说，模块里的东西默认都是隐藏的，要让其可以被别的模块使用，需要通过<strong>exports</strong>关键字来暴露它们。</p><p>在ModuleOne模块下的src上右键，新建一个module-info.java：</p><p><img src="img/QQ截图20190213095840.png" alt="QQ截图20190213095840.png"></p><p>代码如下所示:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> ModuleOne &#123;</span><br><span class="line">    <span class="comment">// 导出包</span></span><br><span class="line">    <span class="keyword">exports</span> cc.mrbird.domain;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>上面代码中导出了<code>cc.mrbird.domain</code>包下的所有内容，对别的模块来说，它们是可见的了。</p><p>然后同样地在ModuleTwo模块下的src上右键，也新建一个module-info.java，代码如下所示:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> ModuleTwo &#123;</span><br><span class="line">    <span class="comment">// 导入模块</span></span><br><span class="line">    <span class="keyword">requires</span> ModuleOne;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们主要做的是将ModuleOne导入进来，所以其暴露的<code>cc.mrbird.domain</code>包下的内容就可以在ModuleTwo下被使用了。</p><p>这时候回到ModuleTwo模块下的Test类，IDEA会自动帮我们导入需要的类，代码就不会报错了：</p><p><img src="img/QQ截图20190213100532.png" alt="QQ截图20190213100532.png"></p><p>我们继续在Test类中加入一些内容：</p><p><img src="img/QQ截图20190213101203.png" alt="QQ截图20190213101203.png"></p><p>上面我们使用了<code>java.util.logging.Logger</code>来打印日志，但是代码编译是不通过的，使用<code>Alt+Enter</code>快捷键后选择第一项，IDEA会自动帮我们在module-info.java文件中导入需要的包，非常方便。</p><p>导入后，module-info.java下的代码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> ModuleTwo &#123;</span><br><span class="line">    <span class="comment">// 导入模块</span></span><br><span class="line">    <span class="keyword">requires</span> ModuleOne;</span><br><span class="line">    <span class="keyword">requires</span> java.logging;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>总的来说，通过模块化来构建项目可以带来以下好处:</p><ol><li><p>减少内存的开销；</p></li><li><p>简化各种类库和大型应用的开发和维护；</p></li><li><p>改进其安全性，可维护性，提高性能。</p></li></ol><h2 id="jshell命令"><a href="#jshell命令" class="headerlink" title="jshell命令"></a>jshell命令</h2><p>在Java 9 之前，我们要想使用Java来输出一句hello world或者计算两个数的和都必须创建一个Java项目，然后创建类在里面写main方法来运行。Java 9 后就不必这样了，其提供了REPL工具：jshell。利用 jshell 在没有创建类的情况下直接声明变量，计算表达式，执行语句。即开发时可以在命令行里直接运行 Java 的代码，而无需创建 Java 文件。</p><p>在JDK 9 的bin目录下有个jshell.exe文件，我们运行它：</p><p><img src="img/QQ截图20190213103825.png" alt="QQ截图20190213103825.png"></p><p>下面演示一些jshell的常用操作。</p><p><strong>基本使用</strong></p><p><img src="img/QQ截图20190213104253.png" alt="QQ截图20190213104253.png"></p><div class="note info"><p>在jshell中，代码末尾的<code>;</code>是可选的。</p></div><p><strong>导包操作</strong></p><p><img src="img/QQ截图20190213104534.png" alt="QQ截图20190213104534.png"></p><p><strong>查看所有已经导入的包</strong></p><p><img src="img/QQ截图20190213104610.png" alt="QQ截图20190213104610.png"></p><p><strong>使用Tab键补全代码</strong></p><p><img src="img/QQ截图20190213104732.png" alt="QQ截图20190213104732.png"></p><p><strong>查看当前环境下所有有效代码</strong></p><p><img src="img/QQ截图20190213104840.png" alt="QQ截图20190213104840.png"></p><p><strong>查看当前环境下所有变量</strong></p><p><img src="img/QQ截图20190213104941.png" alt="QQ截图20190213104941.png"></p><p><strong>查看当前环境下所有方法</strong></p><p><img src="img/QQ截图20190213105231.png" alt="QQ截图20190213105231.png"></p><p><strong>使用外部代码编辑器来修改add方法</strong></p><p><img src="img/QQ截图20190213105412.png" alt="QQ截图20190213105412.png"></p><p>界面弹出：</p><p><img src="img/QQ截图20190213105500.png" alt="QQ截图20190213105500.png"></p><p>修改完毕点击Accept和Exit按钮即可：</p><p><img src="img/QQ截图20190213105553.png" alt="QQ截图20190213105553.png"></p><p><strong>加载外部代码</strong></p><p>在桌面新建一个Hello.java文件：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"hello world"</span>);</span><br><span class="line">&#125;</span><br><span class="line">hello();</span><br></pre></td></tr></table></figure><p></p><p>然后使用<code>/open</code>命令执行这个文件：</p><p><img src="img/QQ截图20190213110050.png" alt="QQ截图20190213110050.png"></p><p>更多关于jshell的功能介绍，可以使用<code>/help</code>命令来查看。</p><h2 id="接口中的私有方法"><a href="#接口中的私有方法" class="headerlink" title="接口中的私有方法"></a>接口中的私有方法</h2><p>我们都知道，在JDK 8之前，接口只能包含<code>public static final</code>的成员变量和<code>public abstract</code>修饰的抽象方法；而在JDK 8中，接口中可以定义静态方法和默认方法了；JDK 9的接口又加了新的特性，其允许接口中包含私有的方法，下面这个接口定义在JDK 9 中是合法的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">TestInterface</span> </span>&#123;</span><br><span class="line">    <span class="comment">// before jdk 7 :</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// jdk 8:</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"mehtod2"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">method3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"mehtod3"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// jdk 9:</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">method4</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"mehtod4"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h2 id="Diamond-Operator使用升级"><a href="#Diamond-Operator使用升级" class="headerlink" title="Diamond Operator使用升级"></a>Diamond Operator使用升级</h2><p>在Java 9 之前的版本中，我们不能将钻石操作符（Diamond Operator）和匿名实现类放在一起使用，比如下面这个例子在Java 9 之前的版本中编译是不通过的：</p><p><img src="img/QQ截图20190214091025.png" alt="QQ截图20190214091025.png"></p><p>而在Java 9中取消了这个限制，我们可以通过这个特性来进行一些初始化操作:</p><p><img src="img/QQ截图20190214091154.png" alt="QQ截图20190214091154.png"></p><h2 id="try使用升级"><a href="#try使用升级" class="headerlink" title="try使用升级"></a>try使用升级</h2><p>在Java 9 之前，我们可以使用下面这种优雅的方式来进行流的关闭操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> (InputStreamReader reader = <span class="keyword">new</span> InputStreamReader(System.in)) &#123;</span><br><span class="line">    reader.read();</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>在<code>try</code>后面的括号中声明初始化的流Java会自动帮我们进行关闭操作。Java 9 对这个特性进行了升级，我们可以在<code>try</code>后面的括号中使用已经初始化过的资源，此时的资源是<code>final</code>的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">InputStreamReader reader = <span class="keyword">new</span> InputStreamReader(System.in);</span><br><span class="line"><span class="keyword">try</span> (reader) &#123;</span><br><span class="line">    reader.read();</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>如果对<code>reader</code>再次进行赋值操作，编译将不通过：</p><p><img src="img/QQ截图20190214093344.png" alt="QQ截图20190214093344.png"></p><h2 id="下划线标识符的限制"><a href="#下划线标识符的限制" class="headerlink" title="下划线标识符的限制"></a>下划线标识符的限制</h2><p>Java 8 中，我们可以使用下划线<code>_</code>作为标识符使用，比如下面这段代码是合法的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String _ = <span class="string">"mrbird"</span>;</span><br><span class="line">System.out.println(_);</span><br></pre></td></tr></table></figure><p></p><p>而在Java 9 中，下划线<code>_</code>已经不能用于标识符了：</p><p><img src="img/QQ截图20190214094709.png" alt="QQ截图20190214094709.png"></p><h2 id="String存储结构变更"><a href="#String存储结构变更" class="headerlink" title="String存储结构变更"></a>String存储结构变更</h2><p>Java 9 之前，字符串的底层是用<code>char[]</code>进行存储的，Java 9 中，字符串改用成了<code>byte[]</code>进行存储:</p><p><img src="img/QQ截图20190214101945.png" alt="QQ截图20190214101945.png"></p><p>之所以做出这个改变是因为：大多数<code>String</code>类型对象存储的都是拉丁字符，这些字符只占一个字节，而<code>char</code>能够存储两个字节，所以大部分情况下都浪费了一半的存储空间。Java 9 将<code>String</code>类的内部表示从<code>UTF-16</code>的<code>char</code>数组更改为<code>byte</code>数组加上<code>encoding-flag</code>字段。新<code>String</code>类将根据字符串的内容存储编码为<code>ISO-8859-1</code> / Latin-1（每个字符一个字节）或<code>UTF-16</code>（每个字符两个字节）的字符。<code>encoding-flag</code>编码标志将指示使用哪种编码。</p><p>基于<code>String</code>的类如<code>StringBuffer</code>和<code>StringBuilder</code>等也是做出了相同的改变。</p><p>具体可参考：<a href="http://openjdk.java.net/jeps/254" target="_blank" rel="noopener">http://openjdk.java.net/jeps/254</a>。</p><h2 id="集合的of方法"><a href="#集合的of方法" class="headerlink" title="集合的of方法"></a>集合的<code>of</code>方法</h2><p>Java 9 之前我们可以使用下面的方式来创建不可变集合：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; list = Collections.unmodifiableList(Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>));</span><br><span class="line"></span><br><span class="line">Set&lt;Integer&gt; set = Collections.unmodifiableSet(<span class="keyword">new</span> HashSet&lt;&gt;(Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)));</span><br><span class="line"></span><br><span class="line">Map&lt;String, Object&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">map.put(<span class="string">"mrbird"</span>, <span class="number">18</span>);</span><br><span class="line">map.put(<span class="string">"kangkang"</span>, <span class="number">20</span>);</span><br><span class="line">Map&lt;String, Object&gt; map1 = Collections.unmodifiableMap(map);</span><br></pre></td></tr></table></figure><p></p><p>Java 9 中的集合类都添加了一个<code>of</code>方法，可以快速的构造不可变集合：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; list = List.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">Set&lt;Integer&gt; set = Set.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">Map&lt;String, Object&gt; map1 = Map.of(<span class="string">"mrbird"</span>, <span class="number">18</span>, <span class="string">"kangkang"</span>, <span class="number">20</span>);</span><br></pre></td></tr></table></figure><p></p><p>对不可变集合进行赋值操作将抛出异常：</p><p><img src="img/QQ截图20190214112738.png" alt="QQ截图20190214112738.png"></p><h2 id="增强的Steam-API"><a href="#增强的Steam-API" class="headerlink" title="增强的Steam API"></a>增强的Steam API</h2><p>在 Java 9 中，Stream API变得更好，Stream接口中添加了 4 个新的方法：<code>dropWhile</code>, <code>takeWhile</code>, <code>ofNullable</code>，还有个 <code>iterate</code>方法的新重载方法，可以让你提供一个<code>Predicate</code>（判断条件）来指定什么时候结束迭代。</p><p>下面举例来演示这几个的用法：</p><p><strong>takeWhile</strong></p><p>takeWhile用于从Stream中获取一部分数据，接收一个Predicate来进行选择。在有序的Stream中，takeWhile返回从开头开始的尽量多的元素。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; list = Arrays.asList(<span class="number">45</span>, <span class="number">43</span>, <span class="number">76</span>, <span class="number">87</span>, <span class="number">42</span>, <span class="number">77</span>, <span class="number">90</span>, <span class="number">73</span>, <span class="number">67</span>, <span class="number">88</span>);</span><br><span class="line">list.stream().takeWhile(x -&gt; x &lt; <span class="number">50</span>).forEach(System.out::println);</span><br></pre></td></tr></table></figure><p></p><p>结果输出:</p><p><img src="img/QQ截图20190214135831.png" alt="QQ截图20190214135831.png"></p><p>程序从头开始判断当前值是否小于50，当判断到第三个元素76时，发现不满足，于是程序就结束了。所以<code>takeWhile</code>不同于过滤器。</p><p><strong>dropWhile</strong></p><p>dropWhile的行为与takeWhile相反，返回剩余的元素：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; list = Arrays.asList(<span class="number">45</span>, <span class="number">43</span>, <span class="number">76</span>, <span class="number">87</span>, <span class="number">42</span>, <span class="number">77</span>, <span class="number">90</span>, <span class="number">73</span>, <span class="number">67</span>, <span class="number">88</span>);</span><br><span class="line">list.stream().dropWhile(x -&gt; x &lt; <span class="number">50</span>).forEach(System.out::println);</span><br></pre></td></tr></table></figure><p></p><p>程序输出:</p><p><img src="img/QQ截图20190214140313.png" alt="QQ截图20190214140313.png"></p><p><strong>ofNullable</strong></p><p>Java 8 中Stream不能完全为null（只有一个元素，且为null），否则会报空指针异常。而Java 9 中的ofNullable 方法允许我们创建一个单元素 Stream，可以包含一个非空元素，也可以创建一个空 Stream：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 报 NullPointerException</span></span><br><span class="line"><span class="comment">// Stream&lt;Object&gt; stream1 = Stream.of(null);</span></span><br><span class="line"><span class="comment">// System.out.println(stream1.count());</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 不报异常，允许通过</span></span><br><span class="line">Stream&lt;String&gt; stringStream = Stream.of(<span class="string">"AA"</span>, <span class="string">"BB"</span>, <span class="keyword">null</span>);</span><br><span class="line">System.out.println(stringStream.count()); <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 不报异常，允许通过</span></span><br><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">list.add(<span class="string">"AA"</span>);</span><br><span class="line">list.add(<span class="keyword">null</span>);</span><br><span class="line">System.out.println(list.stream().count()); <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ofNullable()：允许值完全为 null</span></span><br><span class="line">Stream&lt;Object&gt; stream1 = Stream.ofNullable(<span class="keyword">null</span>);</span><br><span class="line">System.out.println(stream1.count()); <span class="comment">// 0</span></span><br><span class="line"></span><br><span class="line">Stream&lt;String&gt; stream = Stream.ofNullable(<span class="string">"hello world"</span>);</span><br><span class="line">System.out.println(stream.count()); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><p></p><p><strong>Steam iterator的重载方法</strong></p><p><img src="img/QQ截图20190214141552.png" alt="QQ截图20190214141552.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Java 8 中的</span></span><br><span class="line">Stream.iterate(<span class="number">0</span>, x -&gt; x + <span class="number">1</span>).limit(<span class="number">10</span>).forEach(System.out::println);</span><br><span class="line"><span class="comment">// 等价于 Java 9 中的</span></span><br><span class="line">Stream.iterate(<span class="number">0</span>, x -&gt; x &lt; <span class="number">10</span>, x -&gt; x + <span class="number">1</span>).forEach(System.out::println);</span><br></pre></td></tr></table></figure><p>除了上面几个新特性外，Java 9 还支持将optional转换为流的操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">list.add(<span class="string">"mrbird"</span>);</span><br><span class="line">list.add(<span class="string">"kangkang"</span>);</span><br><span class="line">list.add(<span class="string">"maria"</span>);</span><br><span class="line"></span><br><span class="line">Optional&lt;List&lt;String&gt;&gt; optional = Optional.of(list);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 流中的元素为 list</span></span><br><span class="line">Stream&lt;List&lt;String&gt;&gt; stream = optional.stream();</span><br><span class="line">stream.forEach(System.out::println);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 流中的元素为 list中的每个元素</span></span><br><span class="line">Stream&lt;String&gt; stringStream = optional.stream().flatMap(Collection::stream);</span><br><span class="line">stringStream.forEach(System.out::println);</span><br></pre></td></tr></table></figure><p></p><p>程序输出：</p><p><img src="img/QQ截图20190214143228.png" alt="QQ截图20190214143228.png"></p><h2 id="HTTP-Client"><a href="#HTTP-Client" class="headerlink" title="HTTP Client"></a>HTTP Client</h2><p>Java 9 中新增了全新的<code>HttpClient</code>来替代<code>HttpURLConnection</code>，其可以从<code>jdk.incubator.httpclient</code>模块中获取。因为在默认情况下，这个模块是不能根据<code>classpath</code>获取的，需要使用<code>add modules</code>命令选项配置这个模块，将这个模块添加到 classpath中。</p><p>我们在src下的module-info.java中引入这个模块：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">requires</span> jdk.incubator.httpclient;</span><br></pre></td></tr></table></figure><p></p><p>写个基于<code>HttpClient</code>的例子:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">HttpClient client = HttpClient.newHttpClient();</span><br><span class="line">HttpRequest req = HttpRequest.newBuilder(URI.create(<span class="string">"https://mrbird.cc"</span>))</span><br><span class="line">                .GET()</span><br><span class="line">                .build();</span><br><span class="line">HttpResponse&lt;String&gt; response = client.send(req, HttpResponse.BodyHandler.asString());</span><br><span class="line">System.out.println(response.statusCode());</span><br><span class="line">System.out.println(response.version().name());</span><br><span class="line">System.out.println(response.body());</span><br></pre></td></tr></table></figure><p></p><p>输出结果：</p><p><img src="img/QQ截图20190214145555.png" alt="QQ截图20190214145555.png"></p><blockquote><p>参考自：<a href="https://www.jianshu.com/u/5f70a16b98e7" target="_blank" rel="noopener">https://www.jianshu.com/u/5f70a16b98e7</a></p></blockquote><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Thu Apr 04 2019 14:23:35 GMT+0800 (GMT+08:00) --&gt;&lt;p&gt;在Java 8 发布3年多后，Java 9 终于在2017年9月21日正式发布。Java 9 提供了超过150项新功能特性，包括备受期待的模块化系统、 可交互的REPL工具jShell、JDK编译工具、Java公共API和私有代码，以及安全增强、扩展提升和性能管理改善等。在学习这些新特性之前，我们得先安装好JDK 9，JDK 9 下载地址：&lt;a href=&quot;https://www.oracle.com/technetwork/cn/java/javase/downloads/jdk9-downloads-3848520-zhs.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.oracle.com/technetwork/cn/java/javase/downloads/jdk9-downloads-3848520-zhs.html&lt;/a&gt;。
    
    </summary>
    
    
      <category term="Java" scheme="http://mrbird.cc/tags/Java/"/>
    
      <category term="Java 9" scheme="http://mrbird.cc/tags/Java-9/"/>
    
  </entry>
  
  <entry>
    <title>学习Dockerfile</title>
    <link href="http://mrbird.cc/Dockerfile.html"/>
    <id>http://mrbird.cc/Dockerfile.html</id>
    <published>2018-10-18T09:14:26.000Z</published>
    <updated>2019-04-01T02:33:31.822Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Apr 04 2019 14:23:34 GMT+0800 (GMT+08:00) --><p>在 <a href="https://mrbird.cc/Docker-Image-Container.html">Docker 镜像与容器</a> 一节中我们通过Dockerfile构建了镜像，这节我们来了解下Dockerfile的语法。Dockerfile包含了诸多关键字，所以要学习Dockerfile的用法，得先从这些关键字入手。</p><a id="more"></a><h2 id="FROM"><a href="#FROM" class="headerlink" title="FROM"></a>FROM</h2><p>位于Dockerfile开头，表示基于什么镜像构建：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">FROM scratch # 制作base image</span><br><span class="line">FROM ubuntu:16.04 #使用ubuntu:16.04这个image</span><br></pre></td></tr></table></figure><p></p><div class="note info"><p>出于安全考虑，最好使用官方的image作为base image。</p></div><h2 id="LABEL"><a href="#LABEL" class="headerlink" title="LABEL"></a>LABEL</h2><p>Dockerfile的元数据，描述作用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LABEL version=&quot;1.0&quot; author=&quot;mrbird&quot; description=&quot;dockerfile demo&quot;</span><br></pre></td></tr></table></figure><p></p><div class="note info"><p>Dockerfile最好都要有元数据，这样更易于理解。</p></div><h2 id="RUN"><a href="#RUN" class="headerlink" title="RUN"></a>RUN</h2><p>运行命令，每次run都会生成一个图层，所以最好将命令合并:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">FROM ubuntu</span><br><span class="line">RUN apt-get update \</span><br><span class="line">    &amp;&amp; apt-get install -y vim</span><br></pre></td></tr></table></figure><p></p><p><code>\</code>换行</p><h2 id="WORKDIR"><a href="#WORKDIR" class="headerlink" title="WORKDIR"></a>WORKDIR</h2><p>用于指定工作目录，切换路径：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">FROM ubuntu</span><br><span class="line">WORKDIR /test # 没有则自动创建test目录</span><br><span class="line">WORKDIR demo</span><br><span class="line">RUN pwd</span><br></pre></td></tr></table></figure><p></p><p>输出 /test/demo。</p><div class="note info"><p>最好不要用RUN cd来切换目录，而使用WORKDIR，这样可以减少不必要的图层，尽量使用绝对目录。</p></div><h2 id="ADD-amp-COPY"><a href="#ADD-amp-COPY" class="headerlink" title="ADD &amp; COPY"></a>ADD &amp; COPY</h2><p>ADD 和COPY都可以将构建环境中的文件或目录复制到镜像中，比如</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">WORKDIR /demo</span><br><span class="line">ADD test test/</span><br></pre></td></tr></table></figure><p></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">WORKDIR /demo</span><br><span class="line">COPY test test/</span><br></pre></td></tr></table></figure><p>最终都会将test文件添加到/demo/test/目录下。</p><p>区别：</p><ol><li><p>ADD 添加的文件是压缩文件的话，会自动解压。</p></li><li><p>COPY 只能复制构建目录下的文件，ADD可以添加一个构建上下文中的文件或目录，也可以是一个URL，如：</p></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ADD http://wordpress.org/latest.zip /</span><br></pre></td></tr></table></figure><h2 id="ENV"><a href="#ENV" class="headerlink" title="ENV"></a>ENV</h2><p>设置环境变量常量。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ENV MYSQL_VERSION 5.7</span><br><span class="line">RUN apt-get install -y mysql-server=&quot;$&#123;MYSQL_VERSION&#125;&quot;</span><br></pre></td></tr></table></figure><p></p><div class="note info"><p>通过设定常量，可以提高可维护性。</p></div><h2 id="VOLUME-amp-EXPOSE"><a href="#VOLUME-amp-EXPOSE" class="headerlink" title="VOLUME &amp; EXPOSE"></a>VOLUME &amp; EXPOSE</h2><p>存储和网络，这里先略，后面学习到这一块再说。</p><h2 id="CMD"><a href="#CMD" class="headerlink" title="CMD"></a>CMD</h2><ol><li><p>设置容器启动后默认执行的命令和参数。</p></li><li><p>docker run指定了其他命令，CMD命令会被忽略。</p></li><li><p>定义了多个CMD，只有最后一个有效。</p></li></ol><p>比如有如下Dockerfile：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">FROM ubuntu</span><br><span class="line">ENV name mrbird</span><br><span class="line">CMD echo &quot;hello docker&quot;</span><br><span class="line">CMD echo &quot;hello $name&quot;</span><br></pre></td></tr></table></figure><p></p><p>构建镜像，运行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run [image]</span><br></pre></td></tr></table></figure><p></p><p>输出 hello mrbird。</p><p>如果运行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it [image] /bin/bash</span><br></pre></td></tr></table></figure><p>则没有输出。</p><h2 id="ENTRYPOINT"><a href="#ENTRYPOINT" class="headerlink" title="ENTRYPOINT"></a>ENTRYPOINT</h2><ol><li><p>设置容器启动时运行的命令。</p></li><li><p>不会被忽略，一定会执行。</p></li><li><p>一般写一个shell脚本作为ENTRYPOINT。</p></li></ol><p>比如mongodb官方Dockerfile末尾一段：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">COPY docker-entrypoint.sh /usr/local/bin/</span><br><span class="line">ENTRYPOINT [&quot;docker-entrypoint.sh&quot;]</span><br><span class="line"></span><br><span class="line">EXPOSE 27017</span><br><span class="line">CMD [&quot;mongod&quot;]</span><br></pre></td></tr></table></figure><p></p><p>ENTRYPOINT和CMD结合使用有一个技巧：</p><p>比如有如下一个Dockerfile：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">FROM ubuntu</span><br><span class="line">ENTRYPOINT [&quot;/bin/ls&quot;]</span><br><span class="line">CMD []</span><br></pre></td></tr></table></figure><p></p><p>意思是在ubuntu这个镜像上构建，通过ENTRYPOINT运行/bin/ls命令，然后<code>CMD []</code>这行可以介绍额外的参数选项。</p><p>通过这个Dockerfile构建镜像后(image id为95c35bb00761)，分别运行下面这些命令来创建容器：</p><p><img src="img/QQ截图20190331231033.png" alt="QQ截图20190331231033.png"></p><p>可以看到我们通过相同的镜像构建出了不同的容器。</p><h2 id="Shell和Exec格式"><a href="#Shell和Exec格式" class="headerlink" title="Shell和Exec格式"></a>Shell和Exec格式</h2><p>在Dockerfile中，命令的写法有Shell格式和Exec格式：</p><p>Shell格式的Dockerfile如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">RUN apt-get install -y vim</span><br><span class="line">CMD echo &quot;hello world&quot;</span><br><span class="line">ENTRYPOINTT echo &quot;hello world&quot;</span><br></pre></td></tr></table></figure><p></p><p>Exec格式如下所示:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">RUN [&quot;apt-get&quot;,&quot;install&quot;,&quot;-y&quot;,&quot;vim&quot;]</span><br><span class="line">CMD [&quot;/bin/echo&quot;,&quot;hello world&quot;]</span><br><span class="line">ENTRYPOINTT [&quot;/bin/echo&quot;,&quot;hello world&quot;]</span><br></pre></td></tr></table></figure><p></p><p>在使用Exec格式的时候需要注意和常量的搭配使用问题，比如在Shell格式下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">FROM ubuntu</span><br><span class="line">ENV name mrbird</span><br><span class="line">ENTRYPOINTER echo &quot;hello $name&quot;</span><br></pre></td></tr></table></figure><p></p><p>创建镜像，运行容器后输出：hello mrbird。</p><p>但是在Exec格式下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">FROM ubuntu</span><br><span class="line">ENV name mrbird</span><br><span class="line">ENTRYPOINTER [&quot;/bin/echo&quot;,&quot;hello $name&quot;]</span><br></pre></td></tr></table></figure><p></p><p>创建镜像，运行容器后输出：hello $name。</p><p>正确的写法是:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">FROM ubuntu</span><br><span class="line">ENV name mrbird</span><br><span class="line">ENTRYPOINTER [&quot;/bin/bash&quot;,&quot;-c&quot;,&quot;echo hello $name&quot;]</span><br></pre></td></tr></table></figure><p></p><p>参考文档：<a href="https://docs.docker.com/engine/reference/builder/" target="_blank" rel="noopener">https://docs.docker.com/engine/reference/builder/</a></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Thu Apr 04 2019 14:23:34 GMT+0800 (GMT+08:00) --&gt;&lt;p&gt;在 &lt;a href=&quot;https://mrbird.cc/Docker-Image-Container.html&quot;&gt;Docker 镜像与容器&lt;/a&gt; 一节中我们通过Dockerfile构建了镜像，这节我们来了解下Dockerfile的语法。Dockerfile包含了诸多关键字，所以要学习Dockerfile的用法，得先从这些关键字入手。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Docker" scheme="http://mrbird.cc/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>Docker 镜像与容器</title>
    <link href="http://mrbird.cc/Docker-Image-Container.html"/>
    <id>http://mrbird.cc/Docker-Image-Container.html</id>
    <published>2018-10-15T09:14:26.000Z</published>
    <updated>2019-04-01T02:33:31.821Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Apr 04 2019 14:23:35 GMT+0800 (GMT+08:00) --><p>开始之前，可以通过<a href="https://mrbird.cc/Create-Virtual-Machine-By-Vagrant.html"> Vagrant构建一个CentOS环境 </a>，然后根据<a href="https://docs.docker.com/install/linux/docker-ce/centos/" target="_blank" rel="noopener"> 官方文档 </a>来安装Dokcer，下面的例子运行在CentOS7环境下。</p><p>Docker Image俗称Docker镜像，它是由一系列图层（Layer）构成的，每个图层代表Dockerfile（通过Dockerfile我们可以创建镜像）中的一行指令，镜像是只读的。</p><p>那什么是Dockerfile呢，举个简单的Dockerfile示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">FROM centos</span><br><span class="line">RUN yum install -y vim</span><br></pre></td></tr></table></figure><a id="more"></a><p>上面的Dockerfile包含两行命令（所以它对应两个图层），第一行表示从centos这个镜像中创建一个图层，然后第二行表示接着运行<code>yum install -y vim</code>来安装vim。通过这个Dockerfile我们可以构建一个镜像，通过镜像我们可以创建一个容器（Container）。</p><p>什么是Docker容器？容器是通过镜像构建的一个隔离的应用平台，它包含了运行应用程序所需要的一切。和镜像相比，它在顶部多了一层可读写图层，就如下图所示：</p><p><img src="img/container-layers.jpg" alt="container-layers.jpg"></p><p>镜像和容器的关系就像是Java里类与对象的关系那样，镜像是构建容器的模板，容器是镜像构建出来的实例。</p><h2 id="Docker镜像"><a href="#Docker镜像" class="headerlink" title="Docker镜像"></a>Docker镜像</h2><p>通过<code>docker image ls</code>查看当前有哪些镜像（等价于<code>docker images</code>）：</p><p><img src="img/QQ截图20190331095417.png" alt="QQ截图20190331095417.png"></p><p>当前暂无镜像，可以通过<code>docker pull [OPTIONS] NAME[:TAG|@DIGEST]</code>来从<a href="https://hub.docker.com/" target="_blank" rel="noopener"> DockerHub </a>拉取镜像，比如拉取一个Ubuntu镜像：</p><p><img src="img/QQ截图20190331100325.png" alt="QQ截图20190331100325.png"></p><p><img src="img/QQ截图20190331100459.png" alt="QQ截图20190331100459.png"></p><p>不带tag则是拉取最新的镜像，可以通过tag来指定拉取的版本，比如拉取Ubuntu16.04：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull ubuntu:16.04</span><br></pre></td></tr></table></figure><p>可以通过<code>docker history [OPTIONS] IMAGE</code>来查看image的构建历史（图层）：</p><p><img src="img/QQ截图20190331101129.png" alt="QQ截图20190331101129.png"></p><p>可以通过镜像的名称或者镜像ID来指定。使用镜像ID的时候，可以只指定前几位，只要能唯一标识一个镜像即可，所以上面的94e814e2efa8可以简写为94e。</p><p>删除镜像使用的命令为<code>docker image rm [OPTIONS] IMAGE [IMAGE...]</code>，等价于<code>docker rmi [OPTIONS] IMAGE [IMAGE...]</code>。</p><p>更多关于镜像的命令可以使用<code>docker image --help</code>来查看：</p><p><img src="img/QQ截图20190331101445.png" alt="QQ截图20190331101445.png"></p><h2 id="Docker容器"><a href="#Docker容器" class="headerlink" title="Docker容器"></a>Docker容器</h2><p>可以通过<code>docker run [OPTIONS] IMAGE [COMMAND] [ARG...]</code>命令来运行镜像，生成容器，比如运行刚刚拉去下来的ubuntu镜像，然后通过<code>docker container ls</code>命令查看当前正在运行的容器：</p><p><img src="img/QQ截图20190331102102.png" alt="QQ截图20190331102102.png"></p><p>没有正在运行的容器，我们可以通过<code>docker container ls -a</code>命令来查看所有状态下的容器（可简写为<code>docker ps -a</code>）：</p><p><img src="img/QQ截图20190331102258.png" alt="QQ截图20190331102258.png"></p><p>可看到，ubuntu这个容器状态为Exited退出状态，要让运行容器常驻，可以使用<code>docker run -it</code>命令：</p><p><img src="img/QQ截图20190331104039.png" alt="QQ截图20190331104039.png"></p><p>我们已经进入到ubuntu容器环境里了，可以在上面执行任何ubuntu支持的操作。</p><p>这时候新开一个cmd窗口，查看目前容器的状态：</p><p><img src="img/QQ截图20190331104311.png" alt="QQ截图20190331104311.png"></p><p>上面包含了一开始创建的exited状态的容器以及常驻内存的状态为up的容器。</p><p>退出容器环境使用<code>exit</code>命令即可。</p><p>可以使用<code>docker container rm [OPTIONS] CONTAINER [CONTAINER...]</code>命令来删除容器：</p><p><img src="img/QQ截图20190331104628.png" alt="QQ截图20190331104628.png"></p><p>上面的命令也可以简化为<code>docker rm dd1</code>。</p><p>可以通过<code>docker rm $(docker container ls -aq)</code>命令来一次性删除全部的container，<code>docker container ls -aq</code>作用为列出所有container id。</p><p>可以使用<code>docker rm $(docker container ls -f &quot;status=xxx&quot; -q)</code>来删除指定状态的容器，比如仅删除状态为Exited的容器：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rm $(docker container ls -f <span class="string">"status=exited"</span> -q)</span><br></pre></td></tr></table></figure><h3 id="容器状态改变"><a href="#容器状态改变" class="headerlink" title="容器状态改变"></a>容器状态改变</h3><p>对于Exited状态的容器，我们可以使用<code>docker container start</code>来启动容器：</p><p><img src="img/QQ截图20190331114534.png" alt="QQ截图20190331114534.png"></p><p>进入运行中的容器的命令为：</p><p><img src="img/QQ截图20190331114651.png" alt="QQ截图20190331114651.png"></p><p>暂停容器：</p><p><img src="img/QQ截图20190331114904.png" alt="QQ截图20190331114904.png"></p><p>恢复容器：</p><p><img src="img/QQ截图20190331115022.png" alt="QQ截图20190331115022.png"></p><p>停止容器:</p><p><img src="img/QQ截图20190331115119.png" alt="QQ截图20190331115119.png"></p><p>下图展示了Docker容器的完整生命周期：</p><p><img src="img/1_vca4e-SjpzSL5H401p4LCg.png" alt="1_vca4e-SjpzSL5H401p4LCg.png"></p><p>更多关于container的命令可以使用<code>docker container --help</code>来查看：</p><p><img src="img/QQ截图20190331105035.png" alt="QQ截图20190331105035.png"></p><h2 id="Docker镜像的构建"><a href="#Docker镜像的构建" class="headerlink" title="Docker镜像的构建"></a>Docker镜像的构建</h2><p>Docker镜像的构建有两种方式：基于容器commit和通过Dockerfile构建。</p><h3 id="基于容器"><a href="#基于容器" class="headerlink" title="基于容器"></a>基于容器</h3><p>比如我们在刚刚运行中的unubtu容器中安装vim插件：</p><p><img src="img/QQ截图20190331110009.png" alt="QQ截图20190331110009.png"></p><p>然后exit退出，使用<code>docker commit [OPTIONS] CONTAINER [REPOSITORY[:TAG]]</code>命令来创建一个新的镜像：</p><p><img src="img/QQ截图20190331110834.png" alt="QQ截图20190331110612.png"></p><p>查看该镜像的history：</p><p><img src="img/QQ截图20190331111115.png" alt="QQ截图20190331111115.png"></p><p>停止容器：</p><p><img src="img/QQ截图20190331115119.png" alt="QQ截图20190331115119.png"></p><p>可以看到，它是在id为94e814e2efa8镜像上加了一层图层，id为cc7609287eaa，也就是新的镜像的id。</p><p>一般不推荐这种方式来构建镜像，因为通过修改容器commit来构建新的镜像，我们不清楚原来的容器被修改了什么（比如安装恶意软件）。推荐的做法是通过Dockerfile来构建镜像。</p><h3 id="基于Dockerfile"><a href="#基于Dockerfile" class="headerlink" title="基于Dockerfile"></a>基于Dockerfile</h3><p>新建一个目录：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir ubuntu-vim</span><br></pre></td></tr></table></figure><p></p><p>然后在该目录下编辑Dockerfile</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd ubuntu-vim</span><br><span class="line">vim Dockerfile</span><br></pre></td></tr></table></figure><p></p><p>Dockerfile内容如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">FROM ubuntu</span><br><span class="line">RUN apt-get update</span><br><span class="line">RUN apt-get install</span><br><span class="line">RUN apt-get install -y vim</span><br></pre></td></tr></table></figure><p></p><p>意思是在ubuntu这个镜像基础上，分别运行<code>apt-get update</code>，<code>apt-get install</code>和<code>apt-get install -y vim</code>（<code>-y</code>指的是在命令行交互提示中，直接输入 yes）。</p><p>创建好这个Dockerfile后，运行下面这条命令来构建镜像：</p><p><img src="img/QQ截图20190331113351.png" alt="QQ截图20190331113351.png"></p><p>意思是通过当前目录下的Dockerfile构建进行，镜像名称为<code>mrbird/ubuntu-vim-dk</code>。</p><p>构建好后，查看当前镜像列表：</p><p><img src="img/QQ截图20190331113531.png" alt="QQ截图20190331113531.png"></p><p>其大小和我之前通过修改容器的方式构建的镜像一样。查看其history：</p><p><img src="img/QQ截图20190331113654.png" alt="QQ截图20190331113654.png"></p><p>可以看到Dockerfile的每一行RUN指令都创建了一个新的图层，通过这种方式来构建镜像的好处是，我们可以通过分享Dockerfile的方式来分享容器，并且对原镜像的修改过程一目了然。</p><h2 id="发布镜像"><a href="#发布镜像" class="headerlink" title="发布镜像"></a>发布镜像</h2><p>我们可以将本地构建的镜像发布到<a href="https://hub.docker.com/" target="_blank" rel="noopener"> Docker Hub </a>上。</p><p>首先得在 Docker Hub 上注册个账号：</p><p><img src="img/QQ截图20190331161039.png" alt="QQ截图20190331161039.png"></p><p>我的id为wuyouzhuguli。</p><p>然后新建一个目录，并创建一个Dockerfile：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkdir hello</span><br><span class="line">cd hello</span><br><span class="line">vim Dockerfile</span><br></pre></td></tr></table></figure><p></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">FROM centos</span><br><span class="line">LABEL user=&quot;mrbird&quot; email=&quot;852252810@qq.com&quot; description=&quot;hello demo&quot;</span><br><span class="line">CMD echo &quot;hello docker by mrbird&quot;</span><br></pre></td></tr></table></figure><p>接着通过这个Dockerfile构建镜像:</p><p><img src="img/QQ截图20190331161533.png" alt="QQ截图20190331161533.png"></p><p>tag部分必须和上面注册账号一致。</p><p>然后使用命令<code>docker login</code>登录 Docker：</p><p><img src="img/QQ截图20190331161658.png" alt="QQ截图20190331161658.png"></p><p>登录成功，开始push操作：</p><p><img src="img/QQ截图20190331161942.png" alt="QQ截图20190331161942.png"></p><p>push成功，查看 Docker Hub：</p><p><img src="img/QQ截图20190331162042.png" alt="QQ截图20190331162042.png"></p><h3 id="关联Github创建"><a href="#关联Github创建" class="headerlink" title="关联Github创建"></a>关联Github创建</h3><p>除了通过<code>docker push</code>往Docker Hub上传镜像外，我们可以通过关联Github仓库的方式来创建镜像。</p><p>首先在Github下新建一个仓库，然后上传Dockerfile：</p><p><img src="img/QQ截图20190331164522.png" alt="QQ截图20190331164522.png"></p><p>然后回到Docker Hub，新建一个仓库：</p><p><img src="img/QQ截图20190331164646.png" alt="QQ截图20190331164646.png"></p><p>关联Github账号，然后点击Create，然后在Builds选项卡里选择Github：</p><p><img src="img/QQ截图20190331164816.png" alt="QQ截图20190331164816.png"></p><p>然后选择Github的Dockerfiles仓库，路径选择hello：</p><p><img src="img/QQ截图20190331164927.png" alt="QQ截图20190331164927.png"></p><p>点击save and build按钮后，Docker Hub会根据关联的Github仓库下的Dockerfile来构建一个镜像：</p><p><img src="img/QQ截图20190331165631.png" alt="QQ截图20190331165631.png"></p><p><img src="img/QQ截图20190331165713.png" alt="QQ截图20190331165713.png"></p><p>一般推荐这种方式。</p><p>参考链接：</p><ol><li><p><a href="https://docs.docker.com/v17.09/engine/userguide/storagedriver/imagesandcontainers/#images-and-layers" target="_blank" rel="noopener">https://docs.docker.com/v17.09/engine/userguide/storagedriver/imagesandcontainers/#images-and-layers</a></p></li><li><p><a href="https://stackoverflow.com/questions/21498832/in-docker-whats-the-difference-between-a-container-and-an-image" target="_blank" rel="noopener">https://stackoverflow.com/questions/21498832/in-docker-whats-the-difference-between-a-container-and-an-image</a></p></li></ol><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Thu Apr 04 2019 14:23:35 GMT+0800 (GMT+08:00) --&gt;&lt;p&gt;开始之前，可以通过&lt;a href=&quot;https://mrbird.cc/Create-Virtual-Machine-By-Vagrant.html&quot;&gt; Vagrant构建一个CentOS环境 &lt;/a&gt;，然后根据&lt;a href=&quot;https://docs.docker.com/install/linux/docker-ce/centos/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt; 官方文档 &lt;/a&gt;来安装Dokcer，下面的例子运行在CentOS7环境下。&lt;/p&gt;&lt;p&gt;Docker Image俗称Docker镜像，它是由一系列图层（Layer）构成的，每个图层代表Dockerfile（通过Dockerfile我们可以创建镜像）中的一行指令，镜像是只读的。&lt;/p&gt;&lt;p&gt;那什么是Dockerfile呢，举个简单的Dockerfile示例：&lt;/p&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;FROM centos&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;RUN yum install -y vim&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="Docker" scheme="http://mrbird.cc/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>使用Vagrant创建CentOS虚拟机</title>
    <link href="http://mrbird.cc/Create-Virtual-Machine-By-Vagrant.html"/>
    <id>http://mrbird.cc/Create-Virtual-Machine-By-Vagrant.html</id>
    <published>2018-10-10T07:07:19.000Z</published>
    <updated>2019-04-01T02:33:31.805Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Apr 04 2019 14:23:35 GMT+0800 (GMT+08:00) --><p>Vagrant是一款由HashiCorp公司提供的，用于快速构建虚拟机环境的软件。本节我们将使用Vagrant结合Oracle VM VirtualBox快速地在win10环境下构建CentOS7虚拟机。在此之前需要先安装好 <a href="https://www.vagrantup.com/downloads.html" target="_blank" rel="noopener">Vagrant</a> 和 <a href="https://www.virtualbox.org/" target="_blank" rel="noopener">VirtualBox</a>。</p><a id="more"></a><h2 id="构建CentOS7虚拟机"><a href="#构建CentOS7虚拟机" class="headerlink" title="构建CentOS7虚拟机"></a>构建CentOS7虚拟机</h2><p>在<a href="https://app.vagrantup.com/boxes/search" target="_blank" rel="noopener">https://app.vagrantup.com/boxes/search</a>下搜索centos：</p><p><img src="img/QQ截图20190328162307.png" alt="QQ截图20190328162307.png"></p><p>然后在win10任意盘符下创建vagrant_vm目录（注意目录最好不要有中文和空格），然后在该目录下使用cmd执行<code>vagrant init centos/7</code>命令：</p><p><img src="img/QQ截图20190328201613.png" alt="QQ截图20190328201613.png"></p><p>然后执行<code>vagrant up</code>启动（这时候最好也打开VirtualBox）：</p><p><img src="img/QQ截图20190328202035.png" alt="QQ截图20190328202035.png"></p><p>构建完毕，这时候VirtualBox的列表里会出现一台正在运行的虚拟机：</p><p><img src="img/QQ截图20190328202353.png" alt="QQ截图20190328202353.png"></p><p>这就是我们刚刚通过Vagrant构建的CentOS7虚拟机了。</p><p>如果当你执行<code>vagrant up</code>命令后，虚拟机文件下载非常的慢的话，可以使用下面这种方式来构建：</p><p>在上面的日志中可以找到这么一行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Downloading: https://vagrantcloud.com/centos/boxes/7/versions/1902.01/providers/virtualbox.box</span><br></pre></td></tr></table></figure><p></p><p>后面这个URL就是下载地址了，将它黏贴到迅雷等下载工具下载即可。然后将下载好后的xxx.box文件复制到vagrant_vm目录下，并且重命名为centos7.box（删除centos7.box之外的文件和目录，只保留centos7.box一个文件）。</p><p>接着运行<code>vagrant box add -name &#39;centos/7&#39; centos7.box</code>命令：</p><p><img src="img/QQ截图20190328203659.png" alt="QQ截图20190328203659.png"></p><p>添加成功后执行<code>vagrant init centos/7</code>初始化：</p><p><img src="img/QQ截图20190328203846.png" alt="QQ截图20190328203846.png"></p><p>初始化成功后执行<code>vagrant up</code>启动：</p><p><img src="img/QQ截图20190328204151.png" alt="QQ截图20190328204151.png"></p><p>构建成功，效果和一开始在线下载构建是一样的。</p><h2 id="连接虚拟机"><a href="#连接虚拟机" class="headerlink" title="连接虚拟机"></a>连接虚拟机</h2><p>我们先用<code>vagrant status</code>命令查看一下虚拟机的状态：</p><p><img src="img/QQ截图20190328210130.png" alt="QQ截图20190328210130.png"></p><p>可以看到虚拟机是运行中的状态，我们可以执行<code>vagrant halt</code>来关闭虚拟机：</p><p><img src="img/QQ截图20190328210245.png" alt="QQ截图20190328210245.png"></p><p><img src="img/QQ截图20190328210316.png" alt="QQ截图20190328210316.png"></p><p>启动虚拟机的命令为<code>vagrant up</code>，我们也可以使用<code>vagrant suspend</code>命令来暂停运行中的虚拟机，以保持它的运行状态：</p><p><img src="img/QQ截图20190328210643.png" alt="QQ截图20190328210643.png"></p><p><img src="img/QQ截图20190328210742.png" alt="QQ截图20190328210742.png"></p><p>暂停后可以使用<code>vagrant resume</code>命令来恢复虚拟机：</p><p><img src="img/QQ截图20190328211115.png" alt="QQ截图20190328211115.png"></p><p>连接正在运行中的虚拟机的命令为<code>vagrant ssh</code>：</p><p><img src="img/QQ截图20190328211400.png" alt="QQ截图20190328211400.png"></p><p>重启虚拟机使用的命令为<code>vagrant reload</code>。如果你不想要这个虚拟机的话可以使用<code>vagrant distroy</code>命令进行销毁。</p><h2 id="目录共享"><a href="#目录共享" class="headerlink" title="目录共享"></a>目录共享</h2><p>Vagrant的根目录（就是我们一开始创建的vagrant_vm）和虚拟机里的/vagrant目录是共享的。我们在vagrant_vm目录下新建一个hello.txt文件，内容为hello：</p><p><img src="img/QQ截图20190328212914.png" alt="QQ截图20190328212914.png"></p><p>然后连接虚拟机，查看虚拟机/vagrant目录下有什么内容:</p><p><img src="img/QQ截图20190328214455.png" alt="QQ截图20190328214455.png"></p><p>说明同步成功。</p><p>我们也可以自定义共享路劲，编辑vagrant_vm文件夹下的Vagrantfile文件：</p><p><img src="img/QQ截图20190328222933.png" alt="QQ截图20190328222933.png"></p><p>在这行下面添加如下配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">config.vm.synced_folder &quot;./data&quot;, &quot;/share&quot;, create:true, owner: &quot;root&quot;, group: &quot;root&quot;</span><br></pre></td></tr></table></figure><p>这个配置的意思是将当前路径下的data文件夹和虚拟机的/share目录共享，拥有者为root，群组为root，如果路径不存在则创建。</p><p>修改了Vagrantfile文件需要执行 <code>vagrant reload</code>重启。重启后我们在data文件夹下新建一个world.txt文件，然后连接虚拟机看看是否共享成功：</p><p><img src="img/QQ截图20190328231719.png" alt="QQ截图20190328231719.png"></p><p>共享成功！</p><p>在这途中，遇到了如下问题:</p><div class="note danger"><p>Vagrant was unable to mount VirtualBox shared folders. This is usually because the filesystem “vboxsf” is not available. This filesystem is made available via the VirtualBox Guest Additions and kernel module. Please verify that these guest additions are properly installed in the guest. This is not a bug in Vagrant and is usually caused by a faulty Vagrant box. For context, the command attempted was</p><p>…</p><p>The error output from the command was: mount: unknown filesystem type ‘vboxsf’</p></div><p>安装下面这个插件可解决问题：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vagrant plugin install vagrant-vbguest</span><br></pre></td></tr></table></figure><p></p><h2 id="网络配置"><a href="#网络配置" class="headerlink" title="网络配置"></a>网络配置</h2><h3 id="虚拟机私有网络"><a href="#虚拟机私有网络" class="headerlink" title="虚拟机私有网络"></a>虚拟机私有网络</h3><p>在Vagrantfile里打开下面这行配置：</p><p><img src="img/QQ截图20190329203440.png" alt="QQ截图20190329203440.png"></p><p>然后使用命令<code>vagrant reload</code>重启虚拟机，重启后我们使用<code>ping</code>命令看是否可以在windows上访问到这个ip：</p><p><img src="img/QQ截图20190329203610.png" alt="QQ截图20190329203610.png"></p><p>访问成功，连接虚拟机，使用<code>ifconfig</code>查看其IP：</p><p><img src="img/QQ截图20190329203731.png" alt="QQ截图20190329203731.png"></p><p>正是我们刚刚配置的那个IP。</p><h3 id="虚拟机公有网络"><a href="#虚拟机公有网络" class="headerlink" title="虚拟机公有网络"></a>虚拟机公有网络</h3><p>编辑Vagrantfile，将我们刚刚开启的私有网络配置注释，然后开启下面这行配置：</p><p><img src="img/QQ截图20190329204536.png" alt="QQ截图20190329204536.png"></p><p>然后重启虚拟机，重启过程中会然你根据当前网络环境选择：</p><p><img src="img/QQ截图20190329204658.png" alt="QQ截图20190329204658.png"></p><p>因为我电脑连接的是家里wifi所以选择第四个选项，重启好后连接虚拟机，查看其IP：</p><p><img src="img/QQ截图20190329204819.png" alt="QQ截图20190329204819.png"></p><p>新开一个cmd窗口，ping 这个地址看是否能通:</p><p><img src="img/QQ截图20190329204921.png" alt="QQ截图20190329204921.png"></p><p>公有网络和私有网络的区别是，公有网络是无线路由器自动分配的IP地址，并且在同一个wifi网络下的其他设备也是可以访问这个IP地址的。</p><p>比如我们在windows浏览器里输入<a href="http://192.168.28.83/" target="_blank" rel="noopener">http://192.168.28.83/</a>：</p><p><img src="img/QQ截图20190329205957.png" alt="QQ截图20190329205957.png"></p><p>然后让手机连接和电脑相同的wifi网络，并且访问<a href="http://192.168.28.83/" target="_blank" rel="noopener">http://192.168.28.83/</a>：</p><p><img alt="" src="img/QQ图片20190329210159.jpg" style="width:25rem"></p><p>结果说明公有网络配置成功。</p><h2 id="多主机配置"><a href="#多主机配置" class="headerlink" title="多主机配置"></a>多主机配置</h2><p>使用Vagrant可以轻松地创建多台虚拟主机。下面我们开始通过Vagrant来创建两台新的虚拟主机“prod”和“dev”。</p><p>在vagrant_vm目录下新建一个目录，名称为multi，然后通过现有的box来初始化一个Vagrantfile配置：</p><p><img src="img/QQ截图20190329213710.png" alt="QQ截图20190329213710.png"></p><p>接着编辑multi目录下的Vagrantfile文件，新增下面两项配置：</p><p><img src="img/QQ截图20190329213847.png" alt="QQ截图20190329213847.png"></p><p>运行<code>vagrant status</code>：</p><p><img src="img/QQ截图20190329213928.png" alt="QQ截图20190329213928.png"></p><p>可以看到多了两台状态为<code>not created</code>的虚拟机，名称分别为“prod”和“dev”。</p><p>我们可以使用<code>vagrant up</code>来启动两台主机，也可以通过<code>vagrant up prod</code>来单独启动“prod”这台虚拟主机。</p><p>启动后（第一次启动耗时可能比较长），使用<code>vagrant status</code>来查看它们的状态：</p><p><img src="img/QQ截图20190329214836.png" alt="QQ截图20190329214836.png"></p><p>通过<code>vagrant ssh 主机名</code>就可以连接上它们了。</p><h3 id="网络配置-1"><a href="#网络配置-1" class="headerlink" title="网络配置"></a>网络配置</h3><p>接下来开始配置网络，让它们之间可以通讯。</p><p>我们按照上面介绍网络配置的方式来为这两台虚拟主机配置私有网络：</p><p><img src="img/QQ截图20190329215535.png" alt="QQ截图20190329215535.png"></p><p>值得注意的是，在配置私有网络的时候，IP网段不能和Windows主机相同。</p><p>配置好后重启这两台虚拟机，然后分别连接这两台虚拟机，看是否能够ping通：</p><p><img src="img/QQ截图20190329220045.png" alt="QQ截图20190329220045.png"></p><p><img src="img/QQ截图20190329220109.png" alt="QQ截图20190329220109.png"></p><p>配置成功。</p><h3 id="自定义主机名"><a href="#自定义主机名" class="headerlink" title="自定义主机名"></a>自定义主机名</h3><p>编辑Vagrantfile，添加如下配置：</p><p><img src="img/QQ截图20190329220648.png" alt="QQ截图20190329220648.png"></p><p>重启后，连接虚拟机，可以看到hostname已经修改为我们设置的名称了：</p><p><img src="img/QQ截图20190329220747.png" alt="QQ截图20190329220747.png"></p><p><img src="img/QQ截图20190329220810.png" alt="QQ截图20190329220810.png"></p><h3 id="多主机的共享目录"><a href="#多主机的共享目录" class="headerlink" title="多主机的共享目录"></a>多主机的共享目录</h3><p>默认的这两台虚拟主机的/vagrant和当前目录multi/是共享的。我们也可以分别为它们设置不同的共享目录。</p><p>编辑Vagrantfile，添加如下配置：</p><p><img src="img/QQ截图20190329221152.png" alt="QQ截图20190329221152.png"></p><p>然后重启这两台虚拟主机就好了。</p><p>更多Vagrant的配置可以查看官方文档：<a href="https://www.vagrantup.com/docs/" target="_blank" rel="noopener">https://www.vagrantup.com/docs/</a></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Thu Apr 04 2019 14:23:35 GMT+0800 (GMT+08:00) --&gt;&lt;p&gt;Vagrant是一款由HashiCorp公司提供的，用于快速构建虚拟机环境的软件。本节我们将使用Vagrant结合Oracle VM VirtualBox快速地在win10环境下构建CentOS7虚拟机。在此之前需要先安装好 &lt;a href=&quot;https://www.vagrantup.com/downloads.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Vagrant&lt;/a&gt; 和 &lt;a href=&quot;https://www.virtualbox.org/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;VirtualBox&lt;/a&gt;。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Vagrant" scheme="http://mrbird.cc/tags/Vagrant/"/>
    
  </entry>
  
  <entry>
    <title>Spring Boot 中的异步调用</title>
    <link href="http://mrbird.cc/Spring-Boot-Async.html"/>
    <id>http://mrbird.cc/Spring-Boot-Async.html</id>
    <published>2018-09-28T06:42:06.000Z</published>
    <updated>2019-04-01T02:33:31.836Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Apr 04 2019 14:23:35 GMT+0800 (GMT+08:00) --><p>通常我们开发的程序都是同步调用的，即程序按照代码的顺序一行一行的逐步往下执行，每一行代码都必须等待上一行代码执行完毕才能开始执行。而异步编程则没有这个限制，代码的调用不再是阻塞的。所以在一些情景下，通过异步编程可以提高效率，提升接口的吞吐量。这节将介绍如何在Spring Boot中进行异步编程。</p><a id="more"></a><h2 id="开启异步"><a href="#开启异步" class="headerlink" title="开启异步"></a>开启异步</h2><p>新建一个Spring Boot项目，版本为2.1.0.RELEASE，并引入<code>spring-boot-starter-web</code>依赖，项目结构如下所示：</p><p><img src="img/QQ截图20190302100710.png" alt="QQ截图20190302100710.png"></p><p>要开启异步支持，首先得在Spring Boot入口类上加上<code>@EnableAsync</code>注解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableAsync</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoApplication</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(DemoApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>接下来开始编写异步方法。</p><p>在<code>com.example.demo</code>路径下新建<code>service</code>包，并创建<code>TestService</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Logger logger = LoggerFactory.getLogger(<span class="keyword">this</span>.getClass());</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Async</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">asyncMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        sleep();</span><br><span class="line">        logger.info(<span class="string">"异步方法内部线程名称：&#123;&#125;"</span>, Thread.currentThread().getName());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">syncMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        sleep();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sleep</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>上面的Service中包含一个异步方法<code>asyncMethod</code>（开启异步支持后，只需要在方法上加上<code>@Async</code>注解便是异步方法了）和同步方法<code>syncMethod</code>。<code>sleep</code>方法用于让当前线程阻塞2秒钟。</p><p>接着在<code>com.example.demo</code>路径下新建<code>controller</code>包，然后创建<code>TestController</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Logger logger = LoggerFactory.getLogger(<span class="keyword">this</span>.getClass());</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> TestService testService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"async"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testAsync</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">        logger.info(<span class="string">"异步方法开始"</span>);</span><br><span class="line"></span><br><span class="line">        testService.asyncMethod();</span><br><span class="line"></span><br><span class="line">        logger.info(<span class="string">"异步方法结束"</span>);</span><br><span class="line">        <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">        logger.info(<span class="string">"总耗时：&#123;&#125; ms"</span>, end - start);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"sync"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSync</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">        logger.info(<span class="string">"同步方法开始"</span>);</span><br><span class="line"></span><br><span class="line">        testService.syncMethod();</span><br><span class="line"></span><br><span class="line">        logger.info(<span class="string">"同步方法结束"</span>);</span><br><span class="line">        <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">        logger.info(<span class="string">"总耗时：&#123;&#125; ms"</span>, end - start);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>启动项目，访问 <a href="http://localhost:8080/sync" target="_blank" rel="noopener">http://localhost:8080/sync</a> 请求，控制台输出如下：</p><p><img src="img/QQ截图20190302101932.png" alt="QQ截图20190302101932.png"></p><p>可看到默认程序是同步的，由于<code>sleep</code>方法阻塞的原因，<code>testSync</code>方法执行了2秒钟以上。</p><p>访问 <a href="http://localhost:8080/async" target="_blank" rel="noopener">http://localhost:8080/async</a> ，控制台输出如下：</p><p><img src="img/QQ截图20190302102327.png" alt="QQ截图20190302102327.png"></p><p>可看到<code>testAsync</code>方法耗时极少，因为异步的原因，程序并没有被<code>sleep</code>方法阻塞，这就是异步调用的好处。同时异步方法内部会新启一个线程来执行，这里线程名称为task - 1。</p><p>默认情况下的异步线程池配置使得线程不能被重用，每次调用异步方法都会新建一个线程，我们可以自己定义异步线程池来优化。</p><h2 id="自定义异步线程池"><a href="#自定义异步线程池" class="headerlink" title="自定义异步线程池"></a>自定义异步线程池</h2><p>在<code>com.example.demo</code>下新建<code>config</code>包，然后创建<code>AsyncPoolConfig</code>配置类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AsyncPoolConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ThreadPoolTaskExecutor <span class="title">asyncThreadPoolTaskExecutor</span><span class="params">()</span></span>&#123;</span><br><span class="line">        ThreadPoolTaskExecutor executor = <span class="keyword">new</span> ThreadPoolTaskExecutor();</span><br><span class="line">        executor.setCorePoolSize(<span class="number">20</span>);</span><br><span class="line">        executor.setMaxPoolSize(<span class="number">200</span>);</span><br><span class="line">        executor.setQueueCapacity(<span class="number">25</span>);</span><br><span class="line">        executor.setKeepAliveSeconds(<span class="number">200</span>);</span><br><span class="line">        executor.setThreadNamePrefix(<span class="string">"asyncThread"</span>);</span><br><span class="line">        executor.setWaitForTasksToCompleteOnShutdown(<span class="keyword">true</span>);</span><br><span class="line">        executor.setAwaitTerminationSeconds(<span class="number">60</span>);</span><br><span class="line"></span><br><span class="line">        executor.setRejectedExecutionHandler(<span class="keyword">new</span> ThreadPoolExecutor.CallerRunsPolicy());</span><br><span class="line"></span><br><span class="line">        executor.initialize();</span><br><span class="line">        <span class="keyword">return</span> executor;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面我们通过<code>ThreadPoolTaskExecutor</code>的一些方法自定义了一个线程池，这些方法的含义如下所示：</p><ul><li><p><code>corePoolSize</code>：线程池核心线程的数量，默认值为1（这就是默认情况下的异步线程池配置使得线程不能被重用的原因）。</p></li><li><p><code>maxPoolSize</code>：线程池维护的线程的最大数量，只有当核心线程都被用完并且缓冲队列满后，才会开始申超过请核心线程数的线程，默认值为<code>Integer.MAX_VALUE</code>。</p></li><li><p><code>queueCapacity</code>：缓冲队列。</p></li><li><p><code>keepAliveSeconds</code>：超出核心线程数外的线程在空闲时候的最大存活时间，默认为60秒。</p></li><li><p><code>threadNamePrefix</code>：线程名前缀。</p></li><li><p><code>waitForTasksToCompleteOnShutdown</code>：是否等待所有线程执行完毕才关闭线程池，默认值为false。</p></li><li><p><code>awaitTerminationSeconds</code>：<code>waitForTasksToCompleteOnShutdown</code>的等待的时长，默认值为0，即不等待。</p></li><li><p><code>rejectedExecutionHandler</code>：当没有线程可以被使用时的处理策略（拒绝任务），默认策略为<code>abortPolicy</code>，包含下面四种策略：</p><p><img src="img/QQ截图20190302111014.png" alt="QQ截图20190302111014.png"></p><ol><li><p><code>callerRunsPolicy</code>：用于被拒绝任务的处理程序，它直接在 execute 方法的调用线程中运行被拒绝的任务；如果执行程序已关闭，则会丢弃该任务。</p></li><li><p><code>abortPolicy</code>：直接抛出<code>java.util.concurrent.RejectedExecutionException</code>异常。</p></li><li><p><code>discardOldestPolicy</code>：当线程池中的数量等于最大线程数时、抛弃线程池中最后一个要执行的任务，并执行新传入的任务。</p></li><li><p><code>discardPolicy</code>：当线程池中的数量等于最大线程数时，不做任何动作。</p></li></ol></li></ul><p>要使用该线程池，只需要在<code>@Async</code>注解上指定线程池Bean名称即可：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestService</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Async</span>(<span class="string">"asyncThreadPoolTaskExecutor"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">asyncMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       ......</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重启项目，再次访问 <a href="http://localhost:8080/async" target="_blank" rel="noopener">http://localhost:8080/async</a> ，控制台输出入下：</p><p><img src="img/QQ截图20190302112759.png" alt="QQ截图20190302112759.png"></p><h2 id="处理异步回调"><a href="#处理异步回调" class="headerlink" title="处理异步回调"></a>处理异步回调</h2><p>如果异步方法具有返回值的话，需要使用<code>Future</code>来接收回调值。我们修改<code>TestService</code>的<code>asyncMethod</code>方法，给其添加返回值：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Async</span>(<span class="string">"asyncThreadPoolTaskExecutor"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> Future&lt;String&gt; <span class="title">asyncMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sleep();</span><br><span class="line">    logger.info(<span class="string">"异步方法内部线程名称：&#123;&#125;"</span>, Thread.currentThread().getName());</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> AsyncResult&lt;&gt;(<span class="string">"hello async"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>泛型指定返回值的类型，<code>AsyncResult</code>为Spring实现的<code>Future</code>实现类：</p><p><img src="img/QQ截图20190302140425.png" alt="QQ截图20190302140425.png"></p><p>接着改造<code>TestController</code>的<code>testAsync</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"async"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">testAsync</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">    logger.info(<span class="string">"异步方法开始"</span>);</span><br><span class="line"></span><br><span class="line">    Future&lt;String&gt; stringFuture = testService.asyncMethod();</span><br><span class="line">    String result = stringFuture.get();</span><br><span class="line">    logger.info(<span class="string">"异步方法返回值：&#123;&#125;"</span>, result);</span><br><span class="line">    </span><br><span class="line">    logger.info(<span class="string">"异步方法结束"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">    logger.info(<span class="string">"总耗时：&#123;&#125; ms"</span>, end - start);</span><br><span class="line">    <span class="keyword">return</span> stringFuture.get();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p><code>Future</code>接口的<code>get</code>方法用于获取异步调用的返回值。</p><p>重启项目，访问 <a href="http://localhost:8080/async" target="_blank" rel="noopener">http://localhost:8080/async</a> 控制台输出如下所示:</p><p><img src="img/QQ截图20190302141055.png" alt="QQ截图20190302141055.png"></p><p>通过返回结果我们可以看出<code>Future</code>的<code>get</code>方法为阻塞方法，只有当异步方法返回内容了，程序才会继续往下执行。<code>get</code>还有一个<code>get(long timeout, TimeUnit unit)</code>重载方法，我们可以通过这个重载方法设置超时时间，即异步方法在设定时间内没有返回值的话，直接抛出<code>java.util.concurrent.TimeoutException</code>异常。</p><p>比如设置超时时间为60秒：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String result = stringFuture.get(<span class="number">60</span>, TimeUnit.SECONDS);</span><br></pre></td></tr></table></figure><blockquote><p>源码链接：<a href="https://github.com/wuyouzhuguli/SpringAll/tree/master/49.Spring-Boot-Async" target="_blank" rel="noopener">https://github.com/wuyouzhuguli/SpringAll/tree/master/49.Spring-Boot-Async</a></p></blockquote><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Thu Apr 04 2019 14:23:35 GMT+0800 (GMT+08:00) --&gt;&lt;p&gt;通常我们开发的程序都是同步调用的，即程序按照代码的顺序一行一行的逐步往下执行，每一行代码都必须等待上一行代码执行完毕才能开始执行。而异步编程则没有这个限制，代码的调用不再是阻塞的。所以在一些情景下，通过异步编程可以提高效率，提升接口的吞吐量。这节将介绍如何在Spring Boot中进行异步编程。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Spring" scheme="http://mrbird.cc/tags/Spring/"/>
    
      <category term="Spring Boot" scheme="http://mrbird.cc/tags/Spring-Boot/"/>
    
  </entry>
  
  <entry>
    <title>Spring Boot 中处理跨域</title>
    <link href="http://mrbird.cc/Spring-Boot-Deal-CORS.html"/>
    <id>http://mrbird.cc/Spring-Boot-Deal-CORS.html</id>
    <published>2018-09-22T02:08:47.000Z</published>
    <updated>2019-03-13T10:48:29.195Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Apr 04 2019 14:23:35 GMT+0800 (GMT+08:00) --><p>HTML 5中新增的跨域资源访问（Cross-Origin Resource Sharing）特性可以让我们在开发后端系统的时候决定资源是否允许被跨域访问。所谓跨域指的是域名不同或者端口不同或者协议不同，比如当从mrbrid.cc网站访问mrbird.cc:8080网站资源就会存在跨域问题。Spring从4.2版本开始就提供了跨域的支持，开箱即用。这里介绍如何在Spring Boot开发中解决跨域的问题，主要分为注解驱动和接口编程的方式。</p><a id="more"></a><h2 id="模拟跨域"><a href="#模拟跨域" class="headerlink" title="模拟跨域"></a>模拟跨域</h2><p>要解决跨域问题，我们就得先模拟一个跨域情景。新建Spring Boot项目，版本为2.1.0.RELEASE，并引如下依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-thymeleaf<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p></p><p>项目结构如下所示：</p><p><img src="img/QQ截图20190301150006.png" alt="QQ截图20190301150006.png"></p><p>在<code>com.example.demo</code>路径下新建<code>controller</code>包，并创建<code>TestController</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"index"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">index</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"index"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"hello"</span>)</span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"hello"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>然后在resources/templates下新建index.html：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>跨域测试<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"http://libs.baidu.com/jquery/1.11.3/jquery.min.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"hello"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">    $(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        $.get(<span class="string">"http://test.mrbird.cc:8080/hello"</span>, <span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">            $(<span class="string">"#hello"</span>).text(data);</span></span><br><span class="line"><span class="undefined">        &#125;)</span></span><br><span class="line"><span class="undefined">    &#125;)</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p></p><p>编辑本地hosts文件，将<a href="http://test.mrbird.cc" target="_blank" rel="noopener">http://test.mrbird.cc</a>网址映射到127.0.0.1上：</p><p><img src="img/QQ截图20190301150336.png" alt="QQ截图20190301150336.png"></p><p>启动项目访问<a href="http://localhost:8080/" target="_blank" rel="noopener">http://localhost:8080/</a>，会发现页面并没有成功显示hello，并且F12观察浏览器控制台会发现其报错了：</p><p><img src="img/QQ截图20190301150534.png" alt="QQ截图20190301150534.png"></p><p>这是因为我们在<a href="http://localhost:8080/" target="_blank" rel="noopener">http://localhost:8080/</a>域名下试图访问<a href="http://test.mrbird.cc:8080" target="_blank" rel="noopener">http://test.mrbird.cc:8080</a>下的hello接口，这就存在跨域问题，接下来我们来解决这个问题。</p><h2 id="注解驱动"><a href="#注解驱动" class="headerlink" title="注解驱动"></a>注解驱动</h2><p>Spring 4.2后提供了<code>@CrossOrigin</code>注解，该注解可以标注于方法或者类上，包含了以下属性:</p><table><tr><th>属性</th><th>含义</th></tr><tr><td>value</td><td>指定所支持域的集合，<code>*</code>表示所有域都支持，默认值为<code>*</code>。这些值对应HTTP请求头中的<code>Access-Control-Allow-Origin</code></td></tr><tr><td>origins</td><td>同value</td></tr><tr><td>allowedHeaders</td><td>允许请求头中的header，默认都支持</td></tr><tr><td>exposedHeaders</td><td>响应头中允许访问的header，默认为空</td></tr><tr><td>methods</td><td>支持请求的方法，比如<code>GET</code>，<code>POST</code>，<code>PUT</code>等，默认和Controller中的方法上标注的一致。</td></tr><tr><td>allowCredentials</td><td>是否允许cookie随请求发送，使用时必须指定具体的域</td></tr><tr><td>maxAge</td><td>预请求的结果的有效期，默认30分钟</td></tr></table><p>我们来改造<code>TestController</code>中的<code>hello</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"hello"</span>)</span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="meta">@CrossOrigin</span>(value = <span class="string">"*"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"hello"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>表示允许所有域都支持，重启项目，再次访问<a href="http://localhost:8080/" target="_blank" rel="noopener">http://localhost:8080/</a>：</p><p><img src="img/QQ截图20190301153418.png" alt="QQ截图20190301153418.png"></p><h2 id="接口编程"><a href="#接口编程" class="headerlink" title="接口编程"></a>接口编程</h2><p>除了使用<code>@CrossOrigin</code>注解外，我们可以使用接口编程的方式进行统一配置。</p><p>在<code>com.example.demo</code>路径下新建<code>config</code>包，然后创建<code>WebConfigurer</code>，实现<code>WebMvcConfigurer</code>，重写<code>addCorsMappings</code>默认实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebConfigurer</span> <span class="keyword">implements</span> <span class="title">WebMvcConfigurer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addCorsMappings</span><span class="params">(CorsRegistry registry)</span> </span>&#123;</span><br><span class="line">        registry.addMapping(<span class="string">"/**"</span>)</span><br><span class="line">                .allowedOrigins(<span class="string">"*"</span>)</span><br><span class="line">                .allowedMethods(<span class="string">"GET"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>上面配置表示允许所有请求支持跨域访问，并且不限定域，但是支持持GET方法。将<code>hello</code>方法上的<code>@CrossOrigin</code>注解注释掉，重启项目，再次访问<a href="http://localhost:8080/" target="_blank" rel="noopener">http://localhost:8080/</a>，结果也是OK的。</p><h2 id="过滤器实现"><a href="#过滤器实现" class="headerlink" title="过滤器实现"></a>过滤器实现</h2><p>查看官方文档，发现其还提供了基于过滤器的实现方式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> FilterRegistrationBean <span class="title">corsFilter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    UrlBasedCorsConfigurationSource source = <span class="keyword">new</span> UrlBasedCorsConfigurationSource();</span><br><span class="line">    CorsConfiguration config = <span class="keyword">new</span> CorsConfiguration();</span><br><span class="line">    config.setAllowCredentials(<span class="keyword">true</span>);</span><br><span class="line">    config.addAllowedOrigin(<span class="string">"*"</span>);</span><br><span class="line">    source.registerCorsConfiguration(<span class="string">"/**"</span>, config);</span><br><span class="line">    FilterRegistrationBean bean = <span class="keyword">new</span> FilterRegistrationBean(<span class="keyword">new</span> CorsFilter(source));</span><br><span class="line">    bean.setOrder(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> bean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h2 id="Actuator跨域"><a href="#Actuator跨域" class="headerlink" title="Actuator跨域"></a>Actuator跨域</h2><p>如果项目里集成了<code>Actuator</code>相关功能，其暴露的接口也支持跨域，只需要在配置文件中添加如下配置即可：</p><p>ENDPOINTS CORS CONFIGURATION (<a href="https://github.com/spring-projects/spring-boot/blob/v2.1.0.RELEASE/spring-boot-project/spring-boot-actuator-autoconfigure/src/main/java/org/springframework/boot/actuate/autoconfigure/endpoint/web/CorsEndpointProperties.java" target="_blank" rel="noopener">CorsEndpointProperties</a>)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">management.endpoints.web.cors.allow-credentials= # Whether credentials are supported. When not set, credentials are not supported.</span><br><span class="line">management.endpoints.web.cors.allowed-headers= # Comma-separated list of headers to allow in a request. &apos;*&apos; allows all headers.</span><br><span class="line">management.endpoints.web.cors.allowed-methods= # Comma-separated list of methods to allow. &apos;*&apos; allows all methods. When not set, defaults to GET.</span><br><span class="line">management.endpoints.web.cors.allowed-origins= # Comma-separated list of origins to allow. &apos;*&apos; allows all origins. When not set, CORS support is disabled.</span><br><span class="line">management.endpoints.web.cors.exposed-headers= # Comma-separated list of headers to include in a response.</span><br><span class="line">management.endpoints.web.cors.max-age=1800s # How long the response from a pre-flight request can be cached by clients. If a duration suffix is not specified, seconds will be used.</span><br></pre></td></tr></table></figure><p></p><blockquote><p>源码链接：<a href="https://github.com/wuyouzhuguli/SpringAll/tree/master/48.Spring-Boot-CORS-Support" target="_blank" rel="noopener">https://github.com/wuyouzhuguli/SpringAll/tree/master/48.Spring-Boot-CORS-Support</a></p></blockquote><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Thu Apr 04 2019 14:23:35 GMT+0800 (GMT+08:00) --&gt;&lt;p&gt;HTML 5中新增的跨域资源访问（Cross-Origin Resource Sharing）特性可以让我们在开发后端系统的时候决定资源是否允许被跨域访问。所谓跨域指的是域名不同或者端口不同或者协议不同，比如当从mrbrid.cc网站访问mrbird.cc:8080网站资源就会存在跨域问题。Spring从4.2版本开始就提供了跨域的支持，开箱即用。这里介绍如何在Spring Boot开发中解决跨域的问题，主要分为注解驱动和接口编程的方式。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Spring" scheme="http://mrbird.cc/tags/Spring/"/>
    
      <category term="Spring Boot" scheme="http://mrbird.cc/tags/Spring-Boot/"/>
    
  </entry>
  
  <entry>
    <title>自定义Spring Boot 内容协商</title>
    <link href="http://mrbird.cc/Spring-Boot-Diy-Resolver.html"/>
    <id>http://mrbird.cc/Spring-Boot-Diy-Resolver.html</id>
    <published>2018-09-16T02:08:27.000Z</published>
    <updated>2019-03-13T10:49:45.558Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Apr 04 2019 14:23:37 GMT+0800 (GMT+08:00) --><p><strong>内容协商</strong>机制是指客户端和服务器端就响应的资源内容进行交涉，然后提供给客户端最为适合的资源。内容协商会以响应资源的语言、字符集、编码方式等作为判断的基准。HTTP请求头中Content-Type，Accept等内容就是内容协商判断的标准。在Spring Boot中，一个完整的内容协商过程如下图所示：</p><a id="more"></a><p><img src="img/askfljasdfneiw.png" alt="askfljasdfneiw.png"></p><p>这个过程的核心组件：</p><table><tr><th>组件</th><th>名称</th><th>说明</th></tr><tr><td>ContentNegotiationManager</td><td>内容协商管理器</td><td>ContentNegotiationStrategy 控制策略</td></tr><tr><td>MediaType</td><td>媒体类型</td><td>HTTP 消息媒体类型，如 text/html</td></tr><tr><td>@RequestMapping#consumes</td><td>消费媒体类型</td><td>请求头 Content-Type 媒体类型映射</td></tr><tr><td>@RequestMapping#produces</td><td>生产媒体类型</td><td>响应头 Content-Type 媒体类型映射</td></tr><tr><td>HttpMessageConverter</td><td>HTTP消息转换器接口</td><td>HTTP 消息转换器，用于反序列化 HTTP 请求或序列化响应</td></tr><tr><td>WebMvcConfigurer</td><td>Web MVC 配置器</td><td>配置 REST 相关的组件</td></tr><tr><td>HandlerMethod</td><td>处理方法</td><td>@RequestMapping 标注的方法</td></tr><tr><td>HandlerMethodArgumentResolver</td><td>处理方法参数解析器</td><td>用于 HTTP 请求中解析 HandlerMethod 参数内容</td></tr><tr><td>HandlerMethodReturnValueHandler</td><td>处理方法返回值解析器</td><td>用于 HandlerMethod 返回值解析为 HTTP 响应内容</td></tr></table><p><code>HttpMessageConverter</code>为HTTP消息转换接口，Spring根据不同的媒体类型进行了相应的实现。比如上图中Accept为application/json，所以在第7步中，会选择使用<code>HttpMessageConverter</code>的实现类<code>MappingJackson2HttpMessageConverter</code>来处理返回值。</p><h2 id="自定义HttpMessageConverter"><a href="#自定义HttpMessageConverter" class="headerlink" title="自定义HttpMessageConverter"></a>自定义HttpMessageConverter</h2><p>除了Spring给我们提供的<code>HttpMessageConverter</code>实现外，我们也可以自定义<code>HttpMessageConverter</code>的实现，来处理一些实际业务需求。</p><p>假如现在要实现一个用于处理 Content-Type 为 text/properties 媒体类型的 HttpMessageConverter 实现类 PropertiesHttpMessageConverter，当我们在请求体中传输下面内容时：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">name:mrbrid</span><br><span class="line">age:18</span><br></pre></td></tr></table></figure><p></p><p>能够自动转换为Properties对象。</p><p>我们可以参照<code>MappingJackson2HttpMessageConverter</code>的实现方式来进行实现，查看<code>MappingJackson2HttpMessageConverter</code>的原型图：</p><p><img src="img/QQ截图20190228110016.png" alt="QQ截图20190228110016.png"></p><p>所以我们可以通过继承<code>AbstractGenericHttpMessageConverter</code>的方式来实现<code>HttpMessageConverter</code>接口。</p><p>新建Spring Boot项目，版本为2.1.0.RELEASE，并引入<code>spring-boot-starter-web</code>依赖，项目结构如下所示:</p><p><img src="img/QQ截图20190228110545.png" alt="QQ截图20190228110545.png"></p><p>我们在<code>com.example.demo</code>路径下新建<code>converter</code>包，然后创建<code>PropertiesHttpMessageConverter</code>，继承<code>AbstractGenericHttpMessageConverter</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PropertiesHttpMessageConverter</span> <span class="keyword">extends</span> <span class="title">AbstractGenericHttpMessageConverter</span>&lt;<span class="title">Properties</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">writeInternal</span><span class="params">(Properties properties, Type type, HttpOutputMessage outputMessage)</span> <span class="keyword">throws</span> IOException, HttpMessageNotWritableException </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Properties <span class="title">readInternal</span><span class="params">(Class&lt;? extends Properties&gt; clazz, HttpInputMessage inputMessage)</span> <span class="keyword">throws</span> IOException, HttpMessageNotReadableException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Properties <span class="title">read</span><span class="params">(Type type, Class&lt;?&gt; contextClass, HttpInputMessage inputMessage)</span> <span class="keyword">throws</span> IOException, HttpMessageNotReadableException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>其中<code>readxxx</code>为反序列化过程，即将HTTP请求反序列化为参数的过程；<code>writeInternal</code>为序列化过程，将响应序列化。</p><h3 id="反序列化过程"><a href="#反序列化过程" class="headerlink" title="反序列化过程"></a>反序列化过程</h3><p>我们继续编写<code>PropertiesHttpMessageConverter</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PropertiesHttpMessageConverter</span> <span class="keyword">extends</span> <span class="title">AbstractGenericHttpMessageConverter</span>&lt;<span class="title">Properties</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">writeInternal</span><span class="params">(Properties properties, Type type, HttpOutputMessage outputMessage)</span> <span class="keyword">throws</span> IOException, HttpMessageNotWritableException </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Properties <span class="title">readInternal</span><span class="params">(Class&lt;? extends Properties&gt; clazz, HttpInputMessage inputMessage)</span> <span class="keyword">throws</span> IOException, HttpMessageNotReadableException </span>&#123;</span><br><span class="line">        Properties properties = <span class="keyword">new</span> Properties();</span><br><span class="line">        <span class="comment">// 获取请求头</span></span><br><span class="line">        HttpHeaders headers = inputMessage.getHeaders();</span><br><span class="line">        <span class="comment">// 获取 content-type</span></span><br><span class="line">        MediaType contentType = headers.getContentType();</span><br><span class="line">        <span class="comment">// 获取编码</span></span><br><span class="line">        Charset charset = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (contentType != <span class="keyword">null</span>) &#123;</span><br><span class="line">            charset = contentType.getCharset();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        charset = charset == <span class="keyword">null</span> ? Charset.forName(<span class="string">"UTF-8"</span>) : charset;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取请求体</span></span><br><span class="line">        InputStream body = inputMessage.getBody();</span><br><span class="line">        InputStreamReader inputStreamReader = <span class="keyword">new</span> InputStreamReader(body, charset);</span><br><span class="line">        </span><br><span class="line">        properties.load(inputStreamReader);</span><br><span class="line">        <span class="keyword">return</span> properties;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Properties <span class="title">read</span><span class="params">(Type type, Class&lt;?&gt; contextClass, HttpInputMessage inputMessage)</span> <span class="keyword">throws</span> IOException, HttpMessageNotReadableException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> readInternal(<span class="keyword">null</span>, inputMessage);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>在<code>readInternal</code>方法中，我们获取了HTTP请求体中的输入流和编码，然后调用Properties对象的<code>load</code>方法来将流转换为Properties对象。反序列化过程完成了，我们还需将<code>PropertiesHttpMessageConverter</code>添加到<code>HttpMessageConverter</code>集合中。</p><p>在<code>com.example.demo</code>路径下新建<code>config</code>包，然后创建<code>WebConfigurer</code>配置类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebConfigurer</span> <span class="keyword">implements</span> <span class="title">WebMvcConfigurer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">extendMessageConverters</span><span class="params">(List&lt;HttpMessageConverter&lt;?&gt;&gt; converters)</span> </span>&#123;</span><br><span class="line">        converters.add(<span class="keyword">new</span> PropertiesHttpMessageConverter());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p><code>extendMessageConverters</code>方法为<code>WebMvcConfigurer</code>的默认方法，这里我们重写这个方法，用于将<code>PropertiesHttpMessageConverter</code>添加到消息转换器集合中。</p><p>接着创建一个Controller来测试一波，在<code>com.example.demo</code>路径下新建<code>controller</code>包，然后创建<code>TestController</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(value = <span class="string">"test"</span>, consumes = <span class="string">"text/properties"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Properties <span class="title">test</span><span class="params">(@RequestBody Properties properties)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> properties;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>我们通过<code>@GetMapping</code>注解的<code>consumes</code>属性指定了方法接收的媒体类型为<code>text/properties</code>，如果方法能够成功被调用，并且可以返回<code>Properties</code>对象，则说明我们自定义的HTTP消息转换器是可行的。</p><p>启动项目，使用PostMan访问：</p><p><img src="img/QQ截图20190228142903.png" alt="QQ截图20190228142903.png"></p><p>请求头中指定Content-Type为text/properties，请求体内容如下所示:</p><p><img src="img/QQ截图20190228142955.png" alt="QQ截图20190228142955.png"></p><p>访问后，控制台输出错误如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Resolved [org.springframework.http.converter.HttpMessageNotReadableException: Required request body is missing: public java.util.Properties com.example.demo.controller.TestController.test(java.util.Properties)]</span><br></pre></td></tr></table></figure><p></p><p>为什么呢？因为我们在自定义<code>PropertiesHttpMessageConverter</code>的时候需要在其构造器中指定它能够处理的媒体类型，我们查看<code>MappingJackson2HttpMessageConverter</code>的构造器，看看它是怎么实现的：</p><p><img src="img/QQ截图20190228143338.png" alt="QQ截图20190228143338.png"></p><p>所以我们在<code>PropertiesHttpMessageConverter</code>的构造器中添加相应的媒体类型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">PropertiesHttpMessageConverter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(<span class="keyword">new</span> MediaType(<span class="string">"text"</span>, <span class="string">"properties"</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>这时候，重启项目，再次访问上面的请求，可看到响应如下所示:</p><p><img src="img/QQ截图20190228143600.png" alt="QQ截图20190228143600.png"></p><h3 id="序列化过程"><a href="#序列化过程" class="headerlink" title="序列化过程"></a>序列化过程</h3><p>序列化的过程就是处理HTTP响应的过程，对应<code>PropertiesHttpMessageConverter</code>的<code>writeInternal</code>方法。那为什么我们都还实现这个方法，上面的Controller请求却能返回正常的JSON内容呢？两个原因：</p><ol><li><p>这里我们定义的是REST接口，所以响应默认会被序列化为JSON格式；</p></li><li><p>由于使用<code>converters.add(new PropertiesHttpMessageConverter());</code>这种方式来添加自定义HTTP消息处理器默认会被添加到集合的末尾，在处理JSON响应的时候被排在前面的<code>MappingJackson2HttpMessageConverter</code>优先处理了。</p></li></ol><p>我们可以通过debug来查看<code>PropertiesHttpMessageConverter</code>是否真的被添加到集合末尾了：</p><p><img src="img/QQ截图20190228144601.png" alt="QQ截图20190228144601.png"></p><p><img src="img/QQ截图20190228144626.png" alt="QQ截图20190228144626.png"></p><p>所以我们要换下面这种方式来添加自定义HTTP处理器：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebConfigurer</span> <span class="keyword">implements</span> <span class="title">WebMvcConfigurer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">extendMessageConverters</span><span class="params">(List&lt;HttpMessageConverter&lt;?&gt;&gt; converters)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// converters.add(new PropertiesHttpMessageConverter());</span></span><br><span class="line">        <span class="comment">// 指定顺序，这里为第一个</span></span><br><span class="line">        converters.add(<span class="number">0</span>, <span class="keyword">new</span> PropertiesHttpMessageConverter());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>我们重启项目，再次debug：</p><p><img src="img/QQ截图20190228145054.png" alt="QQ截图20190228145054.png"></p><p>可看到，<code>PropertiesHttpMessageConverter</code>已经排在第一个了。这时候再次访问上面的请求，响应如下所示:</p><p><img src="img/QQ截图20190228145215.png" alt="QQ截图20190228145215.png"></p><p>没有任何返回值，这是因为我们还没实现<code>writeInternal</code>呢。继续实现<code>writeInternal</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PropertiesHttpMessageConverter</span> <span class="keyword">extends</span> <span class="title">AbstractGenericHttpMessageConverter</span>&lt;<span class="title">Properties</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">writeInternal</span><span class="params">(Properties properties, Type type, HttpOutputMessage outputMessage)</span> <span class="keyword">throws</span> IOException, HttpMessageNotWritableException </span>&#123;</span><br><span class="line">        <span class="comment">// 获取请求头</span></span><br><span class="line">        HttpHeaders headers = outputMessage.getHeaders();</span><br><span class="line">        <span class="comment">// 获取 content-type</span></span><br><span class="line">        MediaType contentType = headers.getContentType();</span><br><span class="line">        <span class="comment">// 获取编码</span></span><br><span class="line">        Charset charset = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (contentType != <span class="keyword">null</span>) &#123;</span><br><span class="line">            charset = contentType.getCharset();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        charset = charset == <span class="keyword">null</span> ? Charset.forName(<span class="string">"UTF-8"</span>) : charset;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取请求体</span></span><br><span class="line">        OutputStream body = outputMessage.getBody();</span><br><span class="line">        OutputStreamWriter outputStreamWriter = <span class="keyword">new</span> OutputStreamWriter(body, charset);</span><br><span class="line"></span><br><span class="line">        properties.store(outputStreamWriter, <span class="string">"Serialized by PropertiesHttpMessageConverter#writeInternal"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>过程和反序化差不多，这里是通过<code>Properties</code>对象的<code>store</code>方法来进行写操作。</p><p>重启项目，再次访问上面的请求，响应如下所示：</p><p><img src="img/QQ截图20190228145908.png" alt="QQ截图20190228145908.png"></p><h2 id="自定义HandlerMethodArgumentResolver"><a href="#自定义HandlerMethodArgumentResolver" class="headerlink" title="自定义HandlerMethodArgumentResolver"></a>自定义HandlerMethodArgumentResolver</h2><p>上面这种方式必须依赖于<code>@RequestBody</code>和<code>@ResponseBody</code>注解，除此之外我们还可以通过自定义<code>HandlerMethodArgumentResolver</code>和<code>HandlerMethodReturnValueHandler</code>实现类的方式来处理内容协商。</p><p><code>HandlerMethodArgumentResolver</code>俗称方法参数解析器，用于解析由<code>@RequestMapping</code>注解（或其派生的注解）所标注的方法的参数。这里我们开始通过实现<code>HandlerMethodArgumentResolver</code>的方式来将HTTP请求体的内容自动解析为Properties对象。</p><p>在<code>com.example.demo</code>路径下新建<code>resolver</code>包，然后创建<code>PropertiesHandlerMethodReturnValueHandler</code>实现<code>HandlerMethodArgumentResolver</code>接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PropertiesHandlerMethodArgumentResolver</span> <span class="keyword">implements</span> <span class="title">HandlerMethodArgumentResolver</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">supportsParameter</span><span class="params">(MethodParameter parameter)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Properties.class.equals(parameter.getParameterType());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">resolveArgument</span><span class="params">(MethodParameter parameter, ModelAndViewContainer mavContainer, NativeWebRequest webRequest, WebDataBinderFactory binderFactory)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ServletWebRequest servletWebRequest = (ServletWebRequest) webRequest;</span><br><span class="line">        HttpServletRequest request = servletWebRequest.getRequest();</span><br><span class="line">        String contentType = request.getHeader(<span class="string">"Content-Type"</span>);</span><br><span class="line"></span><br><span class="line">        MediaType mediaType = MediaType.parseMediaType(contentType);</span><br><span class="line">        <span class="comment">// 获取编码</span></span><br><span class="line">        Charset charset = mediaType.getCharset() == <span class="keyword">null</span> ? Charset.forName(<span class="string">"UTF-8"</span>) : mediaType.getCharset();</span><br><span class="line">        <span class="comment">// 获取输入流</span></span><br><span class="line">        InputStream inputStream = request.getInputStream();</span><br><span class="line">        InputStreamReader inputStreamReader = <span class="keyword">new</span> InputStreamReader(inputStream, charset);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 输入流转换为 Properties</span></span><br><span class="line">        Properties properties = <span class="keyword">new</span> Properties();</span><br><span class="line">        properties.load(inputStreamReader);</span><br><span class="line">        <span class="keyword">return</span> properties;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>方法<code>supportsParameter</code>用于指定支持解析的参数类型，这里为Properties类型。<code>resolveArgument</code>方法用于实现解析逻辑，解析过程和上面定义的<code>PropertiesHttpMessageConverter</code>的<code>readInternal</code>方法类似。</p><p>接着，我们还需将<code>PropertiesHandlerMethodArgumentResolver</code>添加到Spring自带的<code>HandlerMethodArgumentResolver</code>实现类集合中。值得注意的是，我们不能在配置类<code>WebMvcConfigurer</code>中通过重写<code>addArgumentResolvers</code>的方式来添加，查看该方法源码上的注释：</p><p><img src="img/QQ截图20190228185749.png" alt="QQ截图20190228185749.png"></p><p>大致意思是通过这个方法来添加的方法参数解析器不会覆盖Spring内置的方法参数解析器，如果需要这么做的话，可以直接通过修改<code>RequestMappingHandlerAdapter</code>来实现。</p><p>所以我们可以通过下面这个方式来实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebConfigurer</span> <span class="keyword">implements</span> <span class="title">WebMvcConfigurer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RequestMappingHandlerAdapter requestMappingHandlerAdapter;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 获取当前 RequestMappingHandlerAdapter 所有的 ArgumentResolver对象</span></span><br><span class="line">        List&lt;HandlerMethodArgumentResolver&gt; argumentResolvers = requestMappingHandlerAdapter.getArgumentResolvers();</span><br><span class="line">        List&lt;HandlerMethodArgumentResolver&gt; newArgumentResolvers = <span class="keyword">new</span> ArrayList&lt;&gt;(argumentResolvers.size() + <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 添加 PropertiesHandlerMethodArgumentResolver 到集合第一个位置</span></span><br><span class="line">        newArgumentResolvers.add(<span class="number">0</span>, <span class="keyword">new</span> PropertiesHandlerMethodArgumentResolver());</span><br><span class="line">        <span class="comment">// 将原 ArgumentResolver 添加到集合中</span></span><br><span class="line">        newArgumentResolvers.addAll(argumentResolvers);</span><br><span class="line">        <span class="comment">// 重新设置 ArgumentResolver对象集合</span></span><br><span class="line">        requestMappingHandlerAdapter.setArgumentResolvers(newArgumentResolvers);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>我们在<code>WebConfigurer</code>配置类装配完毕的时候，通过<code>requestMappingHandlerAdapter</code>对象的<code>setArgumentResolvers</code>方法来重新设置方法解析器集合，将<code>PropertiesHandlerMethodArgumentResolver</code>添加到集合的第一个位置。</p><p>之所以要将<code>PropertiesHandlerMethodArgumentResolver</code>添加到第一个位置是因为Properties本质也是一个Map对象，而Spring内置的<code>MapMethodProcessor</code>就是用于处理Map参数类型的，如果不将<code>PropertiesHandlerMethodArgumentResolver</code>优先级提高，那么Properties类型参数会被<code>MapMethodProcessor</code>解析，从而出错。</p><p>配置完毕后，我们改造一下<code>TestController</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// @RestController</span></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(value = <span class="string">"test"</span>, consumes = <span class="string">"text/properties"</span>)</span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Properties <span class="title">test</span><span class="params">(@RequestBody Properties properties)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> properties;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(value = <span class="string">"test1"</span>, consumes = <span class="string">"text/properties"</span>)</span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Properties <span class="title">test1</span><span class="params">(Properties properties)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> properties;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p><code>test1</code>方法的参数没有被<code>@RequestBody</code>标注，启动项目，访问下面这个请求：</p><p><img src="img/QQ截图20190228190930.png" alt="QQ截图20190228190930.png"></p><p>可以看到方法成功执行，并且返回了正确的内容，说明我们自定义的方法参数解析器<code>PropertiesHandlerMethodArgumentResolver</code>是可行的。</p><p>但是方法的返回值还是由<code>PropertiesHttpMessageConverter</code>的<code>writeInternal</code>方法解析的，并且依赖于<code>@ResponseBody</code>注解，接着我们开始实现自定义方法返回值解析器，并且不依赖于<code>@ResponseBody</code>注解。</p><h2 id="自定义HandlerMethodReturnValueHandler"><a href="#自定义HandlerMethodReturnValueHandler" class="headerlink" title="自定义HandlerMethodReturnValueHandler"></a>自定义HandlerMethodReturnValueHandler</h2><p><code>HandlerMethodArgumentResolver</code>俗称方法返回值解析器，用于解析由<code>@RequestMapping</code>注解（或其派生的注解）所标注的方法的返回值。这里我们开始通过实现<code>HandlerMethodReturnValueHandler</code>的方式来自定义一个用于处理返回值类型为Properties类型的解析器。</p><p>在<code>com.example.demo</code>路径下新建<code>handler</code>包，然后创建<code>PropertiesHandlerMethodReturnValueHandler</code>实现<code>HandlerMethodReturnValueHandler</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PropertiesHandlerMethodReturnValueHandler</span> <span class="keyword">implements</span> <span class="title">HandlerMethodReturnValueHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">supportsReturnType</span><span class="params">(MethodParameter returnType)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Properties.class.equals(returnType.getMethod().getReturnType());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleReturnValue</span><span class="params">(Object returnValue, MethodParameter returnType, ModelAndViewContainer mavContainer, NativeWebRequest webRequest)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Properties properties = (Properties) returnValue;</span><br><span class="line"></span><br><span class="line">        ServletWebRequest servletWebRequest = (ServletWebRequest) webRequest;</span><br><span class="line"></span><br><span class="line">        HttpServletResponse response = servletWebRequest.getResponse();</span><br><span class="line">        ServletServerHttpResponse servletServerHttpResponse = <span class="keyword">new</span> ServletServerHttpResponse(response);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取请求头</span></span><br><span class="line">        HttpHeaders headers = servletServerHttpResponse.getHeaders();</span><br><span class="line"></span><br><span class="line">        MediaType contentType = headers.getContentType();</span><br><span class="line">        <span class="comment">// 获取编码</span></span><br><span class="line">        Charset charset = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (contentType != <span class="keyword">null</span>) &#123;</span><br><span class="line">            charset = contentType.getCharset();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        charset = charset == <span class="keyword">null</span> ? Charset.forName(<span class="string">"UTF-8"</span>) : charset;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取请求体</span></span><br><span class="line">        OutputStream body = servletServerHttpResponse.getBody();</span><br><span class="line">        OutputStreamWriter outputStreamWriter = <span class="keyword">new</span> OutputStreamWriter(body, charset);</span><br><span class="line"></span><br><span class="line">        properties.store(outputStreamWriter, <span class="string">"Serialized by PropertiesHandlerMethodReturnValueHandler#handleReturnValue"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p><code>supportsReturnType</code>方法指定了处理返回值的类型，<code>handleReturnValue</code>方法用于处理返回值，这里的逻辑和<code>PropertiesHttpMessageConverter</code>的<code>writeInternal</code>方法基本一致，不再赘述。</p><p>接着将<code>PropertiesHandlerMethodReturnValueHandler</code>添加到到Spring自带的<code>HandlerMethodReturnValueHandler</code>实现类集合中，添加方式和自定义<code>HandlerMethodArgumentResolver</code>一致：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebConfigurer</span> <span class="keyword">implements</span> <span class="title">WebMvcConfigurer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RequestMappingHandlerAdapter requestMappingHandlerAdapter;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 获取当前 RequestMappingHandlerAdapter 所有的 ArgumentResolver对象</span></span><br><span class="line">        List&lt;HandlerMethodArgumentResolver&gt; argumentResolvers = requestMappingHandlerAdapter.getArgumentResolvers();</span><br><span class="line">        List&lt;HandlerMethodArgumentResolver&gt; newArgumentResolvers = <span class="keyword">new</span> ArrayList&lt;&gt;(argumentResolvers.size() + <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 添加 PropertiesHandlerMethodArgumentResolver 到集合第一个位置</span></span><br><span class="line">        newArgumentResolvers.add(<span class="number">0</span>, <span class="keyword">new</span> PropertiesHandlerMethodArgumentResolver());</span><br><span class="line">        <span class="comment">// 将原 ArgumentResolver 添加到集合中</span></span><br><span class="line">        newArgumentResolvers.addAll(argumentResolvers);</span><br><span class="line">        <span class="comment">// 重新设置 ArgumentResolver对象集合</span></span><br><span class="line">        requestMappingHandlerAdapter.setArgumentResolvers(newArgumentResolvers);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取当前 RequestMappingHandlerAdapter 所有的 returnValueHandlers对象</span></span><br><span class="line">        List&lt;HandlerMethodReturnValueHandler&gt; returnValueHandlers = requestMappingHandlerAdapter.getReturnValueHandlers();</span><br><span class="line">        List&lt;HandlerMethodReturnValueHandler&gt; newReturnValueHandlers = <span class="keyword">new</span> ArrayList&lt;&gt;(returnValueHandlers.size() + <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 添加 PropertiesHandlerMethodReturnValueHandler 到集合第一个位置</span></span><br><span class="line">        newReturnValueHandlers.add(<span class="number">0</span>, <span class="keyword">new</span> PropertiesHandlerMethodReturnValueHandler());</span><br><span class="line">        <span class="comment">// 将原 returnValueHandlers 添加到集合中</span></span><br><span class="line">        newReturnValueHandlers.addAll(returnValueHandlers);</span><br><span class="line">        <span class="comment">// 重新设置 ReturnValueHandlers对象集合</span></span><br><span class="line">        requestMappingHandlerAdapter.setReturnValueHandlers(newReturnValueHandlers);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>配置好后，我们将<code>TestController</code>的<code>test1</code>方法的<code>@ResponseBody</code>注解去掉，重启项目，再次访问:</p><p><img src="img/QQ截图20190228192419.png" alt="QQ截图20190228192419.png"></p><p>可以看到，返回值成功被<code>PropertiesHandlerMethodReturnValueHandler</code>的<code>handleReturnValue</code>方法解析了。</p><p>但是这里还有一个问题，我们查看控制台，会发现如下异常:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">javax.servlet.ServletException: Circular view path [test1]: would dispatch back to the current handler URL [/test1] again. Check your ViewResolver setup! (Hint: This may be the result of an unspecified view, due to default view name generation.)</span><br><span class="line">	at org.springframework.web.servlet.view.InternalResourceView.prepareForRendering(InternalResourceView.java:209) ~[spring-webmvc-5.1.2.RELEASE.jar:5.1.2.RELEASE]</span><br><span class="line">	at org.springframework.web.servlet.view.InternalResourceView.renderMergedOutputModel(InternalResourceView.java:147) ~[spring-webmvc-5.1.2.RELEASE.jar:5.1.2.RELEASE]</span><br><span class="line">	at org.springframework.web.servlet.view.AbstractView.render(AbstractView.java:316) ~[spring-webmvc-5.1.2.RELEASE.jar:5.1.2.RELEASE]</span><br><span class="line">	at org.springframework.web.servlet.DispatcherServlet.render(DispatcherServlet.java:1370) ~[spring-webmvc-5.1.2.RELEASE.jar:5.1.2.RELEASE]</span><br><span class="line">	at org.springframework.web.servlet.DispatcherServlet.processDispatchResult(DispatcherServlet.java:1116) ~[spring-webmvc-5.1.2.RELEASE.jar:5.1.2.RELEASE]</span><br><span class="line">	at org.springframework.web.servlet.DispatcherServlet.doDispatch(DispatcherServlet.java:1055) ~[spring-webmvc-5.1.2.RELEASE.jar:5.1.2.RELEASE]</span><br><span class="line">	at org.springframework.web.servlet.DispatcherServlet.doService(DispatcherServlet.java:942) ~[spring-webmvc-5.1.2.RELEASE.jar:5.1.2.RELEASE]</span><br><span class="line">	at org.springframework.web.servlet.FrameworkServlet.processRequest(FrameworkServlet.java:998) ~[spring-webmvc-5.1.2.RELEASE.jar:5.1.2.RELEASE]</span><br><span class="line">	at org.springframework.web.servlet.FrameworkServlet.doGet(FrameworkServlet.java:890) ~[spring-webmvc-5.1.2.RELEASE.jar:5.1.2.RELEASE]</span><br><span class="line">	at javax.servlet.http.HttpServlet.service(HttpServlet.java:634) ~[tomcat-embed-core-9.0.12.jar:9.0.12]</span><br><span class="line">	at org.springframework.web.servlet.FrameworkServlet.service(FrameworkServlet.java:875) ~[spring-webmvc-5.1.2.RELEASE.jar:5.1.2.RELEASE]</span><br><span class="line">	at javax.servlet.http.HttpServlet.service(HttpServlet.java:741) ~[tomcat-embed-core-9.0.12.jar:9.0.12]</span><br><span class="line">	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:231) ~[tomcat-embed-core-9.0.12.jar:9.0.12]</span><br><span class="line">	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) ~[tomcat-embed-core-9.0.12.jar:9.0.12]</span><br><span class="line">	at org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:53) ~[tomcat-embed-websocket-9.0.12.jar:9.0.12]</span><br><span class="line">	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) ~[tomcat-embed-core-9.0.12.jar:9.0.12]</span><br><span class="line">	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) ~[tomcat-embed-core-9.0.12.jar:9.0.12]</span><br><span class="line">	at org.springframework.web.filter.RequestContextFilter.doFilterInternal(RequestContextFilter.java:99) ~[spring-web-5.1.2.RELEASE.jar:5.1.2.RELEASE]</span><br><span class="line">	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107) ~[spring-web-5.1.2.RELEASE.jar:5.1.2.RELEASE]</span><br><span class="line">	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) ~[tomcat-embed-core-9.0.12.jar:9.0.12]</span><br><span class="line">	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) ~[tomcat-embed-core-9.0.12.jar:9.0.12]</span><br><span class="line">	at org.springframework.web.filter.FormContentFilter.doFilterInternal(FormContentFilter.java:92) ~[spring-web-5.1.2.RELEASE.jar:5.1.2.RELEASE]</span><br><span class="line">	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107) ~[spring-web-5.1.2.RELEASE.jar:5.1.2.RELEASE]</span><br><span class="line">	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) ~[tomcat-embed-core-9.0.12.jar:9.0.12]</span><br><span class="line">	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) ~[tomcat-embed-core-9.0.12.jar:9.0.12]</span><br><span class="line">	at org.springframework.web.filter.HiddenHttpMethodFilter.doFilterInternal(HiddenHttpMethodFilter.java:93) ~[spring-web-5.1.2.RELEASE.jar:5.1.2.RELEASE]</span><br><span class="line">	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107) ~[spring-web-5.1.2.RELEASE.jar:5.1.2.RELEASE]</span><br><span class="line">	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) ~[tomcat-embed-core-9.0.12.jar:9.0.12]</span><br><span class="line">	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) ~[tomcat-embed-core-9.0.12.jar:9.0.12]</span><br><span class="line">	at org.springframework.web.filter.CharacterEncodingFilter.doFilterInternal(CharacterEncodingFilter.java:200) ~[spring-web-5.1.2.RELEASE.jar:5.1.2.RELEASE]</span><br><span class="line">	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107) ~[spring-web-5.1.2.RELEASE.jar:5.1.2.RELEASE]</span><br><span class="line">	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) ~[tomcat-embed-core-9.0.12.jar:9.0.12]</span><br><span class="line">	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) ~[tomcat-embed-core-9.0.12.jar:9.0.12]</span><br><span class="line">	at org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:199) ~[tomcat-embed-core-9.0.12.jar:9.0.12]</span><br><span class="line">	at org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:96) [tomcat-embed-core-9.0.12.jar:9.0.12]</span><br><span class="line">	at org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:490) [tomcat-embed-core-9.0.12.jar:9.0.12]</span><br><span class="line">	at org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:139) [tomcat-embed-core-9.0.12.jar:9.0.12]</span><br><span class="line">	at org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:92) [tomcat-embed-core-9.0.12.jar:9.0.12]</span><br><span class="line">	at org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:74) [tomcat-embed-core-9.0.12.jar:9.0.12]</span><br><span class="line">	at org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:343) [tomcat-embed-core-9.0.12.jar:9.0.12]</span><br><span class="line">	at org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:408) [tomcat-embed-core-9.0.12.jar:9.0.12]</span><br><span class="line">	at org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:66) [tomcat-embed-core-9.0.12.jar:9.0.12]</span><br><span class="line">	at org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:770) [tomcat-embed-core-9.0.12.jar:9.0.12]</span><br><span class="line">	at org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1415) [tomcat-embed-core-9.0.12.jar:9.0.12]</span><br><span class="line">	at org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:49) [tomcat-embed-core-9.0.12.jar:9.0.12]</span><br><span class="line">	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149) [na:1.8.0_171]</span><br><span class="line">	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624) [na:1.8.0_171]</span><br><span class="line">	at org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:61) [tomcat-embed-core-9.0.12.jar:9.0.12]</span><br><span class="line">	at java.lang.Thread.run(Thread.java:748) [na:1.8.0_171]</span><br></pre></td></tr></table></figure><p>这是因为，在Spring中如果Controller中的方法没有被<code>@ResponseBody</code>标注的话，默认会把返回值当成视图的名称，而这里我们并不希望解析的Properties值被当成视图名称，所以我们需要在<code>PropertiesHandlerMethodReturnValueHandler</code>的<code>handleReturnValue</code>方法最后一行添加如下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 告诉 Spring MVC 请求已经处理完毕</span></span><br><span class="line">mavContainer.setRequestHandled(<span class="keyword">true</span>);</span><br></pre></td></tr></table></figure><p>这行代码告诉Spring，请求已经成功完成了，无需进行后续的处理。重启项目再次访问上面的请求，控制台便不再抛异常了。</p><blockquote><p>源码链接：<a href="https://github.com/wuyouzhuguli/SpringAll/tree/master/47.Spring-Boot-Content-Negotiation" target="_blank" rel="noopener">https://github.com/wuyouzhuguli/SpringAll/tree/master/47.Spring-Boot-Content-Negotiation</a></p></blockquote><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Thu Apr 04 2019 14:23:37 GMT+0800 (GMT+08:00) --&gt;&lt;p&gt;&lt;strong&gt;内容协商&lt;/strong&gt;机制是指客户端和服务器端就响应的资源内容进行交涉，然后提供给客户端最为适合的资源。内容协商会以响应资源的语言、字符集、编码方式等作为判断的基准。HTTP请求头中Content-Type，Accept等内容就是内容协商判断的标准。在Spring Boot中，一个完整的内容协商过程如下图所示：&lt;/p&gt;
    
    </summary>
    
    
      <category term="Spring" scheme="http://mrbird.cc/tags/Spring/"/>
    
      <category term="Spring Boot" scheme="http://mrbird.cc/tags/Spring-Boot/"/>
    
  </entry>
  
  <entry>
    <title>Spring Boot配合Hibernate Validator参数校验</title>
    <link href="http://mrbird.cc/Spring-Boot-Hibernate-Validator-Params-Check.html"/>
    <id>http://mrbird.cc/Spring-Boot-Hibernate-Validator-Params-Check.html</id>
    <published>2018-09-14T02:01:45.000Z</published>
    <updated>2019-03-13T10:50:11.216Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Apr 04 2019 14:23:35 GMT+0800 (GMT+08:00) --><p>Spring Boot中结合Hibernate Validator可以实现优雅的参数校验，而不必在业务代码中写一大堆的参数校验逻辑。Hibernate Validator的基本使用可以参考<a href="/Spring表单校验.html">Spring表单校验</a>，这里介绍一种结合全局异常捕获的方式来实现低耦合简洁的参数校验解决方案。</p><a id="more"></a><h2 id="方法参数校验"><a href="#方法参数校验" class="headerlink" title="方法参数校验"></a>方法参数校验</h2><p>新建一个Spring Boot工程，版本为2.1.0.RELEASE，<code>artifactId</code>为<code>validator</code>，并引入<code>spring-boot-starter-web</code>和<code>commons-lang3</code>依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.commons<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-lang3<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><p></p><p>项目结构如下所示：</p><p><img src="img/QQ截图20190227113219.png" alt="QQ截图20190227113219.png"></p><p><code>spring-boot-starter-web</code>已经包含了<code>hibernate-validator</code>，所以无需单独引入： <img src="img/QQ截图20190227114315.png" alt="QQ截图20190227114315.png"></p><p>在<code>com.example.demo</code>下新建<code>controller</code>包，然后创建<code>TestController</code>，定义一个<code>test1</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@Validated</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"test1"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">test1</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">            @NotBlank(message = <span class="string">"&#123;required&#125;"</span>)</span> String name,</span></span><br><span class="line"><span class="function">            @<span class="title">Email</span><span class="params">(message = <span class="string">"&#123;invalid&#125;"</span>)</span> String email) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"success"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p><code>test1</code>方法的<code>name</code>参数使用<code>@NotBlank</code>标注，表示不能为空，提示信息为<code>{required}</code>占位符里的内容；<code>email</code>参数使用<code>@Email</code>注解标注，表示必须为一个合法的邮箱值（可以为空），提示信息为<code>{invalid}</code>占位符里的内容。要让参数校验生效，我们还需在类上使用<code>@Validated</code>注解标注。</p><p>接下来定义上面两个占位符的内容。在resources目录下新建ValidationMessages.properties文件，内容如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">required=\u4e0d\u80fd\u4e3a\u7a7a</span><br><span class="line">invalid=\u683c\u5f0f\u4e0d\u5408\u6cd5</span><br></pre></td></tr></table></figure><p></p><p>内容为中文转Unicode后的值，可以使用<a href="http://tool.chinaz.com/tools/unicode.aspx" target="_blank" rel="noopener">http://tool.chinaz.com/tools/unicode.aspx</a>网站转换，<code>\u4e0d\u80fd\u4e3a\u7a7a</code>转为中文为“不能为空”，<code>\u683c\u5f0f\u4e0d\u5408\u6cd5</code>转为中文为“格式不合法”。</p><p>启动项目，使用Postman进行测试，参数内容如下所示：</p><p><img src="img/QQ截图20190227140409.png" alt="QQ截图20190227140409.png"></p><p>这里<code>name</code>参数值为空，<code>email</code>参数值为123，访问后，控制台输出异常如下：</p><p><img src="img/QQ截图20190227140521.png" alt="QQ截图20190227140521.png"></p><p>可见，使用这种方式参数校验不通过时，会抛出<code>javax.validation.ConstraintViolationException</code>，我们使用全局异常捕获来处理这种异常：</p><p>在<code>com.example.demo</code>下新建<code>handler</code>包，然后创建<code>GlobalExceptionHandler</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestControllerAdvice</span></span><br><span class="line"><span class="meta">@Order</span>(value = Ordered.HIGHEST_PRECEDENCE)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GlobalExceptionHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 统一处理请求参数校验(普通传参)</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> e ConstraintViolationException</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> FebsResponse</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@ExceptionHandler</span>(value = ConstraintViolationException.class)</span><br><span class="line">    <span class="meta">@ResponseStatus</span>(HttpStatus.BAD_REQUEST)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">handleConstraintViolationException</span><span class="params">(ConstraintViolationException e)</span> </span>&#123;</span><br><span class="line">        StringBuilder message = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        Set&lt;ConstraintViolation&lt;?&gt;&gt; violations = e.getConstraintViolations();</span><br><span class="line">        <span class="keyword">for</span> (ConstraintViolation&lt;?&gt; violation : violations) &#123;</span><br><span class="line">            Path path = violation.getPropertyPath();</span><br><span class="line">            String[] pathArr = StringUtils.splitByWholeSeparatorPreserveAllTokens(path.toString(), <span class="string">"."</span>);</span><br><span class="line">            message.append(pathArr[<span class="number">1</span>]).append(violation.getMessage()).append(<span class="string">","</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        message = <span class="keyword">new</span> StringBuilder(message.substring(<span class="number">0</span>, message.length() - <span class="number">1</span>));</span><br><span class="line">        <span class="keyword">return</span> message.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>上面主要的逻辑是获取校验不通过的参数名称，然后拼接上提示信息，并且HTTP返回状态码为400。重启项目，再次访问刚刚的链接，响应如下所示：</p><p><img src="img/QQ截图20190227141744.png" alt="QQ截图20190227141744.png"></p><h2 id="使用实体传参"><a href="#使用实体传参" class="headerlink" title="使用实体传参"></a>使用实体传参</h2><p>当参数较少的时候可以使用上面这种方式，但如果参数众多上面的方式就略显繁琐了。这时候我们可以使用实体对象来进行传参。</p><p>为了模拟这种情况，我们在<code>com.example.demo</code>路径下新建<code>domain</code>包，然后新建<code>User</code>类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">2731598327208972274L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@NotBlank</span>(message = <span class="string">"&#123;required&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Email</span>(message = <span class="string">"&#123;invalid&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String email;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getEmail</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> email;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setEmail</span><span class="params">(String email)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.email = email;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>接着在<code>TestController</code>里创建一个<code>test2</code>方法:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"test2"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">test2</span><span class="params">(@Valid User user)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"success"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>使用实体对象传参的方式参数校验需要在相应的参数前加上<code>@Valid</code>注解。重启项目，再次访问下面这个请求： <img src="img/QQ截图20190227140409.png" alt="QQ截图20190227140409.png"></p><p>控制台会输出如下信息:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Resolved [org.springframework.validation.BindException: org.springframework.validation.BeanPropertyBindingResult: 2 errors</span><br><span class="line">Field error in object &apos;user&apos; on field &apos;name&apos;: rejected value []; codes [NotBlank.user.name,NotBlank.name,NotBlank.java.lang.String,NotBlank]; arguments [org.springframework.context.support.DefaultMessageSourceResolvable: codes [user.name,name]; arguments []; default message [name]]; default message [不能为空]</span><br><span class="line">Field error in object &apos;user&apos; on field &apos;email&apos;: rejected value [123]; codes [Email.user.email,Email.email,Email.java.lang.String,Email]; arguments [org.springframework.context.support.DefaultMessageSourceResolvable: codes [user.email,email]; arguments []; default message [email],[Ljavax.validation.constraints.Pattern$Flag;@5fb82092,org.springframework.validation.beanvalidation.SpringValidatorAdapter$ResolvableAttribute@cc0c307]; default message [格式不合法]]</span><br></pre></td></tr></table></figure><p>这时候我们需要在<code>GlobalExceptionHandler</code>捕获<code>org.springframework.validation.BindException</code>异常：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 统一处理请求参数校验(实体对象传参)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> e BindException</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> FebsResponse</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@ExceptionHandler</span>(BindException.class)</span><br><span class="line"><span class="meta">@ResponseStatus</span>(HttpStatus.BAD_REQUEST)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">validExceptionHandler</span><span class="params">(BindException e)</span> </span>&#123;</span><br><span class="line">    StringBuilder message = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    List&lt;FieldError&gt; fieldErrors = e.getBindingResult().getFieldErrors();</span><br><span class="line">    <span class="keyword">for</span> (FieldError error : fieldErrors) &#123;</span><br><span class="line">        message.append(error.getField()).append(error.getDefaultMessage()).append(<span class="string">","</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    message = <span class="keyword">new</span> StringBuilder(message.substring(<span class="number">0</span>, message.length() - <span class="number">1</span>));</span><br><span class="line">    <span class="keyword">return</span> message.toString();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>重启项目，再次访问刚刚的请求，响应如下所示:</p><p><img src="img/QQ截图20190227143248.png" alt="QQ截图20190227143248.png"></p><p>我们将请求参数改为合法的内容：</p><p><img src="img/QQ截图20190227143400.png" alt="QQ截图20190227143400.png"></p><p>点击访问，响应如下所示:</p><p><img src="img/QQ截图20190227143434.png" alt="QQ截图20190227143434.png"></p><blockquote><p>源码链接：<a href="https://github.com/wuyouzhuguli/SpringAll/tree/master/46.Spring-Boot-Hibernate-Validator" target="_blank" rel="noopener">https://github.com/wuyouzhuguli/SpringAll/tree/master/46.Spring-Boot-Hibernate-Validator</a></p></blockquote><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Thu Apr 04 2019 14:23:35 GMT+0800 (GMT+08:00) --&gt;&lt;p&gt;Spring Boot中结合Hibernate Validator可以实现优雅的参数校验，而不必在业务代码中写一大堆的参数校验逻辑。Hibernate Validator的基本使用可以参考&lt;a href=&quot;/Spring表单校验.html&quot;&gt;Spring表单校验&lt;/a&gt;，这里介绍一种结合全局异常捕获的方式来实现低耦合简洁的参数校验解决方案。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Spring" scheme="http://mrbird.cc/tags/Spring/"/>
    
      <category term="Spring Boot" scheme="http://mrbird.cc/tags/Spring-Boot/"/>
    
  </entry>
  
  <entry>
    <title>深入学习Spring Boot中的SpringApplication</title>
    <link href="http://mrbird.cc/deepin-springboot-application.html"/>
    <id>http://mrbird.cc/deepin-springboot-application.html</id>
    <published>2018-09-04T06:54:26.000Z</published>
    <updated>2019-03-13T10:50:36.507Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Apr 04 2019 14:23:36 GMT+0800 (GMT+08:00) --><p>在Spring Boot的入口类中，我们通常是通过调用<code>SpringApplication</code>的run方法来启动Spring Boot项目。这节我们来深入学习下SpringApplication的一些细节。</p><h2 id="自定义SpringApplication"><a href="#自定义SpringApplication" class="headerlink" title="自定义SpringApplication"></a>自定义SpringApplication</h2><p>默认的我们都是直接通过<code>SpringApplication</code>的run方法来直接启动Spring Boot，其实我们可以通过一些API来调整某些行为。<a id="more"></a></p><h3 id="通过SpringApplication-API调整"><a href="#通过SpringApplication-API调整" class="headerlink" title="通过SpringApplication API调整"></a>通过SpringApplication API调整</h3><p>我们新建一个SpringBoot项目，Spring Boot版本为2.1.0.RELEASE，<code>artifactId</code>为SpringApplication，并引入<code>spring-boot-starter-web</code>依赖。项目结构如下所示:</p><p><img src="img/QQ截图20190223103358.png" alt="QQ截图20190223103358.png"></p><p>我们将入口类的代码改为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SpringApplication application = <span class="keyword">new</span> SpringApplication(DemoApplication.class);</span><br><span class="line">application.setBannerMode(Banner.Mode.OFF);</span><br><span class="line">application.setWebApplicationType(WebApplicationType.NONE);</span><br><span class="line">application.setAdditionalProfiles(<span class="string">"dev"</span>);</span><br><span class="line">application.run(args);</span><br></pre></td></tr></table></figure><p></p><p>通过调用<code>SpringApplication</code>的方法，我们关闭了Banner的打印，设置应用环境为非WEB应用，profiles指定为dev。除此之外，<code>SpringApplication</code>还包含了许多别的方法，具体可以查看源码或者官方文档：</p><p><img src="img/QQ截图20190223101959.png" alt="QQ截图20190223101959.png"></p><h3 id="通过SpringApplicationBuilder-API调整"><a href="#通过SpringApplicationBuilder-API调整" class="headerlink" title="通过SpringApplicationBuilder API调整"></a>通过SpringApplicationBuilder API调整</h3><p><code>SpringApplicationBuilder</code>提供了Fluent API，可以实现链式调用，下面的代码和上面的效果一致，但在编写上较为方便：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> SpringApplicationBuilder(DemoApplication.class)</span><br><span class="line">        .bannerMode(Banner.Mode.OFF)</span><br><span class="line">        .web(WebApplicationType.NONE)</span><br><span class="line">        .profiles(<span class="string">"dev"</span>)</span><br><span class="line">        .run(args);</span><br></pre></td></tr></table></figure><h2 id="SpringApplication准备阶段"><a href="#SpringApplication准备阶段" class="headerlink" title="SpringApplication准备阶段"></a>SpringApplication准备阶段</h2><p><code>SpringApplicaiton</code>的生命周期阶段大致可以分为准备阶段和运行阶段。</p><p>我们通过源码来查看<code>SpringApplication</code>的有参构造器：</p><p><img src="img/QQ截图20190223102806.png" alt="QQ截图20190223102806.png"></p><p>通过有参构造器里的代码我们可以将<code>SpringApplication</code>的准备阶段分为以下几个步骤：</p><h3 id="配置源"><a href="#配置源" class="headerlink" title="配置源"></a>配置源</h3><p>构造器中<code>this.primarySources = new LinkedHashSet&lt;&gt;(Arrays.asList(primarySources));</code>这行代码用于加载我们配置的Spring Boot Bean源。通常我们使用<code>SpringApplication</code>或者<code>SpringApplicationBuilder</code>的构造器来直接指定源。</p><p>所谓的Spring Boot Bean源指的是某个被<code>@SpringBootApplication</code>注解标注的类，比如入口类：</p><p><img src="img/QQ截图20190223104742.png" alt="QQ截图20190223104742.png"></p><p>我们也可以将上面的代码改为下面这种方式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication application = <span class="keyword">new</span> SpringApplication(ApplicationResource.class);</span><br><span class="line">        application.run(args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SpringBootApplication</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ApplicationResource</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>这样也是可行的。查看<code>SpringApplicaiton</code>的单个参数构造器：</p><p><img src="img/QQ截图20190223105200.png" alt="QQ截图20190223105200.png"></p><p>说明我们除了配置单个源外，还可以配置多个源。</p><h3 id="推断应用类型"><a href="#推断应用类型" class="headerlink" title="推断应用类型"></a>推断应用类型</h3><p>构造器中这行<code>this.webApplicationType = WebApplicationType.deduceFromClasspath();</code>代码用于推断当前Spring Boot应用类型。</p><p>Spring Boot 2.0后，应用可以分为下面三种类型：</p><ol><li><p><code>WebApplicationType.NONE</code>：非WEB类型；</p></li><li><p><code>WebApplicationType.REACTIVE</code>：Web Reactive类型；</p></li><li><p><code>WebApplicationType.SERVLET</code>：Web Servlet类型。</p></li></ol><p><code>WebApplicationType.deduceFromClasspath()</code>或根据当前应用ClassPath中是否存在相关的实现类来判断应用类型到底是哪个，<code>deduceFromClasspath</code>方法的源码如下所示:</p><p><img src="img/QQ截图20190223105842.png" alt="QQ截图20190223105842.png"></p><p>我们也可以直接通过<code>SpringApplication</code>的<code>setWebApplicationType</code>方法或者<code>SpringApplicationBuilder</code>的<code>web</code>方法来指定当前应用的类型。</p><h3 id="加载应用上下文初始器"><a href="#加载应用上下文初始器" class="headerlink" title="加载应用上下文初始器"></a>加载应用上下文初始器</h3><p>接着下一行代码<code>setInitializers((Collection) getSpringFactoriesInstances(ApplicationContextInitializer.class));</code>用于加载应用上下文初始器<code>ApplicationContextInitializer</code>。</p><p><code>getSpringFactoriesInstances</code>方法的源码如下所示：</p><p><img src="img/QQ截图20190223110924.png" alt="QQ截图20190223110924.png"></p><p>上面代码利用Spring工厂加载机制，实例化<code>ApplicationContextInitializer</code>实现类，并进行排序。</p><p>所以我们可以通过实现<code>ApplicationContextInitializer</code>接口用于在Spring Boot应用初始化之前执行一些自定义操作。</p><p>举个例子，在<code>com.example.demo</code>下新建<code>initializer</code>包，然后创建一个<code>HelloApplicationContextInitializer</code>类，实现<code>ApplicationContextInitializer</code>接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Order</span>(Ordered.HIGHEST_PRECEDENCE)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloApplicationContextInitializer</span> <span class="keyword">implements</span> <span class="title">ApplicationContextInitializer</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initialize</span><span class="params">(ConfigurableApplicationContext applicationContext)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"ConfigurableApplicationContext.id - "</span> + applicationContext.getId());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>上面代码中实现了initialize方法，并且使用<code>@Order</code>注解指定优先级。其中<code>Ordered.HIGHEST_PRECEDENCE</code>等于<code>Integer.MIN_VALUE</code>，<code>Ordered.LOWEST_PRECEDENCE</code>等于<code>Integer.MAX_VALUE</code>。所以数值越小，优先级越高。</p><p>除了使用<code>@Order</code>注解来指定优先级外，我们也可以通过实现<code>org.springframework.core.Ordered</code>接口的<code>getOrder</code>方法来指定优先级。</p><p>接着我们来创建一个优先级比<code>HelloApplicationContextInitializer</code>低的Initializer —— <code>AfterHelloApplicationContextInitializer</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AfterHelloApplicationContextInitializer</span> <span class="keyword">implements</span> <span class="title">ApplicationContextInitializer</span>, <span class="title">Ordered</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initialize</span><span class="params">(ConfigurableApplicationContext applicationContext)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"AfterHelloApplicationContextInitializer: "</span> + applicationContext.getId());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Ordered.LOWEST_PRECEDENCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>上面通过<code>getOrder</code>方法来指定了优先级为最低优先级。</p><p>创建好后，我们还需在工厂配置文件里配置这两个实现类。在resources目录下新建META-INF目录，并创建spring.factories文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># Initializers</span><br><span class="line">org.springframework.context.ApplicationContextInitializer=\</span><br><span class="line">com.example.demo.initializer.HelloApplicationContextInitializer,\</span><br><span class="line">com.example.demo.initializer.AfterHelloApplicationContextInitializer</span><br></pre></td></tr></table></figure><p></p><p>这时候，启动Spring Boot项目，会发现控制台在打印Banner后就执行了这两个初始化器，并且<code>HelloApplicationContextInitializer</code>的<code>initialize</code>方法执行时机先于<code>AfterHelloApplicationContextInitializer</code>的<code>initialize</code>方法：</p><p><img src="img/QQ截图20190223155233.png" alt="QQ截图20190223155233.png"></p><h3 id="加载应用事件监听器"><a href="#加载应用事件监听器" class="headerlink" title="加载应用事件监听器"></a>加载应用事件监听器</h3><p>在加载完应用上下文初始器后，下一行的<code>setListeners((Collection) getSpringFactoriesInstances(ApplicationListener.class));</code>代码加载了应用事件监听器。与加载事件上下文初始器类似，Spring Boot也是通过Spring的工厂方法来实例化<code>ApplicationListener</code>的实现类，并进行排序。</p><p>既然是事件监听，那么其可以监听什么事件呢？其监听的是<code>ApplicationEvent</code>接口的实现类，我们查看一下都有哪些事件实现了这个接口：</p><p><img src="img/QQ截图20190223162205.png" alt="QQ截图20190223162205.png"></p><p>这里我们以<code>ContextClosedEvent</code>为例子来编写自定义的应用事件监听器，监听Spring上下文关闭事件。</p><p>在<code>com.example.demo</code>下新建<code>listener</code>包，然后创建一个<code>ContextClosedEventListener</code>类，实现<code>ApplicationListener</code>接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Order</span>(Ordered.HIGHEST_PRECEDENCE)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ContextClosedEventListener</span> <span class="keyword">implements</span> <span class="title">ApplicationListener</span>&lt;<span class="title">ContextClosedEvent</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onApplicationEvent</span><span class="params">(ContextClosedEvent event)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"ContextClosedEvent: "</span> + event.getApplicationContext().getId());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>上面代码实现了对<code>ContextClosedEvent</code>事件的监听，并且分配了最高优先级。</p><p>接着创建一个优先级比<code>ContextClosedEventListener</code>低的上面代码实现了对<code>ContextClosedEvent</code>事件监听器<code>AfterContextClosedEventListener</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AfterContextClosedEventListener</span> <span class="keyword">implements</span> <span class="title">ApplicationListener</span>&lt;<span class="title">ContextClosedEvent</span>&gt;, <span class="title">Ordered</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onApplicationEvent</span><span class="params">(ContextClosedEvent event)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"AfterContextClosedEventr: "</span> + event.getApplicationContext().getId());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Ordered.HIGHEST_PRECEDENCE + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>最后，别忘了在Spring工厂配置文件里进行配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># Application Listeners</span><br><span class="line">org.springframework.context.ApplicationListener=\</span><br><span class="line">com.example.demo.listener.ContextClosedEventListener,\</span><br><span class="line">com.example.demo.listener.AfterContextClosedEventListener</span><br></pre></td></tr></table></figure><p></p><p>在Spring Boot入口类中将环境指定为非WEB环境（这样在启动后应用会马上关闭）:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> SpringApplicationBuilder(DemoApplication.class)</span><br><span class="line">                .web(WebApplicationType.NONE)</span><br><span class="line">                .run(args);</span><br></pre></td></tr></table></figure><p></p><p>运行Spring Boot入口类，控制台输出如下： <img src="img/QQ截图20190223162948.png" alt="QQ截图20190223162948.png"></p><h3 id="推断入口类"><a href="#推断入口类" class="headerlink" title="推断入口类"></a>推断入口类</h3><p>接着构造器里的代码下一行<code>this.mainApplicationClass = deduceMainApplicationClass();</code>用于推断运行Spring Boot应用的入口类。查看<code>deduceMainApplicationClass</code>方法源码：</p><p><img src="img/QQ截图20190225093317.png" alt="QQ截图20190225093317.png"></p><p>代码主要逻辑是根据Main线程执行堆栈判断实际的入口类。</p><p>准备阶段介绍完毕后，接下来开始介绍运行阶段。</p><h2 id="SpringApplication运行阶段"><a href="#SpringApplication运行阶段" class="headerlink" title="SpringApplication运行阶段"></a>SpringApplication运行阶段</h2><p>SpringApplication的运行阶段对应<code>SpringApplication</code>的<code>run</code>方法，我们查看其源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ConfigurableApplicationContext <span class="title">run</span><span class="params">(String... args)</span> </span>&#123;</span><br><span class="line">    StopWatch stopWatch = <span class="keyword">new</span> StopWatch();</span><br><span class="line">    stopWatch.start();</span><br><span class="line">    ConfigurableApplicationContext context = <span class="keyword">null</span>;</span><br><span class="line">    Collection&lt;SpringBootExceptionReporter&gt; exceptionReporters = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    configureHeadlessProperty();</span><br><span class="line">    SpringApplicationRunListeners listeners = getRunListeners(args);</span><br><span class="line">    listeners.starting();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ApplicationArguments applicationArguments = <span class="keyword">new</span> DefaultApplicationArguments(</span><br><span class="line">                args);</span><br><span class="line">        ConfigurableEnvironment environment = prepareEnvironment(listeners,</span><br><span class="line">                applicationArguments);</span><br><span class="line">        configureIgnoreBeanInfo(environment);</span><br><span class="line">        Banner printedBanner = printBanner(environment);</span><br><span class="line">        context = createApplicationContext();</span><br><span class="line">        exceptionReporters = getSpringFactoriesInstances(</span><br><span class="line">                SpringBootExceptionReporter.class,</span><br><span class="line">                <span class="keyword">new</span> Class[]&#123;ConfigurableApplicationContext.class&#125;, context);</span><br><span class="line">        prepareContext(context, environment, listeners, applicationArguments,</span><br><span class="line">                printedBanner);</span><br><span class="line">        refreshContext(context);</span><br><span class="line">        afterRefresh(context, applicationArguments);</span><br><span class="line">        stopWatch.stop();</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.logStartupInfo) &#123;</span><br><span class="line">            <span class="keyword">new</span> StartupInfoLogger(<span class="keyword">this</span>.mainApplicationClass)</span><br><span class="line">                    .logStarted(getApplicationLog(), stopWatch);</span><br><span class="line">        &#125;</span><br><span class="line">        listeners.started(context);</span><br><span class="line">        callRunners(context, applicationArguments);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">        handleRunFailure(context, ex, exceptionReporters, listeners);</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(ex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        listeners.running(context);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">        handleRunFailure(context, ex, exceptionReporters, <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(ex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> context;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>运行阶段大致可以分为下面这几个过程：</p><h3 id="开启时间监听"><a href="#开启时间监听" class="headerlink" title="开启时间监听"></a>开启时间监听</h3><p><code>run</code>方法开头的这两行代码用于开启时间监听：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">StopWatch stopWatch = <span class="keyword">new</span> StopWatch();</span><br><span class="line">stopWatch.start();</span><br></pre></td></tr></table></figure><p></p><p>上面代码用于开启Spring Boot应用启动时间监听，配合下面的<code>stopWatch.stop();</code>便可以计算出完整的启动时间。</p><h3 id="开启运行监听器"><a href="#开启运行监听器" class="headerlink" title="开启运行监听器"></a>开启运行监听器</h3><p><code>run</code>方法的这几行代码用于加载Spring应用运行监听器（SpringApplicationRunListener）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SpringApplicationRunListeners listeners = getRunListeners(args);</span><br><span class="line">listeners.started();</span><br></pre></td></tr></table></figure><p></p><p><code>getRunListeners</code>方法源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> SpringApplicationRunListeners <span class="title">getRunListeners</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Class&lt;?&gt;[] types = <span class="keyword">new</span> Class&lt;?&gt;[] &#123; SpringApplication.class, String[].class &#125;;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> SpringApplicationRunListeners(logger, getSpringFactoriesInstances(</span><br><span class="line">        SpringApplicationRunListener.class, types, <span class="keyword">this</span>, args));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>上面代码通过<code>SpringFactoriesLoader</code>检索META-INF/spring.factories找到声明的所有<code>SpringApplicationRunListener</code>的实现类并将其实例化，然后装配到<code>List&lt;SpringApplicationRunListener&gt;</code>运行监听器集合中。</p><p><code>listeners.started();</code>用于遍历运行监听器集合中的所有<code>SpringApplicationRunListener</code>的实现类，并逐一调用它们的<code>starting</code>方法，广播Spring Boot应用要开始启动了。</p><p>在Spring Boot中<code>SpringApplicationRunListener</code>接口用于监听整个Spring Boot应用生命周期，其代码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">SpringApplicationRunListener</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">starting</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">environmentPrepared</span><span class="params">(ConfigurableEnvironment environment)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">contextPrepared</span><span class="params">(ConfigurableApplicationContext context)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">contextLoaded</span><span class="params">(ConfigurableApplicationContext context)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">started</span><span class="params">(ConfigurableApplicationContext context)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">running</span><span class="params">(ConfigurableApplicationContext context)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">failed</span><span class="params">(ConfigurableApplicationContext context, Throwable exception)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>这些方法对应着Spring Boot应用生命周期的各个阶段：</p><table><tr><th>方法名称</th><th>对应生命周期</th><th>Spring Boot起始版本</th></tr><tr><td>starting()</td><td>Spring 应用刚启动</td><td>1.0</td></tr><tr><td>environmentPrepared(ConfigurableEnvironment)</td><td>ConfigurableEnvironment 准备完毕，允许将其调整</td><td>1.0</td></tr><tr><td>contextPrepared(ConfigurableApplicationContext)</td><td>ConfigurableApplicationContext 准备完毕，允许将其调整</td><td>1.0</td></tr><tr><td>contextLoaded(ConfigurableApplicationContext)</td><td>ConfigurableApplicationContext 已装载，但仍未启动</td><td>1.0</td></tr><tr><td>started(ConfigurableApplicationContext)</td><td>ConfigurableApplicationContext 已启动，此时 Spring Bean 已初始化完成</td><td>2.0</td></tr><tr><td>running(ConfigurableApplicationContext)</td><td>Spring 应用正在运行</td><td>2.0</td></tr><tr><td>failed(ConfigurableApplicationContext,Throwable)</td><td>Spring 应用运行失败</td><td>2.0</td></tr></table><p>我们在<code>com.example.demo.linstener</code>下自定义一个<code>SpringApplicationRunListener</code>接口实现类<code>HelloSpringApplicationRunListener</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloApplicationRunListener</span> <span class="keyword">implements</span> <span class="title">SpringApplicationRunListener</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HelloApplicationRunListener</span><span class="params">(SpringApplication application, String[] args)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">starting</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"HelloApplicationRunListener starting......"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">environmentPrepared</span><span class="params">(ConfigurableEnvironment environment)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">contextPrepared</span><span class="params">(ConfigurableApplicationContext context)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">contextLoaded</span><span class="params">(ConfigurableApplicationContext context)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">started</span><span class="params">(ConfigurableApplicationContext context)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">running</span><span class="params">(ConfigurableApplicationContext context)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">failed</span><span class="params">(ConfigurableApplicationContext context, Throwable exception)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>通过这个实现类，我们可以在Spring Boot应用刚启动的时候在控制台输出<code>HelloApplicationRunListener starting......</code>。</p><p>因为其基于Spring的工厂方法来实现，所以我们需要在spring.factories文件里配置这个实现类:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># Run Listeners</span><br><span class="line">org.springframework.boot.SpringApplicationRunListener=\</span><br><span class="line">com.example.demo.run.HelloApplicationRunListener</span><br></pre></td></tr></table></figure><p></p><p>启动Spring Boot应用便可以在控制台看到如下输出了：</p><p><img src="img/QQ截图20190225101411.png" alt="QQ截图20190225101411.png"></p><h3 id="创建-Environment"><a href="#创建-Environment" class="headerlink" title="创建 Environment"></a>创建 Environment</h3><p><code>run</code>方法中的这行代码用于创建并配置当前SpringBoot应用将要使用的Environment（包括配置要使用的PropertySource以及Profile）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ConfigurableEnvironment environment = prepareEnvironment(listeners, applicationArguments);</span><br></pre></td></tr></table></figure><p></p><p>我们已经在准备阶段里推断出了应用类型，这里只要根据相应的应用类型来创建相应的应用环境即可，类型和环境对应关系如下：</p><ul><li><p>Web Reactive： StandardReactiveWebEnvironment</p></li><li><p>Web Servlet： StandardServletEnvironment</p></li><li><p>非 Web： StandardEnvironment</p></li></ul><p>在<code>prepareEnvironment</code>方法中会执行<code>listeners.environmentPrepared(environment);</code>，用于遍历调用所有<code>SpringApplicationRunListener</code>实现类的<code>environmentPrepared()</code>方法，广播Environment准备完毕。</p><h3 id="是否打印Banner"><a href="#是否打印Banner" class="headerlink" title="是否打印Banner"></a>是否打印Banner</h3><p><code>run</code>方法中的这行代码会根据我们的配置来决定是否打印Banner：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Banner printedBanner = printBanner(environment);</span><br></pre></td></tr></table></figure><p></p><h3 id="创建Context"><a href="#创建Context" class="headerlink" title="创建Context"></a>创建Context</h3><p><code>run</code>方法中的这行代码用于创建<code>ApplicationContext</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">context = createApplicationContext();</span><br></pre></td></tr></table></figure><p></p><p>不同的环境对应不同的<code>ApplicationContext</code>：</p><ul><li><p>Web Reactive： AnnotationConfigReactiveWebServerApplicationContext</p></li><li><p>Web Servlet： AnnotationConfigServletWebServerApplicationContext</p></li><li><p>非 Web： AnnotationConfigApplicationContext</p></li></ul><h3 id="装配Context"><a href="#装配Context" class="headerlink" title="装配Context"></a>装配Context</h3><p><code>run</code>方法中的这行代码用于装配Context：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">prepareContext(context, environment, listeners, applicationArguments, printedBanner);</span><br></pre></td></tr></table></figure><p></p><p>方法<code>prepareContext</code>的源码如下所示:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">prepareContext</span><span class="params">(ConfigurableApplicationContext context,</span></span></span><br><span class="line"><span class="function"><span class="params">                            ConfigurableEnvironment environment, SpringApplicationRunListeners listeners,</span></span></span><br><span class="line"><span class="function"><span class="params">                            ApplicationArguments applicationArguments, Banner printedBanner)</span> </span>&#123;</span><br><span class="line">    context.setEnvironment(environment);</span><br><span class="line">    postProcessApplicationContext(context);</span><br><span class="line">    applyInitializers(context);</span><br><span class="line">    listeners.contextPrepared(context);</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.logStartupInfo) &#123;</span><br><span class="line">        logStartupInfo(context.getParent() == <span class="keyword">null</span>);</span><br><span class="line">        logStartupProfileInfo(context);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Add boot specific singleton beans</span></span><br><span class="line">    ConfigurableListableBeanFactory beanFactory = context.getBeanFactory();</span><br><span class="line">    beanFactory.registerSingleton(<span class="string">"springApplicationArguments"</span>, applicationArguments);</span><br><span class="line">    <span class="keyword">if</span> (printedBanner != <span class="keyword">null</span>) &#123;</span><br><span class="line">        beanFactory.registerSingleton(<span class="string">"springBootBanner"</span>, printedBanner);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (beanFactory <span class="keyword">instanceof</span> DefaultListableBeanFactory) &#123;</span><br><span class="line">        ((DefaultListableBeanFactory) beanFactory)</span><br><span class="line">                .setAllowBeanDefinitionOverriding(<span class="keyword">this</span>.allowBeanDefinitionOverriding);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Load the sources</span></span><br><span class="line">    Set&lt;Object&gt; sources = getAllSources();</span><br><span class="line">    Assert.notEmpty(sources, <span class="string">"Sources must not be empty"</span>);</span><br><span class="line">    load(context, sources.toArray(<span class="keyword">new</span> Object[<span class="number">0</span>]));</span><br><span class="line">    listeners.contextLoaded(context);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p><code>prepareContext</code>方法开头为<code>ApplicationContext</code>加载了environment，之后通过<code>applyInitializers</code>方法逐个执行<code>ApplicationContextInitializer</code>的<code>initialize</code>方法来进一步封装<code>ApplicationContext</code>，并调用所有的<code>SpringApplicationRunListener</code>实现类的<code>contextPrepared</code>方法，广播ApplicationContext已经准备完毕了。</p><p>之后初始化IOC容器，并调用<code>SpringApplicationRunListener</code>实现类的<code>contextLoaded</code>方法，广播<code>ApplicationContext</code>加载完成，这里就包括通过<code>@EnableAutoConfiguration</code>导入的各种自动配置类。</p><h3 id="Refresh-Context"><a href="#Refresh-Context" class="headerlink" title="Refresh Context"></a>Refresh Context</h3><p><code>run</code>方法中的这行代码用于初始化所有自动配置类，并调用<code>ApplicationContext</code>的<code>refresh</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">refreshContext(context);</span><br></pre></td></tr></table></figure><p></p><h3 id="广播应用已启动"><a href="#广播应用已启动" class="headerlink" title="广播应用已启动"></a>广播应用已启动</h3><p><code>run</code>方法中的这行代码用于广播Spring Boot应用已启动：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">listeners.started(context);</span><br></pre></td></tr></table></figure><p></p><p><code>started</code>方法会调用所有的<code>SpringApplicationRunListener</code>的<code>finished</code>方法，广播SpringBoot应用已经成功启动。</p><h3 id="执行Runner"><a href="#执行Runner" class="headerlink" title="执行Runner"></a>执行Runner</h3><p><code>run</code>方法中的这行代码<code>callRunners(context, applicationArguments);</code>遍历所有<code>ApplicationRunner</code>和<code>CommandLineRunner</code>的实现类，并执行其<code>run</code>方法。我们可以实现自己的<code>ApplicationRunner</code>或者<code>CommandLineRunner</code>，来对Spring Boot的启动过程进行扩展。</p><p>我们在<code>com.example.demo</code>下新建<code>runner</code>包，然后创建一个<code>ApplicationRunner</code>的实现类<code>HelloApplicationRunner</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloApplicationRunner</span> <span class="keyword">implements</span> <span class="title">ApplicationRunner</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(ApplicationArguments args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"HelloApplicationRunner: hello spring boot"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>这里我们需要将<code>HelloApplicationRunner</code>使用<code>@Component</code>注解标注，让其注册到IOC容器中。</p><p>然后再创建一个<code>CommandLineRunner</code>的实现类<code>HelloCommandLineRunner</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloCommandLineRunner</span> <span class="keyword">implements</span> <span class="title">CommandLineRunner</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(String... args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"HelloCommandLineRunner: hello spring boot"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>启动Spring Boot应用，便可以在应用刚启动好后看到如下输出：</p><p><img src="img/QQ截图20190225112601.png" alt="QQ截图20190225112601.png"></p><h3 id="广播应用运行中"><a href="#广播应用运行中" class="headerlink" title="广播应用运行中"></a>广播应用运行中</h3><p><code>run</code>方法中的这行代码<code>listeners.running(context);</code>用于调用<code>SpringApplicationRunListener</code>的<code>running</code>方法，广播Spring Boot应用正在运行中。</p><p>当<code>run</code>方法运行出现异常时，便会调用<code>handleRunFailure</code>方法来处理异常，该方法里会通过<code>listeners.failed(context, exception);</code>来调用<code>SpringApplicationRunListener</code>的<code>failed</code>方法，广播应用启动失败，并将异常扩散出去。</p><div class="note info"><p>上面所有的广播事件都是使用Spring的应用事件广播器接口<code>ApplicationEventMulticaster</code>的实现类<code>SimpleApplicationEventMulticaster</code>来进行广播的。</p></div><blockquote><p>源码链接：<a href="https://github.com/wuyouzhuguli/SpringAll/tree/master/45.Spring-Boot-SpringApplication" target="_blank" rel="noopener">https://github.com/wuyouzhuguli/SpringAll/tree/master/45.Spring-Boot-SpringApplication</a></p></blockquote><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Thu Apr 04 2019 14:23:36 GMT+0800 (GMT+08:00) --&gt;&lt;p&gt;在Spring Boot的入口类中，我们通常是通过调用&lt;code&gt;SpringApplication&lt;/code&gt;的run方法来启动Spring Boot项目。这节我们来深入学习下SpringApplication的一些细节。&lt;/p&gt;&lt;h2 id=&quot;自定义SpringApplication&quot;&gt;&lt;a href=&quot;#自定义SpringApplication&quot; class=&quot;headerlink&quot; title=&quot;自定义SpringApplication&quot;&gt;&lt;/a&gt;自定义SpringApplication&lt;/h2&gt;&lt;p&gt;默认的我们都是直接通过&lt;code&gt;SpringApplication&lt;/code&gt;的run方法来直接启动Spring Boot，其实我们可以通过一些API来调整某些行为。
    
    </summary>
    
    
      <category term="Spring" scheme="http://mrbird.cc/tags/Spring/"/>
    
      <category term="Spring Boot" scheme="http://mrbird.cc/tags/Spring-Boot/"/>
    
  </entry>
  
  <entry>
    <title>深入学习Spring Boot自动装配</title>
    <link href="http://mrbird.cc/deepin-springboot-autoconfig.html"/>
    <id>http://mrbird.cc/deepin-springboot-autoconfig.html</id>
    <published>2018-09-02T06:54:26.000Z</published>
    <updated>2019-03-13T10:50:56.148Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Apr 04 2019 14:23:36 GMT+0800 (GMT+08:00) --><h2 id="模式注解"><a href="#模式注解" class="headerlink" title="模式注解"></a>模式注解</h2><p>Stereotype Annotation俗称为模式注解，Spring中常见的模式注解有<code>@Service</code>，<code>@Repository</code>，<code>@Controller</code>等，它们都“派生”自<code>@Component</code>注解。我们都知道，凡是被<code>@Component</code>标注的类都会被Spring扫描并纳入到IOC容器中，那么由<code>@Component</code>派生的注解所标注的类也会被扫描到IOC容器中。下面我们主要来通过自定义模式注解来了解<code>@Component</code>的“派生性”和“层次性”。</p><a id="more"></a><h3 id="Component-“派生性”"><a href="#Component-“派生性”" class="headerlink" title="@Component “派生性”"></a>@Component “派生性”</h3><p>新建一个Spring Boot工程，Spring Boot版本为2.1.0.RELEASE，<code>artifactId</code>为autoconfig，并引入<code>spring-boot-starter-web</code>依赖。项目结构如下所示:</p><p><img src="img/QQ截图20190220151447.png" alt="QQ截图20190220151447.png"></p><p>在<code>com.example.demo</code>下新建<code>annotation</code>包，然后创建一个<code>FirstLevelService</code>注解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(&#123;ElementType.TYPE&#125;)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> FirstLevelService &#123;</span><br><span class="line">    <span class="function">String <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个注解定义由<code>@Service</code>标注，查看<code>@Service</code>的源码会发现其被<code>@Component</code>注解标注，所以它们的层次关系为:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">└─@Component</span><br><span class="line">   └─@Service</span><br><span class="line">      └─@FirstLevelService</span><br></pre></td></tr></table></figure><p></p><p>即<code>@FirstLevelService</code>为<code>@Component</code>派生出来的模式注解，我们来测试一下被它标注的类是否能够被扫描到IOC容器中：</p><p>在<code>com.example.demo</code>下新建<code>service</code>包，然后创建一个<code>TestService</code>类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SecondLevelService</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestService</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>在<code>com.example.demo</code>下新建<code>bootstrap</code>包，然后创建一个<code>ServiceBootStrap</code>类，用于测试注册<code>TestService</code>并从IOC容器中获取它：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ComponentScan</span>(<span class="string">"com.example.demo.service"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServiceBootstrap</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ConfigurableApplicationContext context = <span class="keyword">new</span> SpringApplicationBuilder(ServiceBootstrap.class)</span><br><span class="line">                .web(WebApplicationType.NONE)</span><br><span class="line">                .run(args);</span><br><span class="line">        TestService testService = context.getBean(<span class="string">"testService"</span>, TestService.class);</span><br><span class="line">        System.out.println(<span class="string">"TestService Bean: "</span> + testService);</span><br><span class="line">        context.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>运行该类的main方法，控制台输出如下：</p><p><img src="img/QQ截图20190220152939.png" alt="QQ截图20190220152939.png"></p><h3 id="Component-“层次性”"><a href="#Component-“层次性”" class="headerlink" title="@Component “层次性”"></a>@Component “层次性”</h3><p>我们在<code>com.example.demo.annotation</code>路径下再创建一个<code>SecondLevelService</code>注解定义，该注解由上面的<code>@FirstLevelService</code>标注：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(&#123;ElementType.TYPE&#125;)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@FirstLevelService</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> SecondLevelService &#123;</span><br><span class="line">    <span class="function">String <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>这时候层次关系为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">└─@Component</span><br><span class="line">   └─@Service</span><br><span class="line">      └─@FirstLevelService</span><br><span class="line">            └─@SecondLevelService</span><br></pre></td></tr></table></figure><p></p><p>我们将<code>TestService</code>上的注解换成<code>@SecondLevelService</code>，然后再次运行<code>ServiceBootStrap</code>的main方法，输出如下：</p><p><img src="img/QQ截图20190220152939.png" alt="QQ截图20190220152939.png"></p><p>可见结果也是成功的。</p><div class="note danger"><p>这里有一点需要注意的是：<code>@Component</code>注解只包含一个value属性定义，所以其“派生”的注解也只能包含一个vlaue属性定义。</p></div><h2 id="Enable模块驱动"><a href="#Enable模块驱动" class="headerlink" title="@Enable模块驱动"></a>@Enable模块驱动</h2><p><code>@Enable</code>模块驱动在Spring Framework 3.1后开始支持。这里的模块通俗的来说就是一些为了实现某个功能的组件的集合。通过<code>@Enable</code>模块驱动，我们可以开启相应的模块功能。</p><p><code>@Enable</code>模块驱动可以分为“注解驱动”和“接口编程”两种实现方式，下面逐一进行演示：</p><h3 id="注解驱动"><a href="#注解驱动" class="headerlink" title="注解驱动"></a>注解驱动</h3><p>Spring中，基于注解驱动的示例可以查看<code>@EnableWebMvc</code>源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Target</span>(&#123;ElementType.TYPE&#125;)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Import</span>(&#123;DelegatingWebMvcConfiguration.class&#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnableWebMvc &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>该注解通过<code>@Import</code>导入一个配置类<code>DelegatingWebMvcConfiguration</code>：</p><p><img src="img/QQ截图20190220170120.png" alt="QQ截图20190220170120.png"></p><p>该配置类又继承自<code>WebMvcConfigurationSupport</code>，里面定义了一些Bean的声明。</p><div class="note info"><p>所以，基于注解驱动的<code>@Enable</code>模块驱动其实就是通过<code>@Import</code>来导入一个配置类，以此实现相应模块的组件注册，当这些组件注册到IOC容器中，这个模块对应的功能也就可以使用了。</p></div><p>我们来定义一个基于注解驱动的<code>@Enable</code>模块驱动。</p><p>在<code>com.example.demo</code>下新建<code>configuration</code>包，然后创建一个<code>HelloWorldConfiguration</code>配置类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorldConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"hello world"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>这个配置类里定义了一个名为<code>hello</code>的Bean，内容为<code>hello world</code>。</p><p>在<code>com.example.demo.annotation</code>下创建一个<code>EnableHelloWorld</code>注解定义：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(&#123;ElementType.TYPE&#125;)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Import</span>(HelloWorldConfiguration.class)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnableHelloWorld &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>我们在该注解类上通过<code>@Import</code>导入了刚刚创建的配置类。</p><p>接着在<code>com.example.demo.bootstrap</code>下创建一个<code>TestEnableBootstap</code>启动类来测试<code>@EnableHelloWorld</code>注解是否生效：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableHelloWorld</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestEnableBootstap</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ConfigurableApplicationContext context = <span class="keyword">new</span> SpringApplicationBuilder(TestEnableBootstap.class)</span><br><span class="line">                .web(WebApplicationType.NONE)</span><br><span class="line">                .run(args);</span><br><span class="line">        String hello = context.getBean(<span class="string">"hello"</span>, String.class);</span><br><span class="line">        System.out.println(<span class="string">"hello Bean: "</span> + hello);</span><br><span class="line">        context.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>运行该类的main方法，控制台输出如下：</p><p><img src="img/QQ截图20190220171218.png" alt="QQ截图20190220171218.png"></p><p>说明我们自定义的基于注解驱动的<code>@EnableHelloWorld</code>是可行的。</p><h3 id="接口编程"><a href="#接口编程" class="headerlink" title="接口编程"></a>接口编程</h3><p>除了使用上面这个方式外，我们还可以通过接口编程的方式来实现<code>@Enable</code>模块驱动。Spring中，基于接口编程方式的有<code>@EnableCaching</code>注解，查看其源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(&#123;ElementType.TYPE&#125;)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Import</span>(&#123;CachingConfigurationSelector.class&#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnableCaching &#123;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">proxyTargetClass</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">false</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">AdviceMode <span class="title">mode</span><span class="params">()</span> <span class="keyword">default</span> AdviceMode.PROXY</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">order</span><span class="params">()</span> <span class="keyword">default</span> 2147483647</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>EnableCaching</code>注解通过<code>@Import</code>导入了<code>CachingConfigurationSelector</code>类，该类间接实现了<code>ImportSelector</code>接口，在 <a href="/Spring-Bean-Regist.html">深入学习Spring组件注册</a> 中，我们曾介绍了可以通过<code>ImportSelector</code>来实现组件注册。</p><div class="note info"><p>所以通过接口编程实现<code>@Enable</code>模块驱动的本质是：通过<code>@Import</code>来导入接口<code>ImportSelector</code>实现类，该实现类里可以定义需要注册到IOC容器中的组件，以此实现相应模块对应组件的注册。</p></div><p>接下来我们根据这个思路来自个实现一遍：</p><p>在<code>com.example.demo</code>下新建<code>selector</code>包，然后在该路径下新建一个<code>HelloWorldImportSelector</code>实现<code>ImportSelector</code>接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorldImportSelector</span> <span class="keyword">implements</span> <span class="title">ImportSelector</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String[] selectImports(AnnotationMetadata importingClassMetadata) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> String[]&#123;HelloWorldConfiguration.class.getName()&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>如果看不懂上面这段代码含义的朋友可以阅读<a href="/Spring-Bean-Regist.html">深入学习Spring组件注册</a>一文。</p><p>接着我们修改<code>EnableHelloWorld</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(&#123;ElementType.TYPE&#125;)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Import</span>(HelloWorldImportSelector.class)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnableHelloWorld &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>上面导入的是<code>HelloWorldImportSelector</code>，而非<code>HelloWorldConfiguration</code>。</p><p>再次运行<code>TestEnableBootstap</code>的main方法，你会发现输出是一样的。</p><h2 id="自动装配"><a href="#自动装配" class="headerlink" title="自动装配"></a>自动装配</h2><p>Spring Boot中的自动装配技术底层主要用到了下面这些技术:</p><ol><li><p>Spring 模式注解装配</p></li><li><p>Spring @Enable 模块装配</p></li><li><p>Spring 条件装配装（<a href="/Spring-Bean-Regist.html">深入学习Spring组件注册</a>中有介绍）</p></li><li><p>Spring 工厂加载机制</p></li></ol><p>Spring 工厂加载机制的实现类为<code>SpringFactoriesLoader</code>，查看其源码：</p><p><img src="img/QQ截图20190221110551.png" alt="QQ截图20190221110551.png"></p><p>该类的方法会读取META-INF目录下的spring.factories配置文件，我们查看spring-boot-autoconfigure-2.1.0.RELEASE.jar下的该文件：</p><p><img src="img/QQ截图20190221110753.png" alt="QQ截图20190221110753.png"></p><p><img src="img/QQ截图20190221110907.png" alt="QQ截图20190221110907.png"></p><p>当启动类被<code>@EnableAutoConfiguration</code>标注后，上面截图中的所有类Spring都会去扫描，看是否可以纳入到IOC容器中进行管理。</p><p>比如我们查看<code>org.springframework.boot.autoconfigure.data.redis.RedisAutoConfiguration</code>的源码：</p><p><img src="img/QQ截图20190221111400.png" alt="QQ截图20190221111400.png"></p><p>可看到该类上标注了一些注解，其中<code>@Configuration</code>为模式注解，<code>@EnableConfigurationProperties</code>为模块装配技术，<code>ConditionalOnClass</code>为条件装配技术。这和我们上面列出的Spring Boot自动装配底层主要技术一致，所以我们可以根据这个思路来自定义一个自动装配实现。</p><p>新建一个配置类<code>HelloWorldAutoConfiguration</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableHelloWorld</span></span><br><span class="line"><span class="meta">@ConditionalOnProperty</span>(name = <span class="string">"helloworld"</span>, havingValue = <span class="string">"true"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorldAutoConfiguration</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>然后在resources目录下新建META-INF目录，并创建spring.factories文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># Auto Configure</span><br><span class="line">org.springframework.boot.autoconfigure.EnableAutoConfiguration=\</span><br><span class="line">com.example.demo.configuration.HelloWorldAutoConfiguration</span><br></pre></td></tr></table></figure><p>接着在配置文件application.properties中添加<code>helloworld=true</code>配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">helloworld=true</span><br></pre></td></tr></table></figure><p></p><p>最后创建<code>EnableAutoConfigurationBootstrap</code>，测试下<code>HelloWorldAutoConfiguration</code>是否生效：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableAutoConfiguration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EnableAutoConfigurationBootstrap</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ConfigurableApplicationContext context = <span class="keyword">new</span> SpringApplicationBuilder(EnableAutoConfigurationBootstrap.class)</span><br><span class="line">                .web(WebApplicationType.NONE)</span><br><span class="line">                .run(args);</span><br><span class="line">        String hello = context.getBean(<span class="string">"hello"</span>, String.class);</span><br><span class="line">        System.out.println(<span class="string">"hello Bean: "</span> + hello);</span><br><span class="line">        context.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>运行该main方法，控制台输出如下：</p><p><img src="img/QQ截图20190221112922.png" alt="QQ截图20190221112922.png"></p><p>说明我们自定义的自动装配已经成功了。</p><p>下面简要分析下代码的运行逻辑：</p><ol><li><p>Spring 的工厂加载机制会自动读取META-INF目录下spring.factories文件内容；</p></li><li><p>我们在spring.factories定义了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">org.springframework.boot.autoconfigure.EnableAutoConfiguration=\</span><br><span class="line">com.example.demo.configuration.HelloWorldAutoConfiguration</span><br></pre></td></tr></table></figure><p>我们在测试类上使用了<code>@EnableAutoConfiguration</code>注解标注，那么<code>HelloWorldAutoConfiguration</code>就会被Spring扫描，看是否符合要求，如果符合则纳入到IOC容器中；</p></li><li><p><code>HelloWorldAutoConfiguration</code>上的<code>@ConditionalOnProperty</code>的注解作用为：当配置文件中配置了<code>helloworld=true</code>（我们确实添加了这个配置，所以符合要求）则这个类符合扫描规则；<code>@EnableHelloWorld</code>注解是我们前面例子中自定义的模块驱动注解，其引入了hello这个Bean，所以IOC容器中便会存在hello这个Bean了；</p></li><li><p>通过上面的步骤，我们就可以通过上下文获取到hello这个Bean了。</p></li></ol><blockquote><p>源码链接： <a href="https://github.com/wuyouzhuguli/SpringAll/tree/master/44.Spring-Boot-Autoconfiguration" target="_blank" rel="noopener">https://github.com/wuyouzhuguli/SpringAll/tree/master/44.Spring-Boot-Autoconfiguration</a></p></blockquote><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Thu Apr 04 2019 14:23:36 GMT+0800 (GMT+08:00) --&gt;&lt;h2 id=&quot;模式注解&quot;&gt;&lt;a href=&quot;#模式注解&quot; class=&quot;headerlink&quot; title=&quot;模式注解&quot;&gt;&lt;/a&gt;模式注解&lt;/h2&gt;&lt;p&gt;Stereotype Annotation俗称为模式注解，Spring中常见的模式注解有&lt;code&gt;@Service&lt;/code&gt;，&lt;code&gt;@Repository&lt;/code&gt;，&lt;code&gt;@Controller&lt;/code&gt;等，它们都“派生”自&lt;code&gt;@Component&lt;/code&gt;注解。我们都知道，凡是被&lt;code&gt;@Component&lt;/code&gt;标注的类都会被Spring扫描并纳入到IOC容器中，那么由&lt;code&gt;@Component&lt;/code&gt;派生的注解所标注的类也会被扫描到IOC容器中。下面我们主要来通过自定义模式注解来了解&lt;code&gt;@Component&lt;/code&gt;的“派生性”和“层次性”。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Spring" scheme="http://mrbird.cc/tags/Spring/"/>
    
      <category term="Spring Boot" scheme="http://mrbird.cc/tags/Spring-Boot/"/>
    
  </entry>
  
  <entry>
    <title>深入学习Spring Bean生命周期</title>
    <link href="http://mrbird.cc/Spring-Bean-Lifecycle.html"/>
    <id>http://mrbird.cc/Spring-Bean-Lifecycle.html</id>
    <published>2018-08-05T03:02:35.000Z</published>
    <updated>2019-03-13T10:51:44.159Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Apr 04 2019 14:23:35 GMT+0800 (GMT+08:00) --><p>所谓Spring Bean的生命周期指的是Bean从创建到初始化再到销毁的过程，这个过程由IOC容器管理。一个完整的Bean生命周期可以参考<a href="http://localhost:4001/Spring-Bean%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.html" target="_blank" rel="noopener">Spring Bean生命周期</a>。这里我们主要记录一些和Bean生命周期相关的细节。</p><h2 id="Bean的初始化和销毁"><a href="#Bean的初始化和销毁" class="headerlink" title="Bean的初始化和销毁"></a>Bean的初始化和销毁</h2><p>在整个生命周期过程中，我们可以自定义Bean的初始化和销毁钩子函数，当Bean的生命周期到达相应的阶段的时候，Spring会调用我们自定义的Bean的初始化和销毁方法。自定义Bean初始化和销毁方法有多种方式，下面逐一介绍。</p><a id="more"></a><h3 id="Bean"><a href="#Bean" class="headerlink" title="@Bean"></a>@Bean</h3><p>上一节中介绍了可以在配置类中通过<code>@Bean</code>注解来注册Bean，我们也可以通过它来指定Bean的初始化和方法。</p><p>为了演示，我们新建一个Spring Boot项目，然后创建一个<code>User</code>类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"调用无参构造器创建User"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"初始化User"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"销毁User"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>然后在配置类里注册该组件，并指定初始化和销毁方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span>(initMethod = <span class="string">"init"</span>, destroyMethod = <span class="string">"destory"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">user</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> User();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>其中<code>initMethod = &quot;init&quot;</code>和<code>destroyMethod = &quot;destory&quot;</code>与User类里的<code>init</code>，<code>destory</code>方法相对应。</p><p>在Spring Boot入口类中测试:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回 IOC 容器，使用注解配置，传入配置类</span></span><br><span class="line">AnnotationConfigApplicationContext context = <span class="keyword">new</span> AnnotationConfigApplicationContext(WebConfig.class);</span><br><span class="line">User user = context.getBean(User.class);</span><br><span class="line"><span class="comment">// 关闭 IOC 容器</span></span><br><span class="line">context.close();</span><br></pre></td></tr></table></figure><p></p><p>启动项目，观察控制台输出:</p><p><img src="img/QQ截图20190130142237.png" alt="QQ截图20190130142237.png"></p><p>从上面的输出我们看出在容器启动之前，先调用对象的无参构造器创建对象，然后调用初始化方法，在容器关闭的时候调用销毁方法。</p><p>上面的情况是对于单例而言的，如果组件是多例模式又是什么情况呢？我们把上面的组件注册配置改为多例，然后再次启动项目，观察控制台输出:</p><p><img src="img/QQ截图20190130142740.png" alt="QQ截图20190130142740.png"></p><p>控制台的输出和我们上节讨论的一致，即在多例模式下，IOC容器启动的时候并不会去创建对象，而是在每次获取的时候才会去调用方法创建对象，创建完对象后再调用初始化方法。但在容器关闭后，Spring并没有调用相应的销毁方法，这是因为在多例模式下，容器不会管理这个组件（只负责在你需要的时候创建这个组件），所以容器在关闭的时候并不会调用相应的销毁方法。</p><h3 id="InitializingBean-amp-DisposableBean"><a href="#InitializingBean-amp-DisposableBean" class="headerlink" title="InitializingBean&amp;DisposableBean"></a>InitializingBean&amp;DisposableBean</h3><p>除了上面这种方式指定初始化和销毁方法外，Spring还为我们提供了和初始化，销毁相对应的接口：</p><ul><li><p><code>InitializingBean</code>接口包含一个<code>afterPropertiesSet</code>方法，我们可以通过实现该接口，然后在这个方法中编写初始化逻辑。</p></li><li><p><code>DisposableBean</code>接口包含一个<code>destory</code>方法，我们可以通过实现该接口，然后再这个方法中编写销毁逻辑。</p></li></ul><p>新建一个类，名称为<code>Bird</code>，然后实现这两个接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Bird</span> <span class="keyword">implements</span> <span class="title">InitializingBean</span>, <span class="title">DisposableBean</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Bird</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"调用无参构造器创建Bird"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"销毁Bird"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterPropertiesSet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"初始化Bird"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在配置类中注册这个组件:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Bird <span class="title">bird</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Bird();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>测试一波：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">AnnotationConfigApplicationContext context = <span class="keyword">new</span> AnnotationConfigApplicationContext(WebConfig.class);</span><br><span class="line">System.out.println(<span class="string">"容器创建完毕"</span>);</span><br><span class="line">context.close();</span><br></pre></td></tr></table></figure><p></p><p>启动项目，观察控制台输出:</p><p><img src="img/QQ截图20190130145406.png" alt="QQ截图20190130145406.png"></p><h3 id="PostConstruct-amp-PreDestroy"><a href="#PostConstruct-amp-PreDestroy" class="headerlink" title="@PostConstruct&amp;@PreDestroy"></a>@PostConstruct&amp;@PreDestroy</h3><p>除了上面两种指定初始化和销毁方法的方式外，我们还可以使用<code>@PostConstruct</code>和<code>@PreDestroy</code>注解修饰方法来指定相应的初始化和销毁方法。</p><p>新建一个类，名称为Fish：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Fish</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Fish</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"调用无参构造器创建Fish"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"初始化Fish"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PreDestroy</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"销毁Fish"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>在配置类中注册这个组件:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Fish <span class="title">fish</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Fish();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>测试一波：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">AnnotationConfigApplicationContext context = <span class="keyword">new</span> AnnotationConfigApplicationContext(WebConfig.class);</span><br><span class="line">System.out.println(<span class="string">"容器创建完毕"</span>);</span><br><span class="line">context.close();</span><br></pre></td></tr></table></figure><p></p><p>启动项目，观察控制台输出:</p><p><img src="img/QQ截图20190130150534.png" alt="QQ截图20190130150534.png"></p><p>效果和上面两种方式一致。</p><div class="note info"><p>这两个注解并非Spring提供，而是JSR250规范提供。</p></div><h2 id="BeanPostProcessor"><a href="#BeanPostProcessor" class="headerlink" title="BeanPostProcessor"></a>BeanPostProcessor</h2><p>Spring提供了一个<code>BeanPostProcessor</code>接口，俗称<strong>Bean后置通知处理器</strong>，它提供了两个方法<code>postProcessBeforeInitialization</code>和<code>postProcessAfterInitialization</code>。其中<code>postProcessBeforeInitialization</code>在组件的初始化方法调用之前执行，<code>postProcessAfterInitialization</code>在组件的初始化方法调用之后执行。它们都包含两个入参：</p><ol><li><p>bean：当前组件对象；</p></li><li><p>beanName：当前组件在容器中的名称。</p></li></ol><p>两个方法都返回一个Object类型，我们可以直接返回当前组件对象，或者包装后返回。</p><p>我们来定义一个<code>BeanPostProcessor</code>接口的实现类<code>MyBeanPostProcessor</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBeanPostProcessor</span> <span class="keyword">implements</span> <span class="title">BeanPostProcessor</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">postProcessBeforeInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        System.out.println(beanName + <span class="string">" 初始化之前调用"</span>);</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">postProcessAfterInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        System.out.println(beanName + <span class="string">" 初始化之后调用"</span>);</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>在配置类中注册该组件:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> MyBeanPostProcessor <span class="title">myBeanPostProcessor</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> MyBeanPostProcessor();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>再次启动项目，观察控制台输出:</p><p><img src="img/QQ截图20190130153607.png" alt="QQ截图20190130153607.png"></p><p><img src="img/QQ截图20190130153450.png" alt="QQ截图20190130153450.png"></p><p>可以看到，BeanPostProcessor对IOC容器中所有组件都生效。</p><blockquote><p>源码链接：<a href="https://github.com/wuyouzhuguli/SpringAll/tree/master/51.Spring-Bean-Lifecycle" target="_blank" rel="noopener">https://github.com/wuyouzhuguli/SpringAll/tree/master/51.Spring-Bean-Lifecycle</a></p></blockquote><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Thu Apr 04 2019 14:23:35 GMT+0800 (GMT+08:00) --&gt;&lt;p&gt;所谓Spring Bean的生命周期指的是Bean从创建到初始化再到销毁的过程，这个过程由IOC容器管理。一个完整的Bean生命周期可以参考&lt;a href=&quot;http://localhost:4001/Spring-Bean%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Spring Bean生命周期&lt;/a&gt;。这里我们主要记录一些和Bean生命周期相关的细节。&lt;/p&gt;&lt;h2 id=&quot;Bean的初始化和销毁&quot;&gt;&lt;a href=&quot;#Bean的初始化和销毁&quot; class=&quot;headerlink&quot; title=&quot;Bean的初始化和销毁&quot;&gt;&lt;/a&gt;Bean的初始化和销毁&lt;/h2&gt;&lt;p&gt;在整个生命周期过程中，我们可以自定义Bean的初始化和销毁钩子函数，当Bean的生命周期到达相应的阶段的时候，Spring会调用我们自定义的Bean的初始化和销毁方法。自定义Bean初始化和销毁方法有多种方式，下面逐一介绍。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Spring" scheme="http://mrbird.cc/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>深入学习Spring组件注册</title>
    <link href="http://mrbird.cc/Spring-Bean-Regist.html"/>
    <id>http://mrbird.cc/Spring-Bean-Regist.html</id>
    <published>2018-08-01T06:36:09.000Z</published>
    <updated>2019-03-13T10:51:24.357Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Apr 04 2019 14:23:37 GMT+0800 (GMT+08:00) --><p>接触过Spring的同学肯定都听过IOC。在传统的Java编程中，当需要用到某个对象的时候，我们都是主动地显示创建一个对象实例（new）。使用Spring后就不需要这样做了，因为Spring会帮我们在需要用到某些对象的地方自动注入该对象，而无须我们自己去创建。这种模式俗称控制反转，即IOC（Inversion of Control）。那么Spring是从什么地方获取到我们所需要的对象呢？其实Spring给我们提供了一个IOC容器，里面管理着所有我们需要的对象，组件注册就是我们去告诉Spring哪些类需要交给IOC容器管理。</p><p>这里主要记录组件注册的一些细节。<a id="more"></a></p><h2 id="通过-Bean注册组件"><a href="#通过-Bean注册组件" class="headerlink" title="通过@Bean注册组件"></a>通过@Bean注册组件</h2><p>在较早版本的Spring中，我们都是通过XML的方式来往IOC容器中注册组件的，下面这段代码大家肯定不会陌生：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回 IOC 容器，基于 XML配置，传入配置文件的位置</span></span><br><span class="line">ApplicationContext applicationContext = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"xxx.xml"</span>);</span><br><span class="line">User user = (User) applicationContext.getBean(<span class="string">"user"</span>);</span><br></pre></td></tr></table></figure><p></p><p>Spring 4后推荐我们使用Java Config的方式来注册组件。</p><p>为了演示，我们通过<a href="http://start.spring.io/" target="_blank" rel="noopener">http://start.spring.io/</a>搭建一个简单Spring Boot应用，然后引入Lombok依赖（编辑器也需要安装Lombok插件）：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p></p><p>然后创建一个User类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ToString</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>接着创建一个配置类，在里面通过<code>@Bean</code>注解注册User类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span>()</span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">user</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> User(<span class="string">"mrbird"</span>, <span class="number">18</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>通过<code>@Bean</code>注解，我们向IOC容器注册了一个名称为<code>user</code>（Bean名称默认为方法名，我们也可以通过<code>@Bean(&quot;myUser&quot;)</code>方式来将组件名称指定为<code>myUser</code>）。</p><p>组件注册完毕后，我们测试一下从IOC容器中获取这个组件。在Spring Boot入口类中编写如下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoApplication</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    	SpringApplication.run(DemoApplication.class, args);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 返回 IOC 容器，使用注解配置，传入配置类</span></span><br><span class="line">        ApplicationContext context = <span class="keyword">new</span> AnnotationConfigApplicationContext(WebConfig.class);</span><br><span class="line">        User user = context.getBean(User.class);</span><br><span class="line">        System.out.println(user);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>因为我们是通过注解方式来注册组件的，所以需要使用<code>AnnotationConfigApplicationContext</code>来获取相应的IOC容器，入参为配置类。</p><p>启动项目，看下控制台输出：</p><p><img src="img/QQ截图20181207155127.png" alt="QQ截图20181207155127.png"></p><p>说明组件注册成功。</p><p>我们将组件的名称改为<code>myUser</code>，然后看看IOC容器中，User类型组件是否叫<code>myUser</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoApplication</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(DemoApplication.class, args);</span><br><span class="line"></span><br><span class="line">        ApplicationContext context = <span class="keyword">new</span> AnnotationConfigApplicationContext(WebConfig.class);</span><br><span class="line">        <span class="comment">// 查看 User 这个类在 Spring 容器中叫啥玩意</span></span><br><span class="line">        String[] beanNames = context.getBeanNamesForType(User.class);</span><br><span class="line">        Arrays.stream(beanNames).forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>启动项目，观察控制台输出:</p><p><img src="img/QQ截图20181207155718.png" alt="QQ截图20181207155718.png"></p><h2 id="使用-ComponentScan扫描"><a href="#使用-ComponentScan扫描" class="headerlink" title="使用@ComponentScan扫描"></a>使用@ComponentScan扫描</h2><p>在使用XML配置组件扫描的时候，我们都是这样配置的：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">""</span>&gt;</span><span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br></pre></td></tr></table></figure><p></p><p>其中<code>base-package</code>指定了扫描的路径。路径下所有被<code>@Controller</code>、<code>@Service</code>、<code>@Repository</code>和<code>@Component</code>注解标注的类都会被纳入IOC容器中。</p><p>现在我们脱离XML配置后，可以使用<code>@ComponentScan</code>注解来扫描组件并注册。</p><p>在使用<code>@ComponentScan</code>扫描之前，我们先创建一个Controller，一个Service，一个Dao，并标注上相应的注解。</p><p>然后修改配置类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan</span>(<span class="string">"cc.mrbird.demo"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// @Bean("myUser")</span></span><br><span class="line">    <span class="comment">// public User user() &#123;</span></span><br><span class="line">    <span class="comment">//     return new User("mrbird", 18);</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>在配置类中，我们通过<code>@ComponentScan(&quot;cc.mrbird.demo&quot;)</code>配置了扫描路径，并且将User组件注册注释掉了，取而代之的是在User类上加上<code>@Component</code>注解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ToString</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><div class="note danger"><p>值得注意的是，我们不能将Spring Boot的入口类纳入扫描范围中，否则项目启动将出错。</p></div><p>接下来我们看下在基于注解的IOC容器中是否包含了这些组件：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoApplication</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(DemoApplication.class, args);</span><br><span class="line"></span><br><span class="line">        ApplicationContext context = <span class="keyword">new</span> AnnotationConfigApplicationContext(WebConfig.class);</span><br><span class="line">        <span class="comment">// 查看基于注解的 IOC容器中所有组件名称</span></span><br><span class="line">        String[] beanNames = context.getBeanDefinitionNames();</span><br><span class="line">        Arrays.stream(beanNames).forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>启动项目，观察控制台：</p><p><img src="img/QQ截图20181207164418.png" alt="QQ截图20181207164418.png"></p><p>可见，组件已经成功被扫描进去了，并且名称默认为类名首字母小写。</p><p>这里，配置类WebConfig也被扫描并注册了，查看<code>@Configuration</code>源码就会发现原因：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(ElementType.TYPE)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Configuration &#123;</span><br><span class="line">    <span class="function">String <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h3 id="指定扫描策略"><a href="#指定扫描策略" class="headerlink" title="指定扫描策略"></a>指定扫描策略</h3><p><code>@ComponentScan</code>注解允许我们指定扫描策略，即指定哪些被扫描，哪些不被扫描，查看其源码可发现这两个属性：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Specifies which types are eligible for component scanning.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Further narrows the set of candidate components from everything in &#123;<span class="doctag">@link</span> #basePackages&#125;</span></span><br><span class="line"><span class="comment"> * to everything in the base packages that matches the given filter or filters.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Note that these filters will be applied in addition to the default filters, if specified.</span></span><br><span class="line"><span class="comment"> * Any type under the specified base packages which matches a given filter will be included,</span></span><br><span class="line"><span class="comment"> * even if it does not match the default filters (i.e. is not annotated with &#123;<span class="doctag">@code</span> <span class="doctag">@Component</span>&#125;).</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #resourcePattern()</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #useDefaultFilters()</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">Filter[] includeFilters() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Specifies which types are not eligible for component scanning.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #resourcePattern</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">Filter[] excludeFilters() <span class="keyword">default</span> &#123;&#125;;</span><br></pre></td></tr></table></figure><p></p><p>其中<code>Filter</code>也是一个注解:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Declares the type filter to be used as an &#123;<span class="doctag">@linkplain</span> ComponentScan#includeFilters</span></span><br><span class="line"><span class="comment"> * include filter&#125; or &#123;<span class="doctag">@linkplain</span> ComponentScan#excludeFilters exclude filter&#125;.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Target</span>(&#123;&#125;)</span><br><span class="line"><span class="meta">@interface</span> Filter &#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">FilterType <span class="title">type</span><span class="params">()</span> <span class="keyword">default</span> FilterType.ANNOTATION</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@AliasFor</span>(<span class="string">"classes"</span>)</span><br><span class="line">    Class&lt;?&gt;[] value() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@AliasFor</span>(<span class="string">"value"</span>)</span><br><span class="line">    Class&lt;?&gt;[] classes() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">    String[] pattern() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>接下来我们使用<code>excludeFilters</code>来排除一些组件的扫描：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan</span>(value = <span class="string">"cc.mrbird.demo"</span>,</span><br><span class="line">        excludeFilters = &#123;</span><br><span class="line">                <span class="meta">@Filter</span>(type = FilterType.ANNOTATION,</span><br><span class="line">                        classes = &#123;Controller.class, Repository.class&#125;),</span><br><span class="line">                <span class="meta">@Filter</span>(type = FilterType.ASSIGNABLE_TYPE, classes = User.class)</span><br><span class="line">        &#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>上面我们指定了两种排除扫描的规则：</p><ol><li><p>根据注解来排除（<code>type = FilterType.ANNOTATION</code>）,这些注解的类型为<code>classes = {Controller.class, Repository.class}</code>。即<code>Controller</code>和<code>Repository</code>注解标注的类不再被纳入到IOC容器中。</p></li><li><p>根据指定类型类排除（<code>type = FilterType.ASSIGNABLE_TYPE</code>），排除类型为<code>User.class</code>，其子类，实现类都会被排除。</p></li></ol><p>启动项目，观察控制台：</p><p><img src="img/QQ截图20190129103606.png" alt="QQ截图20190129095439.png"></p><p>可见排除成功。</p><p>除了上面两种常用的规则外，我们还可以使用别的规则，查看<code>FilterType</code>源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> FilterType &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Filter candidates marked with a given annotation.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> org.springframework.core.type.filter.AnnotationTypeFilter</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    ANNOTATION,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Filter candidates assignable to a given type.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> org.springframework.core.type.filter.AssignableTypeFilter</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    ASSIGNABLE_TYPE,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Filter candidates matching a given AspectJ type pattern expression.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> org.springframework.core.type.filter.AspectJTypeFilter</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    ASPECTJ,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Filter candidates matching a given regex pattern.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> org.springframework.core.type.filter.RegexPatternTypeFilter</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    REGEX,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Filter candidates using a given custom</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@link</span> org.springframework.core.type.filter.TypeFilter&#125; implementation.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    CUSTOM</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>可看到，我们还可以通过<code>ASPECTJ</code>表达式，<code>REGEX</code>正则表达式和<code>CUSTOM</code>自定义规则（下面详细介绍）来指定扫描策略。</p><p><code>includeFilters</code>的作用和<code>excludeFilters</code>相反，其指定的是哪些组件需要被扫描：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan</span>(value = <span class="string">"cc.mrbird.demo"</span>,</span><br><span class="line">        includeFilters = &#123;</span><br><span class="line">                <span class="meta">@Filter</span>(type = FilterType.ANNOTATION, classes = Service.class)</span><br><span class="line">        &#125;, useDefaultFilters = <span class="keyword">false</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>上面配置了只将<code>Controller</code>纳入IOC容器，并且需要用<code>useDefaultFilters = false</code>来关闭Spring默认的扫描策略才能让我们的配置生效（Spring Boot入口类的<code>@SpringBootApplication</code>注解包含了一些默认的扫描策略）。</p><p>启动项目，观察控制台：</p><p><img src="img/QQ截图20190129100306.png" alt="QQ截图20190129100306.png"></p><p>可看到，IOC容器中将不再包含dao，service。</p><h3 id="多扫描策略配置"><a href="#多扫描策略配置" class="headerlink" title="多扫描策略配置"></a>多扫描策略配置</h3><p>在Java 8之前，我们可以使用<code>@ComponentScans</code>来配置多个<code>@ComponentScan</code>以实现多扫描规则配置：</p><p><img src="img/QQ截图20190129100809.png" alt="QQ截图20190129100809.png"></p><p>而在Java 8中，新增了<code>@Repeatable</code>注解，使用该注解修饰的注解可以重复使用，查看<code>@ComponentScan</code>源码会发现其已经被该注解标注：</p><p><img src="img/QQ截图20190129101050.png" alt="QQ截图20190129101050.png"></p><p>所以除了使用<code>@ComponentScans</code>来配置多扫描规则外，我们还可以通过多次使用<code>@ComponentScan</code>来指定多个不同的扫描规则。</p><h3 id="自定义扫描策略"><a href="#自定义扫描策略" class="headerlink" title="自定义扫描策略"></a>自定义扫描策略</h3><p>自定义扫描策略需要我们实现<code>org.springframework.core.type.filter.TypeFilter</code>接口，创建<code>MyTypeFilter</code>实现该接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTypeFilter</span> <span class="keyword">implements</span> <span class="title">TypeFilter</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">match</span><span class="params">(MetadataReader metadataReader, MetadataReaderFactory metadataReaderFactory)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>该接口包含<code>match</code>方法，其两个入参<code>MetadataReader</code>和<code>MetadataReaderFactory</code>含义如下：</p><ol><li><p><code>MetadataReader</code>：当前正在扫描的类的信息；</p></li><li><p><code>MetadataReaderFactory</code>：可以通过它来获取其他类的信息。</p></li></ol><p>当<code>match</code>方法返回true时说明匹配成功，false则说明匹配失败。继续完善这个过滤规则：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTypeFilter</span> <span class="keyword">implements</span> <span class="title">TypeFilter</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">match</span><span class="params">(MetadataReader metadataReader, MetadataReaderFactory metadataReaderFactory)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 获取当前正在扫描的类的注解信息</span></span><br><span class="line">        AnnotationMetadata annotationMetadata = metadataReader.getAnnotationMetadata();</span><br><span class="line">        <span class="comment">// 获取当前正在扫描的类的类信息</span></span><br><span class="line">        ClassMetadata classMetadata = metadataReader.getClassMetadata();</span><br><span class="line">        <span class="comment">// 获取当前正在扫描的类的路径等信息</span></span><br><span class="line">        Resource resource = metadataReader.getResource();</span><br><span class="line"></span><br><span class="line">        String className = classMetadata.getClassName();</span><br><span class="line">        <span class="keyword">return</span> StringUtils.hasText(<span class="string">"er"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>上面指定了当被扫描的类名包含<code>er</code>时候，匹配成功，配合<code>excludeFilters</code>使用意指当被扫描的类名包含<code>er</code>时，该类不被纳入IOC容器中。</p><p>我们在<code>@ComponentScan</code>中使用这个自定义的过滤策略：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan</span>(value = <span class="string">"cc.mrbird.demo"</span>,</span><br><span class="line">        excludeFilters = &#123;</span><br><span class="line">            <span class="meta">@Filter</span>(type = FilterType.CUSTOM, classes = MyTypeFilter.class)</span><br><span class="line">        &#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebConfig</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>启动项目，观察输出： <img src="img/QQ截图20190129112811.png" alt="QQ截图20190129112811.png"></p><p>因为<code>User</code>，<code>UserMapper</code>，<code>UserService</code>和<code>UserController</code>等类的类名都包含<code>er</code>，所以它们都没有被纳入到IOC容器中。</p><h2 id="组件作用域-Scope"><a href="#组件作用域-Scope" class="headerlink" title="组件作用域@Scope"></a>组件作用域@Scope</h2><p>默认情况下，在Spring的IOC容器中每个组件都是单例的，即无论在任何地方注入多少次，这些对象都是同一个，我们来看下例子。</p><p>首先将User对象中的<code>@Component</code>注解去除，然后在配置类中配置User Bean：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">user</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> User(<span class="string">"mrbird"</span>, <span class="number">18</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>接着多次从IOC容器中获取这个组件，看看是否为同一个：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回 IOC 容器，使用注解配置，传入配置类</span></span><br><span class="line">ApplicationContext context = <span class="keyword">new</span> AnnotationConfigApplicationContext(WebConfig.class);</span><br><span class="line">Object user1 = context.getBean(<span class="string">"user"</span>);</span><br><span class="line">Object user2 = context.getBean(<span class="string">"user"</span>);</span><br><span class="line">System.out.println(user1 == user2);</span><br></pre></td></tr></table></figure><p></p><p>启动项目，观察控制台输出:</p><p><img src="img/QQ截图20190129135637.png" alt="QQ截图20190129135637.png"></p><p>结果证实了上面的观点。</p><p>在Spring中我们可以使用<code>@Scope</code>注解来改变组件的作用域：</p><p><img src="img/QQ截图20190129140150.png" alt="QQ截图20190129140150.png"></p><ol><li><p><code>singleton</code>：单实例（默认）,在Spring IOC容器启动的时候会调用方法创建对象然后纳入到IOC容器中，以后每次获取都是直接从IOC容器中获取（<code>map.get()</code>）；</p></li><li><p><code>prototype</code>：多实例，IOC容器启动的时候并不会去创建对象，而是在每次获取的时候才会去调用方法创建对象；</p></li><li><p><code>request</code>：一个请求对应一个实例；</p></li><li><p><code>session</code>：同一个session对应一个实例。</p></li></ol><h2 id="懒加载-Lazy"><a href="#懒加载-Lazy" class="headerlink" title="懒加载@Lazy"></a>懒加载@Lazy</h2><p>懒加载是针对单例模式而言的，正如前面所说，IOC容器中的组件默认是单例的，容器启动的时候会调用方法创建对象然后纳入到IOC容器中。</p><p>在User Bean注册的地方加入一句话以观察：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">user</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"往IOC容器中注册user bean"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> User(<span class="string">"mrbird"</span>, <span class="number">18</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>测试：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ApplicationContext context = <span class="keyword">new</span> AnnotationConfigApplicationContext(WebConfig.class);</span><br><span class="line">System.out.println(<span class="string">"容器创建完毕"</span>);</span><br></pre></td></tr></table></figure><p></p><p>启动项目观察控制台输出:</p><p><img src="img/QQ截图20190129144509.png" alt="QQ截图20190129144509.png"></p><p>可以看到，在IOC容器创建完毕之前，组件已经添加到容器中了。</p><p>将User Bean改为懒加载的方式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@Lazy</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">user</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"往IOC容器中注册user bean"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> User(<span class="string">"mrbird"</span>, <span class="number">18</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>再次启动项目，观察输出：</p><p><img src="img/QQ截图20190129144804.png" alt="QQ截图20190129144804.png"></p><p>可看到，容器创建完的时候，User Bean这个组件并未添加到容器中。</p><div class="note info"><p>所以懒加载的功能是，在单例模式中，IOC容器创建的时候不会马上去调用方法创建对象并注册，只有当组件<strong>第一次</strong>被使用的时候才会调用方法创建对象并加入到容器中。</p></div><p>测试一下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ApplicationContext context = <span class="keyword">new</span> AnnotationConfigApplicationContext(WebConfig.class);</span><br><span class="line">System.out.println(<span class="string">"容器创建完毕"</span>);</span><br><span class="line">Object user1 = context.getBean(<span class="string">"user"</span>);</span><br><span class="line">Object user2 = context.getBean(<span class="string">"user"</span>);</span><br></pre></td></tr></table></figure><p></p><p>启动项目，观察输出:</p><p><img src="img/QQ截图20190129145157.png" alt="QQ截图20190129145157.png"></p><p>结果证实了我们的观点。</p><h2 id="条件注册组件"><a href="#条件注册组件" class="headerlink" title="条件注册组件"></a>条件注册组件</h2><h3 id="Conditional"><a href="#Conditional" class="headerlink" title="@Conditional"></a>@Conditional</h3><p>使用<code>@Conditional</code>注解我们可以指定组件注册的条件，即满足特定条件才将组件纳入到IOC容器中。</p><p>在使用该注解之前，我们需要创建一个类，实现<code>Condition</code>接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyCondition</span> <span class="keyword">implements</span> <span class="title">Condition</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">matches</span><span class="params">(ConditionContext context, AnnotatedTypeMetadata metadata)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>该接口包含一个<code>matches</code>方法，包含两个入参:</p><ol><li><p><code>ConditionContext</code>：上下文信息；</p></li><li><p><code>AnnotatedTypeMetadata</code>：注解信息。</p></li></ol><p>简单完善一下这个实现类:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyCondition</span> <span class="keyword">implements</span> <span class="title">Condition</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">matches</span><span class="params">(ConditionContext context, AnnotatedTypeMetadata metadata)</span> </span>&#123;</span><br><span class="line">        String osName = context.getEnvironment().getProperty(<span class="string">"os.name"</span>);</span><br><span class="line">        <span class="keyword">return</span> osName != <span class="keyword">null</span> &amp;&amp; osName.contains(<span class="string">"Windows"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>接着将这个条件添加到User Bean注册的地方：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@Conditional</span>(MyCondition.class)</span><br><span class="line"><span class="function"><span class="keyword">public</span> User <span class="title">user</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> User(<span class="string">"mrbird"</span>, <span class="number">18</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>在Windows环境下，User这个组件将被成功注册，如果是别的操作系统，这个组件将不会被注册到IOC容器中。</p><h3 id="Profile"><a href="#Profile" class="headerlink" title="@Profile"></a>@Profile</h3><p><code>@Profile</code>可以根据不同的环境变量来注册不同的组件，下面我们来学一下它的用法。</p><p>新建一个接口<code>CalculateService</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CalculateService</span> </span>&#123;</span><br><span class="line">    <span class="function">Integer <span class="title">sum</span><span class="params">(Integer... value)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>接着添加两个实现<code>Java7CalculateServiceImpl</code>和<code>Java8CalculateServiceImpl</code>:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@Profile</span>(<span class="string">"java7"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Java7CalculateServiceImpl</span> <span class="keyword">implements</span> <span class="title">CalculateService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">sum</span><span class="params">(Integer... value)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Java 7环境下执行"</span>);</span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= value.length; i++) &#123;</span><br><span class="line">            result += i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@Profile</span>(<span class="string">"java8"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Java8CalculateServiceImpl</span> <span class="keyword">implements</span> <span class="title">CalculateService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">sum</span><span class="params">(Integer... value)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Java 8环境下执行"</span>);</span><br><span class="line">        <span class="keyword">return</span> Arrays.stream(value).reduce(<span class="number">0</span>, Integer::sum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过<code>@Profile</code>注解我们实现了：当环境变量包含<code>java7</code>的时候，<code>Java7CalculateServiceImpl</code>将会被注册到IOC容器中；当环境变量包含<code>java8</code>的时候，<code>Java8CalculateServiceImpl</code>将会被注册到IOC容器中。</p><p>测试一下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ConfigurableApplicationContext context1 = <span class="keyword">new</span> SpringApplicationBuilder(DemoApplication.class)</span><br><span class="line">                .web(WebApplicationType.NONE)</span><br><span class="line">                .profiles(<span class="string">"java8"</span>)</span><br><span class="line">                .run(args);</span><br><span class="line"></span><br><span class="line">CalculateService service = context1.getBean(CalculateService.class);</span><br><span class="line">System.out.println(<span class="string">"求合结果： "</span> + service.sum(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>));</span><br></pre></td></tr></table></figure><p></p><p>启动项目，控制台输出如下：</p><p><img src="img/QQ截图20190221094636.png" alt="QQ截图20190221094636.png"></p><p><img src="img/QQ截图20190221094658.png" alt="QQ截图20190221094658.png"></p><p>如果将<code>.profiles(&quot;java8&quot;)</code>改为<code>.profiles(&quot;java7&quot;)</code>的话，控制台输出如下：</p><p><img src="img/QQ截图20190221094849.png" alt="QQ截图20190221094849.png"></p><p><img src="img/QQ截图20190221094910.png" alt="QQ截图20190221094910.png"></p><h2 id="导入组件"><a href="#导入组件" class="headerlink" title="导入组件"></a>导入组件</h2><h3 id="Import"><a href="#Import" class="headerlink" title="@Import"></a>@Import</h3><p>到目前为止，我们可以使用包扫描和<code>@Bean</code>来实现组件注册。除此之外，我们还可以使用<code>@Import</code>来快速地往IOC容器中添加组件。</p><p>创建一个新的类<code>Hello</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hello</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>然后在配置类中导入这个组件：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@Import</span>(&#123;Hello.class&#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebConfig</span> </span>&#123;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>查看IOC容器中所有组件的名称：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ApplicationContext context = <span class="keyword">new</span> AnnotationConfigApplicationContext(WebConfig.class);</span><br><span class="line">String[] beanNames = context.getBeanDefinitionNames();</span><br><span class="line">Arrays.stream(beanNames).forEach(System.out::println);</span><br></pre></td></tr></table></figure><p></p><p>启动项目，控制台输出:</p><p><img src="img/QQ截图20190129185401.png" alt="QQ截图20190129185401.png"></p><p>可看到，通过<code>@Import</code>我们可以快速地往IOC容器中添加组件，Id默认为全类名。</p><h3 id="ImportSelector"><a href="#ImportSelector" class="headerlink" title="ImportSelector"></a>ImportSelector</h3><p>通过<code>@Import</code>我们已经实现了组件的导入，如果需要一次性导入较多组件，我们可以使用<code>ImportSelector</code>来实现。</p><p>新增三个类<code>Apple</code>，<code>Banana</code>和<code>Watermelon</code>，代码略。</p><p>查看<code>ImportSelector</code>源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ImportSelector</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Select and return the names of which class(es) should be imported based on</span></span><br><span class="line"><span class="comment">     * the &#123;<span class="doctag">@link</span> AnnotationMetadata&#125; of the importing @&#123;<span class="doctag">@link</span> Configuration&#125; class.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">     String[] selectImports(AnnotationMetadata importingClassMetadata);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p><code>ImportSelector</code>是一个接口，包含一个<code>selectImports</code>方法，方法返回类的全类名数组（即需要导入到IOC容器中组件的全类名数组），包含一个<code>AnnotationMetadata</code>类型入参，通过这个参数我们可以获取到使用<code>ImportSelector</code>的类的全部注解信息。</p><p>我们新建一个<code>ImportSelector</code>实现类<code>MyImportSelector</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyImportSelector</span> <span class="keyword">implements</span> <span class="title">ImportSelector</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String[] selectImports(AnnotationMetadata importingClassMetadata) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> String[]&#123;</span><br><span class="line">                <span class="string">"cc.mrbird.demo.domain.Apple"</span>,</span><br><span class="line">                <span class="string">"cc.mrbird.demo.domain.Banana"</span>,</span><br><span class="line">                <span class="string">"cc.mrbird.demo.domain.Watermelon"</span></span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>上面方法返回了新增的三个类的全类名数组，接着我们在配置类的<code>@Import</code>注解上使用<code>MyImportSelector</code>来把这三个组件快速地导入到IOC容器中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Import</span>(&#123;MyImportSelector.class&#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebConfig</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>查看容器中是否已经有这三个组件:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ApplicationContext context = <span class="keyword">new</span> AnnotationConfigApplicationContext(WebConfig.class);</span><br><span class="line">String[] beanNames = context.getBeanDefinitionNames();</span><br><span class="line">Arrays.stream(beanNames).forEach(System.out::println);</span><br></pre></td></tr></table></figure><p></p><p>启动项目，观察控制台：</p><p><img src="img/QQ截图20190130091140.png" alt="QQ截图20190130091140.png"></p><p>组件已经成功导入。</p><h3 id="ImportBeanDefinitionRegistrar"><a href="#ImportBeanDefinitionRegistrar" class="headerlink" title="ImportBeanDefinitionRegistrar"></a>ImportBeanDefinitionRegistrar</h3><p>除了上面两种往IOC容器导入组件的方法外，我们还可以使用<code>ImportBeanDefinitionRegistrar</code>来手动往IOC容器导入组件。</p><p>查看其源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ImportBeanDefinitionRegistrar</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerBeanDefinitions</span><span class="params">(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p><code>ImportBeanDefinitionRegistrar</code>是一个接口，包含一个<code>registerBeanDefinitions</code>方法，该方法包含两个入参：</p><ol><li><p><code>AnnotationMetadata</code>：可以通过它获取到类的注解信息；</p></li><li><p><code>BeanDefinitionRegistry</code>：Bean定义注册器，包含了一些和Bean有关的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BeanDefinitionRegistry</span> <span class="keyword">extends</span> <span class="title">AliasRegistry</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">registerBeanDefinition</span><span class="params">(String var1, BeanDefinition var2)</span> <span class="keyword">throws</span> BeanDefinitionStoreException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">removeBeanDefinition</span><span class="params">(String var1)</span> <span class="keyword">throws</span> NoSuchBeanDefinitionException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">BeanDefinition <span class="title">getBeanDefinition</span><span class="params">(String var1)</span> <span class="keyword">throws</span> NoSuchBeanDefinitionException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">containsBeanDefinition</span><span class="params">(String var1)</span></span>;</span><br><span class="line"></span><br><span class="line">    String[] getBeanDefinitionNames();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getBeanDefinitionCount</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isBeanNameInUse</span><span class="params">(String var1)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>这里我们需要借助<code>BeanDefinitionRegistry</code>的<code>registerBeanDefinition</code>方法来往IOC容器中注册Bean。该方法包含两个入参，第一个为需要注册的Bean名称（Id）,第二个参数为Bean的定义信息，它是一个接口，我们可以使用其实现类<code>RootBeanDefinition</code>来完成：</p><p><img src="img/QQ截图20190130094046.png" alt="QQ截图20190130094046.png"></p><p>为了演示<code>ImportBeanDefinitionRegistrar</code>的使用，我们先新增一个类，名称为<code>Strawberry</code>，代码略。</p><p>然后新增一个<code>ImportBeanDefinitionRegistrar</code>实现类<code>MyImportBeanDefinitionRegistrar</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyImportBeanDefinitionRegistrar</span> <span class="keyword">implements</span> <span class="title">ImportBeanDefinitionRegistrar</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerBeanDefinitions</span><span class="params">(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> String beanName = <span class="string">"strawberry"</span>;</span><br><span class="line">        <span class="keyword">boolean</span> contain = registry.containsBeanDefinition(beanName);</span><br><span class="line">        <span class="keyword">if</span> (!contain) &#123;</span><br><span class="line">            RootBeanDefinition rootBeanDefinition = <span class="keyword">new</span> RootBeanDefinition(Strawberry.class);</span><br><span class="line">            registry.registerBeanDefinition(beanName, rootBeanDefinition);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>在上面的实现类中，我们先通过<code>BeanDefinitionRegistry</code>的<code>containsBeanDefinition</code>方法判断IOC容器中是否包含了名称为<code>strawberry</code>的组件，如果没有，则手动通过<code>BeanDefinitionRegistry</code>的<code>registerBeanDefinition</code>方法注册一个。</p><p>定义好<code>MyImportBeanDefinitionRegistrar</code>后，我们同样地在配置类的<code>@Import</code>中使用它：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@Import</span>(&#123;MyImportBeanDefinitionRegistrar.class&#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebConfig</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>查看容器中是否已经有这个组件:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ApplicationContext context = <span class="keyword">new</span> AnnotationConfigApplicationContext(WebConfig.class);</span><br><span class="line">String[] beanNames = context.getBeanDefinitionNames();</span><br><span class="line">Arrays.stream(beanNames).forEach(System.out::println);</span><br></pre></td></tr></table></figure><p></p><p>启动项目，观察控制台：</p><p><img src="img/QQ截图20190130094912.png" alt="QQ截图20190130094912.png"></p><p>组件已经注册成功。</p><h2 id="使用FactoryBean注册组件"><a href="#使用FactoryBean注册组件" class="headerlink" title="使用FactoryBean注册组件"></a>使用FactoryBean注册组件</h2><p>Spring还提供了一个<code>FactoryBean</code>接口，我们可以通过实现该接口来注册组件，该接口包含了两个抽象方法和一个默认方法：</p><p><img src="img/QQ截图20190130103346.png" alt="QQ截图20190130103346.png"></p><p>为了演示<code>FactoryBean</code>的使用，我们新增一个<code>Cherry</code>类，代码略。</p><p>然后创建<code>FactoryBean</code>的实现类<code>CherryFactoryBean</code>:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CherryFactoryBean</span> <span class="keyword">implements</span> <span class="title">FactoryBean</span>&lt;<span class="title">Cherry</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Cherry <span class="title">getObject</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Cherry();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Class&lt;?&gt; getObjectType() &#123;</span><br><span class="line">        <span class="keyword">return</span> Cherry.class;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSingleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>getObject</code>返回需要注册的组件对象，<code>getObjectType</code>返回需要注册的组件类型，<code>isSingleton</code>指明该组件是否为单例。如果为多例的话，每次从容器中获取该组件都会调用其<code>getObject</code>方法。</p><p>定义好<code>CherryFactoryBean</code>后，我们在配置类中注册这个类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> CherryFactoryBean <span class="title">cherryFactoryBean</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> CherryFactoryBean();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>测试从容器中获取：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ApplicationContext context = <span class="keyword">new</span> AnnotationConfigApplicationContext(WebConfig.class);</span><br><span class="line">Object cherry = context.getBean(<span class="string">"cherryFactoryBean"</span>);</span><br><span class="line">System.out.println(cherry.getClass());</span><br></pre></td></tr></table></figure><p></p><p>启动项目，观察控制台输出：</p><p><img src="img/QQ截图20190130103934.png" alt="QQ截图20190130103934.png"></p><p>可看到，虽然我们获取的是Id为<code>cherryFactoryBean</code>的组件，但其获取到的实际是<code>getObject</code>方法里返回的对象。</p><p>如果我们要获取<code>cherryFactoryBean</code>本身，则可以这样做：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Object cherryFactoryBean = context.getBean(<span class="string">"&amp;cherryFactoryBean"</span>);</span><br><span class="line">System.out.println(cherryFactoryBean.getClass());</span><br></pre></td></tr></table></figure><p></p><p>启动项目，观察控制台：</p><p><img src="img/QQ截图20190130104606.png" alt="QQ截图20190130104606.png"></p><p>为什么加上<code>&amp;</code>前缀就可以获取到相应的工厂类了呢，查看<code>BeanFactory</code>的源码会发现原因:</p><p><img src="img/QQ截图20190130104715.png" alt="QQ截图20190130104715.png"></p><blockquote><p>源码链接：<a href="https://github.com/wuyouzhuguli/SpringAll/tree/master/50.Spring-Regist-Bean" target="_blank" rel="noopener">https://github.com/wuyouzhuguli/SpringAll/tree/master/50.Spring-Regist-Bean</a></p></blockquote><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Thu Apr 04 2019 14:23:37 GMT+0800 (GMT+08:00) --&gt;&lt;p&gt;接触过Spring的同学肯定都听过IOC。在传统的Java编程中，当需要用到某个对象的时候，我们都是主动地显示创建一个对象实例（new）。使用Spring后就不需要这样做了，因为Spring会帮我们在需要用到某些对象的地方自动注入该对象，而无须我们自己去创建。这种模式俗称控制反转，即IOC（Inversion of Control）。那么Spring是从什么地方获取到我们所需要的对象呢？其实Spring给我们提供了一个IOC容器，里面管理着所有我们需要的对象，组件注册就是我们去告诉Spring哪些类需要交给IOC容器管理。&lt;/p&gt;&lt;p&gt;这里主要记录组件注册的一些细节。
    
    </summary>
    
    
      <category term="Spring" scheme="http://mrbird.cc/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>Dubbo的高可用</title>
    <link href="http://mrbird.cc/Dubbo-High-Availability.html"/>
    <id>http://mrbird.cc/Dubbo-High-Availability.html</id>
    <published>2018-07-15T06:42:16.000Z</published>
    <updated>2019-03-25T11:25:43.329Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Apr 04 2019 14:23:35 GMT+0800 (GMT+08:00) --><p>Dubbo的一些自身特性确保了Dubbo的高可用，比如当注册中心宕机后，服务提供者和服务消费者仍能通过本地缓存通讯；注册中心对等集群，任意一台宕掉后，将自动切换到另一台；当有多台服务提供者提供服务时，Dubbo内置了几种负载均衡算法，并且服务提供者是无状态的，任意一台宕掉后，不影响使用；我们还可以通过整合Hystrix来实现服务降级。</p><a id="more"></a><h2 id="注册中心"><a href="#注册中心" class="headerlink" title="注册中心"></a>注册中心</h2><p>这里模拟一下当所有服务注册中心宕机后，服务提供者和服务消费者是否能够正常通讯。</p><p>在上一节的例子上，启动Zookeeper，然后分别启动server-proivder和server-consumer，启动好后关闭Zookeeper，这时候注册中心是宕机的状态：</p><p><img src="img/QQ截图20190325142636.png" alt="QQ截图20190325142636.png"></p><p>访问<a href="http://localhost:8081/hello/mrbird" target="_blank" rel="noopener">http://localhost:8081/hello/mrbird</a>看是否可以成功消费服务：</p><p><img src="img/QQ截图20190325142710.png" alt="QQ截图20190325142710.png"></p><p>可以看到服务提供者和服务消费者通讯是正常的，因为注册中心负责服务地址的注册与查找，相当于目录服务，服务提供者和消费者只在启动时与注册中心交互，注册中心全部宕机，不影响已运行的提供者和消费者，消费者在本地缓存了提供者列表。</p><h2 id="Dubbo直连"><a href="#Dubbo直连" class="headerlink" title="Dubbo直连"></a>Dubbo直连</h2><p>使用注册中心来维护服务可以降低后期维护和拓展的复杂度，降低耦合。不过Dubbo也提供了绕过注册中心的方法，即服务消费者不通过注册中心，而是直接取访问服务提供者来获取服务，这种方式也称为Dubbo直连。</p><p>我们在服务消费者的<code>@Reference</code>注解上直接指定服务提供者的地址，即可实现Dubbo直连：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Reference</span>(url = <span class="string">"http://127.0.0.1:8080"</span>)</span><br><span class="line"><span class="keyword">private</span> HelloService helloService;</span><br></pre></td></tr></table></figure><p></p><h2 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h2><p>Dubbo提供了四种负载均衡机制：RandomLoadBalance，LeastActiveLoadBalance，ConsistentHashLoadBalance和RoundRobinLoadBalance。</p><p><img src="img/QQ截图20190325154012.png" alt="QQ截图20190325154012.png"></p><h3 id="RandomLoadBalance"><a href="#RandomLoadBalance" class="headerlink" title="RandomLoadBalance"></a>RandomLoadBalance</h3><p>RandomLoadBalance是基于权重的负载均衡机制。假如现在有一个由三个服务提供者构成的集群，Server1的权重为100，Server2的权重为200，Server3的权重为300，那么当一个服务消费请求发送过来时，有1/6的几率命中Server1，1/3的记录命中Server2，1/2的记录命中Server3。</p><h3 id="LeastActiveLoadBalance"><a href="#LeastActiveLoadBalance" class="headerlink" title="LeastActiveLoadBalance"></a>LeastActiveLoadBalance</h3><p>LeastActiveLoadBalance俗称最小活跃数负载均衡，假如现在有一个由Server1、Server2和Server3三个服务提供者构成的集群，在上一次请求中，Server1的耗时为100ms，Server2的耗时为200ms，Server3的耗时为300ms，那么当一个新的请求到来时，会命中耗时最少的那个服务，即Server1。</p><h3 id="ConsistentHashLoadBalance"><a href="#ConsistentHashLoadBalance" class="headerlink" title="ConsistentHashLoadBalance"></a>ConsistentHashLoadBalance</h3><p>详见官方文档介绍：<a href="http://dubbo.apache.org/zh-cn/docs/source_code_guide/loadbalance.html" target="_blank" rel="noopener">http://dubbo.apache.org/zh-cn/docs/source_code_guide/loadbalance.html</a>。</p><h3 id="RoundRobinLoadBalance"><a href="#RoundRobinLoadBalance" class="headerlink" title="RoundRobinLoadBalance"></a>RoundRobinLoadBalance</h3><p>RoundRobinLoadBalance是基于权重的轮询负载均衡机制，即服务请求在轮询的同时还得考虑权重。举个例子：</p><p>假如现在有一个由三个服务提供者构成的集群，Server1的权重为100，Server2的权重为200，Server3的权重为300，现在有6个服务消费请求依法发送过来，按照轮询机制，第1个请求命中Server1，第2个请求命中Server2，第3个请求命中Server3，到这里三个服务提供者已经轮询完一次，第4个请求本应该从新开始轮询，命中Server1，但是由于Server1的权重为100（占1/6，即6次只会命中一次），所以第4个请求会被分配到Server2。</p><p>接着轮询，第5个请求将命中Server3，第6个请求命中Server2。所以这6个请求命中的顺序为123232，这个概率和服务提供者的权重比相匹配。</p><h3 id="机制选择"><a href="#机制选择" class="headerlink" title="机制选择"></a>机制选择</h3><p>默认情况下，Dubbo采用RandomLoadBalance负载均衡机制。我们可以在服务提供者和服务消费者上指定使用哪种负载均衡：</p><p>在客户端的<code>@Reference</code>注解上指定：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Reference</span>(loadbalance = RoundRobinLoadBalance.NAME)</span><br><span class="line"><span class="keyword">private</span> HelloService helloService;</span><br></pre></td></tr></table></figure><p></p><p>在服务端的<code>@Server</code>注解上指定：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span>(interfaceClass = HelloService.class, loadbalance = RoundRobinLoadBalance.NAME)</span><br></pre></td></tr></table></figure><p></p><h3 id="权重分配"><a href="#权重分配" class="headerlink" title="权重分配"></a>权重分配</h3><p>我们可以在Dubbo提供的<code>@Server</code>注解上指定暴露服务的权重：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span>(interfaceClass = HelloService.class, weight = <span class="number">100</span>)</span><br></pre></td></tr></table></figure><p></p><p>这时候在Dubbo Admin里可以看到这个服务的权重就为100了：</p><p><img src="img/QQ截图20190325154803.png" alt="QQ截图20190325154803.png"></p><p>我们可以可以通过Dubbo Admin来动态调节服务的权重:</p><p><img src="img/QQ截图20190325154908.png" alt="QQ截图20190325154908.png"></p><h2 id="集群容错"><a href="#集群容错" class="headerlink" title="集群容错"></a>集群容错</h2><p>Dubbo支持多种容错模式：<a href="http://dubbo.apache.org/zh-cn/docs/user/demos/fault-tolerent-strategy.html" target="_blank" rel="noopener">http://dubbo.apache.org/zh-cn/docs/user/demos/fault-tolerent-strategy.html</a></p><h2 id="服务降级"><a href="#服务降级" class="headerlink" title="服务降级"></a>服务降级</h2><p>Dubbo默认支持两种降级策略:</p><ol><li><p>mock=force:return+null 表示消费方对该服务的方法调用都直接返回 null 值，不发起远程调用。用来屏蔽不重要服务不可用时对调用方的影响。</p></li><li><p>还可以改为 mock=fail:return+null 表示消费方对该服务的方法调用在失败后，再返回 null 值，不抛异常。用来容忍不重要服务不稳定时对调用方的影响。</p></li></ol><p>我们可以在Dubbo Admin控制台上来处理降级。</p><p>为了模拟错误情况，我们改造服务提供者实现的hello方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"调用 cc.mrbird.provider.service.HelloServiceImpl#hello"</span>);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"hello,"</span> + message;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>方法中让线程阻塞了2秒。</p><p>接着改造服务消费者，在<code>@Reference</code>注解上配置超时时间：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Reference</span>(timeout = <span class="number">1000</span>)</span><br><span class="line"><span class="keyword">private</span> HelloService helloService;</span><br></pre></td></tr></table></figure><p></p><p>在不进行服务降级的情况下，访问<a href="http://localhost:8081/hello/mrbird" target="_blank" rel="noopener">http://localhost:8081/hello/mrbird</a>将看抛出异常:</p><p><img src="img/QQ截图20190325172215.png" alt="QQ截图20190325172215.png"></p><p>在Dubbo Admin消费者列表上的屏蔽按钮对应mock=force:return+null策略，即不调用服务，直接返回null，</p><p><img src="img/QQ截图20190325172250.png" alt="QQ截图20190325172250.png"></p><p>点击屏蔽后，再次访问<a href="http://localhost:8081/hello/mrbird" target="_blank" rel="noopener">http://localhost:8081/hello/mrbird</a>：</p><p><img src="img/QQ截图20190325172756.png" alt="QQ截图20190325172756.png"></p><p>服务提供者的控制台也没有任何调用日志:</p><p><img src="img/QQ截图20190325172833.png" alt="QQ截图20190325172833.png"></p><p>而容错按钮则对应mock=fail:return+null机制。点击容错按钮，再次访问<a href="http://localhost:8081/hello/mrbird" target="_blank" rel="noopener">http://localhost:8081/hello/mrbird</a>：</p><p><img src="img/QQ截图20190325172756.png" alt="QQ截图20190325172756.png"></p><p><img src="img/QQ截图20190325182525.png" alt="QQ截图20190325182525.png"></p><p>上述结果证明了在mock=fail:return+null策略下，消费方对该服务的方法调用在失败后，再返回 null 值（之所以会输出多次调用日志，是因为Dubbo的重试机制）。</p><h3 id="整合Hystrix"><a href="#整合Hystrix" class="headerlink" title="整合Hystrix"></a>整合Hystrix</h3><p>我们可以通过整合Spring-Cloud-Hystrix和Dubbo来拓展服务降级。</p><p>在server-provider里引入Hystrix依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-hystrix<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0.2.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p></p><p>然后再server-provider的入口类上使用<code>@EnableHystrix</code>注解开启Hystrix功能。</p><p>接着改造server-provider的HelloServiceImpl：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span>(interfaceClass = HelloService.classE)</span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloServiceImpl</span> <span class="keyword">implements</span> <span class="title">HelloService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@HystrixCommand</span>(fallbackMethod = <span class="string">"defaultHello"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"调用 cc.mrbird.provider.service.HelloServiceImpl#hello"</span>);</span><br><span class="line">        String a = <span class="keyword">null</span>;</span><br><span class="line">        a.toString();</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"hello,"</span> + message;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">defaultHello</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"hello anonymous"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>在<code>hello</code>方法中，我们制造一个空指针异常，通过<code>@HystrixCommand(fallbackMethod = &quot;defaultHello&quot;)</code>指定了降级的方法为<code>defaultHello</code>。值得注意的是，降级方法的方法参数和返回类型必须和原方法保持一致，不熟悉的读者可以参考<a href="https://mrbird.cc/Spring-Cloud-Hystrix-Circuit-Breaker.html">https://mrbird.cc/Spring-Cloud-Hystrix-Circuit-Breaker.html</a>。</p><p>改造好后，重启服务提供者和服务消费者，访问<a href="http://localhost:8081/hello/mrbird" target="_blank" rel="noopener">http://localhost:8081/hello/mrbird</a>：</p><p><img src="img/QQ截图20190325191901.png" alt="QQ截图20190325191901.png"></p><p>可见服务已经成功降级。</p><blockquote><p>源码链接：<a href="https://github.com/wuyouzhuguli/SpringAll/tree/master/53.Dubbo-High-Availability" target="_blank" rel="noopener">https://github.com/wuyouzhuguli/SpringAll/tree/master/53.Dubbo-High-Availability</a></p></blockquote><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Thu Apr 04 2019 14:23:35 GMT+0800 (GMT+08:00) --&gt;&lt;p&gt;Dubbo的一些自身特性确保了Dubbo的高可用，比如当注册中心宕机后，服务提供者和服务消费者仍能通过本地缓存通讯；注册中心对等集群，任意一台宕掉后，将自动切换到另一台；当有多台服务提供者提供服务时，Dubbo内置了几种负载均衡算法，并且服务提供者是无状态的，任意一台宕掉后，不影响使用；我们还可以通过整合Hystrix来实现服务降级。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Dubbo" scheme="http://mrbird.cc/tags/Dubbo/"/>
    
  </entry>
  
</feed>
